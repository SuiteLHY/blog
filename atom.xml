<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dunwu</title>
  
  <subtitle>大道至简，知易行难</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://dunwu.github.io/blog/"/>
  <updated>2019-08-21T05:20:27.895Z</updated>
  <id>https://dunwu.github.io/blog/</id>
  
  <author>
    <name>Zhang Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式技术面试题</title>
    <link href="https://dunwu.github.io/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://dunwu.github.io/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2019-10-25T06:31:53.508Z</published>
    <updated>2019-08-21T05:20:27.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式技术面试题"><a class="markdownIt-Anchor" href="#分布式技术面试题"></a> 分布式技术面试题</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">1. 分布式缓存</a><ul><li><a href="#11-redis-%E6%9C%89%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF">1.1. Redis 有什么数据类型？分别用于什么场景？</a></li><li><a href="#12-redis-%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">1.2. Redis 的主从复制是如何实现的？</a></li><li><a href="#13-redis-%E7%9A%84-key-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84">1.3. Redis 的 key 是如何寻址的？</a></li><li><a href="#14-redis-%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">1.4. Redis 的集群模式是如何实现的？</a></li><li><a href="#15-redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81zookeeper-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%AF%94%E8%BE%83%E4%BA%8C%E8%80%85%E4%BC%98%E5%8A%A3">1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</a></li><li><a href="#16-redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</a></li><li><a href="#17-redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">1.7. Redis 过期策略有哪些？</a></li><li><a href="#18-redis-%E5%92%8C-memcached-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">1.8. Redis 和 Memcached 有什么区别？</a></li><li><a href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-redis-%E6%80%A7%E8%83%BD%E5%8F%8D%E8%80%8C%E4%BC%98%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84-memcached">1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</a></li></ul></li><li><a href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq">2. 分布式消息队列（MQ）</a><ul><li><a href="#21-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-mq">2.1. 为什么使用 MQ？</a></li><li><a href="#22-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-mq-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">2.2. 如何保证 MQ 的高可用？</a></li><li><a href="#23-mq-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98">2.3. MQ 有哪些常见问题？如何解决这些问题？</a></li><li><a href="#24-kafka-activemq-rabbitmq-rocketmq-%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9">2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</a></li></ul></li><li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1rpc">3. 分布式服务（RPC）</a><ul><li><a href="#31-dubbo-%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">3.1. Dubbo 的实现过程？</a></li><li><a href="#32-dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">3.2. Dubbo 负载均衡策略有哪些？</a></li><li><a href="#33-dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5-">3.3. Dubbo 集群容错策略 ？</a></li><li><a href="#34-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5">3.4. 动态代理策略？</a></li><li><a href="#35-dubbo-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AEhessianhessian-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</a></li><li><a href="#36-protoco-buffer-%E6%98%AF%E4%BB%80%E4%B9%88">3.6. Protoco Buffer 是什么？</a></li><li><a href="#37-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%8C%82%E4%BA%86%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E9%80%9A%E4%BF%A1%E5%90%97">3.7. 注册中心挂了可以继续通信吗？</a></li><li><a href="#38-zookeeper-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88zookeeper-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</a></li><li><a href="#39-netty-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8niobioaio-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</a></li><li><a href="#310-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%8B%86%E5%88%86%E4%B8%8D%E7%94%A8-dubbo-%E5%8F%AF%E4%BB%A5%E5%90%97">3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</a></li><li><a href="#311-dubbo-%E5%92%8C-thrift-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">3.11. Dubbo 和 Thrift 有什么区别？</a></li></ul></li></ul><!-- /TOC --><h2 id="1-分布式缓存"><a class="markdownIt-Anchor" href="#1-分布式缓存"></a> 1. 分布式缓存</h2><h3 id="11-redis-有什么数据类型分别用于什么场景"><a class="markdownIt-Anchor" href="#11-redis-有什么数据类型分别用于什么场景"></a> 1.1. Redis 有什么数据类型？分别用于什么场景？</h3><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h3 id="12-redis-的主从复制是如何实现的"><a class="markdownIt-Anchor" href="#12-redis-的主从复制是如何实现的"></a> 1.2. Redis 的主从复制是如何实现的？</h3><ol><li>从服务器连接主服务器，发送 SYNC 命令；</li><li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li><li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ol><h3 id="13-redis-的-key-是如何寻址的"><a class="markdownIt-Anchor" href="#13-redis-的-key-是如何寻址的"></a> 1.3. Redis 的 key 是如何寻址的？</h3><h4 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h4><p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p><ul><li><a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 存储着 redis 数据库以整数表示的号码。</li><li>redisDb.dict 存储着该库所有的键值对数据。</li><li>redisDb.expires 保存着每一个键的过期时间。</li></ul><p>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 <a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 即可。</p><p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p><p>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p><h4 id="寻址-key-的步骤"><a class="markdownIt-Anchor" href="#寻址-key-的步骤"></a> 寻址 key 的步骤</h4><ol><li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li><li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次_dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</li><li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li><li>根据哈希值与当前字典计算哈希表的索引值。</li><li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li><li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li></ol><h3 id="14-redis-的集群模式是如何实现的"><a class="markdownIt-Anchor" href="#14-redis-的集群模式是如何实现的"></a> 1.4. Redis 的集群模式是如何实现的？</h3><p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。</p><p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p><h4 id="redis-cluster-节点分配"><a class="markdownIt-Anchor" href="#redis-cluster-节点分配"></a> Redis Cluster 节点分配</h4><p>Redis Cluster 特点：</p><ol><li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li><li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。</li><li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li></ol><h4 id="redis-cluster-主从模式"><a class="markdownIt-Anchor" href="#redis-cluster-主从模式"></a> Redis Cluster 主从模式</h4><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p><p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p><h4 id="redis-sentinel"><a class="markdownIt-Anchor" href="#redis-sentinel"></a> Redis Sentinel</h4><p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p><ul><li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p><p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。</p><p>假设集群仅仅部署 2 个节点</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure><p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p><h3 id="15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"><a class="markdownIt-Anchor" href="#15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"></a> 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3><p>分布式锁的三种实现：</p><ul><li>基于数据库实现分布式锁；</li><li>基于缓存（Redis 等）实现分布式锁；</li><li>基于 Zookeeper 实现分布式锁；</li></ul><h4 id="数据库实现"><a class="markdownIt-Anchor" href="#数据库实现"></a> 数据库实现</h4><h4 id="redis-实现"><a class="markdownIt-Anchor" href="#redis-实现"></a> Redis 实现</h4><ol><li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li><li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ol><h4 id="zookeeper-实现"><a class="markdownIt-Anchor" href="#zookeeper-实现"></a> ZooKeeper 实现</h4><ol><li>创建一个目录 mylock；</li><li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li><li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol><h4 id="实现对比"><a class="markdownIt-Anchor" href="#实现对比"></a> 实现对比</h4><p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br />但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p><h3 id="16-redis-的持久化方式有什么优缺点持久化实现原理"><a class="markdownIt-Anchor" href="#16-redis-的持久化方式有什么优缺点持久化实现原理"></a> 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</h3><h4 id="rdb-快照snapshot"><a class="markdownIt-Anchor" href="#rdb-快照snapshot"></a> RDB 快照（snapshot）</h4><p>将存在于某一时刻的所有数据都写入到硬盘中。</p><h5 id="快照的原理"><a class="markdownIt-Anchor" href="#快照的原理"></a> 快照的原理</h5><p>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。</p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p><ul><li>Redis 创建一个子进程。</li><li>子进程将数据集写入到一个临时快照文件中。</li><li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li></ul><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h5 id="快照的优点"><a class="markdownIt-Anchor" href="#快照的优点"></a> 快照的优点</h5><ul><li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li><li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li><li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li><li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li></ul><h5 id="快照的缺点"><a class="markdownIt-Anchor" href="#快照的缺点"></a> 快照的缺点</h5><ul><li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li><li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li></ul><h4 id="aof"><a class="markdownIt-Anchor" href="#aof"></a> AOF</h4><p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p><h4 id="aof-的原理"><a class="markdownIt-Anchor" href="#aof-的原理"></a> AOF 的原理</h4><ul><li>Redis 创建一个子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ul><h4 id="aof-的优点"><a class="markdownIt-Anchor" href="#aof-的优点"></a> AOF 的优点</h4><ul><li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li><li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li></ul><h4 id="aof-的缺点"><a class="markdownIt-Anchor" href="#aof-的缺点"></a> AOF 的缺点</h4><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li></ul><h3 id="17-redis-过期策略有哪些"><a class="markdownIt-Anchor" href="#17-redis-过期策略有哪些"></a> 1.7. Redis 过期策略有哪些？</h3><ul><li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li><li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li><li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li><li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li><li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li><li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li></ul><h3 id="18-redis-和-memcached-有什么区别"><a class="markdownIt-Anchor" href="#18-redis-和-memcached-有什么区别"></a> 1.8. Redis 和 Memcached 有什么区别？</h3><p>两者都是非关系型内存键值数据库。有以下主要不同：</p><p><strong>数据类型</strong></p><ul><li>Memcached 仅支持字符串类型；</li><li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li></ul><p><strong>数据持久化</strong></p><ul><li>Memcached 不支持持久化；</li><li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li></ul><p><strong>分布式</strong></p><ul><li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li><li>Redis Cluster 实现了分布式的支持。</li></ul><p><strong>内存管理机制</strong></p><ul><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li></ul><h3 id="19-为什么单线程的-redis-性能反而优于多线程的-memcached"><a class="markdownIt-Anchor" href="#19-为什么单线程的-redis-性能反而优于多线程的-memcached"></a> 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3><p>Redis 快速的原因：</p><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程,避免了不必要的上下文切换和竞争条件</li><li>非阻塞 IO</li></ol><p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p><h2 id="2-分布式消息队列mq"><a class="markdownIt-Anchor" href="#2-分布式消息队列mq"></a> 2. 分布式消息队列（MQ）</h2><h3 id="21-为什么使用-mq"><a class="markdownIt-Anchor" href="#21-为什么使用-mq"></a> 2.1. 为什么使用 MQ？</h3><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li>日志处理 - 解决大量日志传输。</li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h3 id="22-如何保证-mq-的高可用"><a class="markdownIt-Anchor" href="#22-如何保证-mq-的高可用"></a> 2.2. 如何保证 MQ 的高可用？</h3><h4 id="数据复制"><a class="markdownIt-Anchor" href="#数据复制"></a> 数据复制</h4><ol><li>将所有 Broker 和待分配的 Partition 排序</li><li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li><li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li></ol><h4 id="选举主服务器"><a class="markdownIt-Anchor" href="#选举主服务器"></a> 选举主服务器</h4><h3 id="23-mq-有哪些常见问题如何解决这些问题"><a class="markdownIt-Anchor" href="#23-mq-有哪些常见问题如何解决这些问题"></a> 2.3. MQ 有哪些常见问题？如何解决这些问题？</h3><p>MQ 的常见问题有：</p><ol><li>消息的顺序问题</li><li>消息的重复问题</li></ol><h4 id="消息的顺序问题"><a class="markdownIt-Anchor" href="#消息的顺序问题"></a> 消息的顺序问题</h4><p>消息有序指的是可以按照消息的发送顺序来消费。</p><p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-23145c8b554a0f2f.jpg"/></div><p>解决方案：</p><p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-034106d7e04c062d.jpg"/></div><p>缺陷：</p><ul><li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li><li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li></ul><p>（2）通过合理的设计或者将问题分解来规避。</p><ul><li>不关注乱序的应用实际大量存在</li><li>队列无序并不意味着消息无序</li></ul><p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p><h4 id="消息的重复问题"><a class="markdownIt-Anchor" href="#消息的重复问题"></a> 消息的重复问题</h4><p>造成消息重复的根本原因是：网络不可达。</p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p><p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br />保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p><h3 id="24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"><a class="markdownIt-Anchor" href="#24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"></a> 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c26f4a3048c38af4.jpg"/></div><h2 id="3-分布式服务rpc"><a class="markdownIt-Anchor" href="#3-分布式服务rpc"></a> 3. 分布式服务（RPC）</h2><h3 id="31-dubbo-的实现过程"><a class="markdownIt-Anchor" href="#31-dubbo-的实现过程"></a> 3.1. Dubbo 的实现过程？</h3><div align="center"><img src="http://dunwu.test.upcdn.net/cs/distributed/rpc/dubbo/dubbo基本架构.png" width="500"/></div><p>节点角色：</p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><p>调用关系：</p><ol><li>务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="32-dubbo-负载均衡策略有哪些"><a class="markdownIt-Anchor" href="#32-dubbo-负载均衡策略有哪些"></a> 3.2. Dubbo 负载均衡策略有哪些？</h3><h5 id="random"><a class="markdownIt-Anchor" href="#random"></a> Random</h5><ul><li>随机，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><h5 id="roundrobin"><a class="markdownIt-Anchor" href="#roundrobin"></a> RoundRobin</h5><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><h5 id="leastactive"><a class="markdownIt-Anchor" href="#leastactive"></a> LeastActive</h5><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><h5 id="consistenthash"><a class="markdownIt-Anchor" href="#consistenthash"></a> ConsistentHash</h5><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li><li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li><li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li></ul><h3 id="33-dubbo-集群容错策略"><a class="markdownIt-Anchor" href="#33-dubbo-集群容错策略"></a> 3.3. Dubbo 集群容错策略 ？</h3><div align="center"><img src="http://dunwu.test.upcdn.net/cs/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg"/></div><ul><li><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</li><li><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</li><li><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul><h3 id="34-动态代理策略"><a class="markdownIt-Anchor" href="#34-动态代理策略"></a> 3.4. 动态代理策略？</h3><p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p><div align="center"><img src="https://oscimg.oschina.net/oscnet/bef19cd5a31b5ae13aff35a8cb4898faaf0.jpg"/></div><p>消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是<strong>ProxyFactory</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p><h3 id="35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"><a class="markdownIt-Anchor" href="#35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"></a> 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3><ol><li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li><li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li><li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li><li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li><li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li></ol><p>Hessian 序列化与 Java 默认的序列化区别？</p><p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p><ol><li>Hessian 支持跨语言串行</li><li>比 java 序列化具有更好的性能和易用性</li><li>支持的语言比较多</li></ol><h3 id="36-protoco-buffer-是什么"><a class="markdownIt-Anchor" href="#36-protoco-buffer-是什么"></a> 3.6. Protoco Buffer 是什么？</h3><p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</p><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p><ol><li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li><li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li></ol><p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p><ol><li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li><li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li></ol><h3 id="37-注册中心挂了可以继续通信吗"><a class="markdownIt-Anchor" href="#37-注册中心挂了可以继续通信吗"></a> 3.7. 注册中心挂了可以继续通信吗？</h3><p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p><h3 id="38-zookeeper-原理是什么zookeeper-有什么用"><a class="markdownIt-Anchor" href="#38-zookeeper-原理是什么zookeeper-有什么用"></a> 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3><p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/distributed/rpc/zookeeper/zookeeper-service.png" /></div><ol><li>每个 Server 在内存中存储了一份数据；</li><li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li><li>Leader 负责处理数据更新等操作（Zab 协议）；</li><li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li></ol><h3 id="39-netty-有什么用niobioaio-有什么用有什么区别"><a class="markdownIt-Anchor" href="#39-netty-有什么用niobioaio-有什么用有什么区别"></a> 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</h3><p>Netty 是一个“网络通讯框架”。</p><p>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p><div align="center"><img src="https://camo.githubusercontent.com/5f7331d15c79fba29474c5be6e9e86db465637c3/687474703a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f73706163652f323031332f303932312f3137343033325f313872625f3139303539312e706e67"/></div><blockquote><p>参考：<a href="https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md" target="_blank" rel="noopener">https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md</a></p></blockquote><p>IO 的方式通常分为几种：</p><ul><li>同步阻塞的 BIO</li><li>同步非阻塞的 NIO</li><li>异步非阻塞的 AIO</li></ul><p>在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p><p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p><p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。</p><blockquote><p>参考：<a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">https://blog.csdn.net/skiof007/article/details/52873421</a></p></blockquote><h3 id="310-为什么要进行系统拆分拆分不用-dubbo-可以吗"><a class="markdownIt-Anchor" href="#310-为什么要进行系统拆分拆分不用-dubbo-可以吗"></a> 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3><p>系统拆分从资源角度分为：应用拆分和数据库拆分。</p><p>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p><div align="center"><img src="http://misc.linkedkeeper.com/misc/img/blog/201804/linkedkeeper0_9c2ed2ed-6156-40f7-ad08-20af067047ca.jpg"/></div><p>是否使用服务依据实际业务场景来决定。</p><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h3 id="311-dubbo-和-thrift-有什么区别"><a class="markdownIt-Anchor" href="#311-dubbo-和-thrift-有什么区别"></a> 3.11. Dubbo 和 Thrift 有什么区别？</h3><ul><li>Thrift 是跨语言的 RPC 框架。</li><li>Dubbo 支持服务治理，而 Thrift 不支持。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式技术面试题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式技术面试题&quot;&gt;&lt;/a&gt; 分布式技术面试题&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/blog/categories/design/architecture/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/blog/tags/architecture/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/tags/distributed/"/>
    
      <category term="interview" scheme="https://dunwu.github.io/blog/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>bigdata/README</title>
    <link href="https://dunwu.github.io/blog/bigdata/README/"/>
    <id>https://dunwu.github.io/blog/bigdata/README/</id>
    <published>2019-10-25T06:31:53.460Z</published>
    <updated>2019-10-21T09:38:25.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据"><a class="markdownIt-Anchor" href="#大数据"></a> 大数据</h1><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><ul><li><a href="MapReduce.md">MapReduce</a></li><li><a href="HDFS.md">HDFS</a></li><li><a href="YARN.md">YARN</a></li><li><a href="hbase">HBase</a><ul><li><a href="hbase/hbase-cli.md">HBase 命令</a></li><li><a href="hbase/hbase-ops.md">HBase 配置</a></li></ul></li></ul><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><h3 id="书"><a class="markdownIt-Anchor" href="#书"></a> 书</h3><p><a href="https://book.douban.com/subject/6523762/" target="_blank" rel="noopener">Hadoop 权威指南</a></p><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#大数据&quot;&gt;&lt;/a&gt; 大数据&lt;/h1&gt;
&lt;h2 id=&quot;知识点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#知识点&quot;&gt;&lt;/a&gt; 📝 知识点&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="hide" scheme="https://dunwu.github.io/blog/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>分布式存储</title>
    <link href="https://dunwu.github.io/blog/design/distributed/distributed-storage/"/>
    <id>https://dunwu.github.io/blog/design/distributed/distributed-storage/</id>
    <published>2019-08-21T03:30:00.000Z</published>
    <updated>2019-09-03T12:44:04.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式存储"><a class="markdownIt-Anchor" href="#分布式存储"></a> 分布式存储</h1><h2 id="分区规则"><a class="markdownIt-Anchor" href="#分区规则"></a> 分区规则</h2><p><strong>分布式数据库</strong> 首先要解决把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-rule.png!zp" /></div><p>数据分布通常有 <strong>哈希分区</strong> 和 <strong>顺序分区</strong> 两种方式，对比如下：</p><table><thead><tr><th style="text-align:left">分区方式</th><th style="text-align:left">特点</th><th style="text-align:left">相关产品</th></tr></thead><tbody><tr><td style="text-align:left">哈希分区</td><td style="text-align:left">离散程度好，数据分布与业务无关，无法顺序访问</td><td style="text-align:left">Redis Cluster，Cassandra，Dynamo</td></tr><tr><td style="text-align:left">顺序分区</td><td style="text-align:left">离散程度易倾斜，数据分布与业务相关，可以顺序访问</td><td style="text-align:left">BigTable，HBase，Hypertable</td></tr></tbody></table><p>由于 <code>Redis Cluster</code> 采用 <strong>哈希分区规则</strong>，这里重点讨论 <strong>哈希分区</strong>。常见的 <strong>哈希分区</strong> 规则有几种，下面分别介绍：</p><h3 id="节点取余分区"><a class="markdownIt-Anchor" href="#节点取余分区"></a> 节点取余分区</h3><p>使用特定的数据，如 <code>Redis</code> 的 <strong>键</strong> 或 <strong>用户</strong> <code>ID</code>，再根据 <strong>节点数量</strong> <code>N</code> 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong>，用来决定数据 <strong>映射</strong> 到哪一个节点上。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-mod.png!zp" /></div><ul><li><strong>优点</strong></li></ul><p>这种方式的突出优点是 <strong>简单性</strong>，常用于 <strong>数据库</strong> 的 <strong>分库分表规则</strong>。一般采用 <strong>预分区</strong> 的方式，提前根据 <strong>数据量</strong> 规划好 <strong>分区数</strong>，比如划分为 <code>512</code> 或 <code>1024</code> 张表，保证可支撑未来一段时间的 <strong>数据容量</strong>，再根据 <strong>负载情况</strong> 将 <strong>表</strong> 迁移到其他 <strong>数据库</strong> 中。扩容时通常采用 <strong>翻倍扩容</strong>，避免 <strong>数据映射</strong> 全部被 <strong>打乱</strong>，导致 <strong>全量迁移</strong> 的情况。</p><ul><li><strong>缺点</strong></li></ul><p>当 <strong>节点数量</strong> 变化时，如 <strong>扩容</strong> 或 <strong>收缩</strong> 节点，数据节点 <strong>映射关系</strong> 需要重新计算，会导致数据的 <strong>重新迁移</strong>。</p><h3 id="一致性哈希分区"><a class="markdownIt-Anchor" href="#一致性哈希分区"></a> 一致性哈希分区</h3><p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-consistent-hash.png!zp" /></div><ul><li><strong>优点</strong></li></ul><p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p><ul><li><strong>缺点</strong></li></ul><p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong> 将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p><blockquote><p><strong>注意</strong>：因为 <strong>一致性哈希分区</strong> 的这些缺点，一些分布式系统采用 <strong>虚拟槽</strong> 对 <strong>一致性哈希</strong> 进行改进，比如 <code>Dynamo</code> 系统。</p></blockquote><h3 id="虚拟槽分区"><a class="markdownIt-Anchor" href="#虚拟槽分区"></a> 虚拟槽分区</h3><p><strong>虚拟槽分区</strong> 巧妙地使用了 <strong>哈希空间</strong>，使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>）。这个范围一般 <strong>远远大于</strong> 节点数，比如 <code>Redis Cluster</code> 槽范围是 <code>0 ~ 16383</code>。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>，如图所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/architecture/partition-hash-slot.png!zp" /></div>当前集群有 `3` 个节点，每个节点平均大约负责 `5460` 个 **槽**。由于采用 **高质量** 的 **哈希算法**，每个槽所映射的数据通常比较 **均匀**，将数据平均划分到 `3` 个节点进行 **数据分区**。`Redis Cluster` 就是采用 **虚拟槽分区**。<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p><ul><li>节点Ａ存储的哈希槽范围是：0 – 5460</li><li>节点Ｂ存储的哈希槽范围是：5461 – 10922</li><li>节点Ｃ存储的哈希槽范围是：10923 – 16383</li></ul><p>这种结构很容易 <strong>添加</strong> 或者 <strong>删除</strong> 节点。如果 <strong>增加</strong> 一个节点 <code>4</code>，就需要从节点 <code>1 ~ 3</code> 获得部分 <strong>槽</strong> 分配到节点 <code>4</code> 上。如果想 <strong>移除</strong> 节点 <code>1</code>，需要将节点 <code>1</code> 中的 <strong>槽</strong> 移到节点 <code>2 ~ 3</code> 上，然后将 <strong>没有任何槽</strong> 的节点 <code>1</code> 从集群中 <strong>移除</strong> 即可。</p><blockquote><p>由于从一个节点将 <strong>哈希槽</strong> 移动到另一个节点并不会 <strong>停止服务</strong>，所以无论 <strong>添加删除</strong> 或者 <strong>改变</strong> 某个节点的 <strong>哈希槽的数量</strong> 都不会造成 <strong>集群不可用</strong> 的状态.</p></blockquote><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式存储&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式存储&quot;&gt;&lt;/a&gt; 分布式存储&lt;/h1&gt;
&lt;h2 id=&quot;分区规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分区规则&quot;&gt;&lt;/a&gt; 分区规则&lt;
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/categories/design/distributed/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>分布式 ID</title>
    <link href="https://dunwu.github.io/blog/design/distributed/distributed-id/"/>
    <id>https://dunwu.github.io/blog/design/distributed/distributed-id/</id>
    <published>2019-07-24T03:55:00.000Z</published>
    <updated>2019-08-21T04:00:04.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式-id"><a class="markdownIt-Anchor" href="#分布式-id"></a> 分布式 ID</h1><h2 id="uuid"><a class="markdownIt-Anchor" href="#uuid"></a> UUID</h2><p>UUID 是通用唯一识别码（Universally Unique Identifier)的缩写，开放软件基金会(OSF)规范定义了包括网卡 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。利用这些元素来生成 UUID。</p><p>UUID 是由 128 位二进制组成，一般转换成十六进制，然后用 String 表示。在 java 中有个 UUID 类,在他的注释中我们看见这里有 4 种不同的 UUID 的生成策略:</p><ul><li>random - 基于随机数生成 UUID，由于 Java 中的随机数是伪随机数，其重复的概率是可以被计算出来的。这个一般我们用下面的代码获取基于随机数的 UUID:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String id = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><ul><li>time-based - 基于时间的 UUID,这个一般是通过当前时间，随机数，和本地 Mac 地址来计算出来，自带的 JDK 包并没有这个算法的我们在一些 UUIDUtil 中，比如我们的 log4j.core.util，会重新定义 UUID 的高位和低位。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UUID <span class="title">getTimeBasedUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() * <span class="number">10000L</span> + <span class="number">122192928000000000L</span> + (<span class="keyword">long</span>)(COUNT.incrementAndGet() % <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">long</span> timeLow = (time &amp; <span class="number">4294967295L</span>) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">long</span> timeMid = (time &amp; <span class="number">281470681743360L</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">long</span> timeHi = (time &amp; <span class="number">1152640029630136320L</span>) &gt;&gt; <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">long</span> most = timeLow | timeMid | <span class="number">4096L</span> | timeHi;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UUID(most, LEAST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>DCE security - DCE 安全的 UUID。</p></li><li><p>name-based - 基于名字的 UUID，通过计算名字和名字空间的 MD5 来计算 UUID。</p></li></ul><p>UUID 的优点:</p><ul><li>通过本地生成，没有经过网络 I/O，性能较快</li></ul><p>UUID 的缺点:</p><ul><li><strong>长度过长</strong> - UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：Mysql 官方明确建议主键越短越好，36 个字符长度的 UUID 不符合要求。</li><li><strong>信息不安全</strong> - 基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li><li><strong>无序性</strong> - 不能生成递增有序的数字。这对于一些特定场景不利。例如：如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。</li></ul><p>适用场景：UUID 的适用场景可以为不需要担心过多的空间占用，以及不需要生成有递增趋势的数字。在 Log4j 里 <code>UuidPatternConverter</code> 中加入了 UUID 来标识每一条日志。</p><h2 id="数据库主键自增"><a class="markdownIt-Anchor" href="#数据库主键自增"></a> 数据库主键自增</h2><p>大家对于唯一标识最容易想到的就是主键自增，这个也是我们最常用的方法。例如我们有个订单服务，那么把订单 id 设置为主键自增即可。</p><p>优点:</p><ul><li>简单方便，有序递增，方便排序和分页</li></ul><p>缺点:</p><ul><li>分库分表会带来问题，需要进行改造。</li><li>并发性能不高，受限于数据库的性能。</li><li>简单递增容易被其他人猜测利用，比如你有一个用户服务用的递增，那么其他人可以根据分析注册的用户 ID 来得到当天你的服务有多少人注册，从而就能猜测出你这个服务当前的一个大概状况。</li><li>数据库宕机服务不可用。</li></ul><p>适用场景: 根据上面可以总结出来，当数据量不多，并发性能不高的时候这个很适合，比如一些 to B 的业务，商家注册这些，商家注册和用户注册不是一个数量级的，所以可以数据库主键递增。如果对顺序递增强依赖，那么也可以使用数据库主键自增。</p><h2 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h2><p>熟悉 Redis 的同学，应该知道在 Redis 中有两个命令 Incr，IncrBy,因为 Redis 是单线程的所以能保证原子性。</p><p>优点：</p><ul><li>性能比数据库好，能满足有序递增。</li></ul><p>缺点：</p><ul><li>由于 redis 是内存的 KV 数据库，即使有 AOF 和 RDB，但是依然会存在数据丢失，有可能会造成 ID 重复。</li><li>依赖于 redis，redis 要是不稳定，会影响 ID 生成。</li></ul><p>适用：由于其性能比数据库好，但是有可能会出现 ID 重复和不稳定，这一块如果可以接受那么就可以使用。也适用于到了某个时间，比如每天都刷新 ID，那么这个 ID 就需要重置，通过(Incr Today)，每天都会从 0 开始加。</p><h2 id="zookeeper"><a class="markdownIt-Anchor" href="#zookeeper"></a> Zookeeper</h2><p>利用 ZK 的 Znode 数据版本如下面的代码，每次都不获取期望版本号也就是每次都会成功，那么每次都会返回最新的版本号:</p><div align="center"><img src="https://user-gold-cdn.xitu.io/2018/9/29/166243d8d5897f41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/></div><p>Zookeeper 这个方案用得较少，严重依赖 Zookeeper 集群，并且性能不是很高，所以不予推荐。</p><h2 id="数据库分段服务缓存-id"><a class="markdownIt-Anchor" href="#数据库分段服务缓存-id"></a> 数据库分段+服务缓存 ID</h2><p>这个方法在美团的 Leaf 中有介绍，详情可以参考美团技术团队的发布的技术文章:<a href="https://link.juejin.im?target=https%3A%2F%2Ftech.meituan.com%2FMT_Leaf.html">Leaf——美团点评分布式 ID 生成系统</a>,这个方案是将数据库主键自增进行优化。</p><div align="center"><img src="https://user-gold-cdn.xitu.io/2018/9/29/1662445bec45eb5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/></div><p>biz_tag 代表每个不同的业务，max_id 代表每个业务设置的大小，step 代表每个 proxyServer 缓存的步长。 之前我们的每个服务都访问的是数据库，现在不需要，每个服务直接和我们的 ProxyServer 做交互，减少了对数据库的依赖。我们的每个 ProxyServer 回去数据库中拿出步长的长度，比如 server1 拿到了 1-1000,server2 拿到来 1001-2000。如果用完会再次去数据库中拿。</p><p>优点:</p><ul><li>比主键递增性能高，能保证趋势递增。</li><li>如果 DB 宕机，proxServer 由于有缓存依然可以坚持一段时间。</li></ul><p>缺点:</p><ul><li>和主键递增一样，容易被人猜测。</li><li>DB 宕机，虽然能支撑一段时间但是仍然会造成系统不可用。</li></ul><p>适用场景:需要趋势递增，并且 ID 大小可控制的，可以使用这套方案。</p><p>当然这个方案也可以通过一些手段避免被人猜测，把 ID 变成是无序的，比如把我们生成的数据是一个递增的 long 型，把这个 Long 分成几个部分，比如可以分成几组三位数，几组四位数，然后在建立一个映射表，将我们的数据变成无序。</p><h2 id="雪花算法-snowflake"><a class="markdownIt-Anchor" href="#雪花算法-snowflake"></a> 雪花算法-Snowflake</h2><p>算法原理：</p><p>Snowflake 是 Twitter 提出来的一个算法，其目的是生成一个 64bit 的整数:</p><div align="center"><img src="https://user-gold-cdn.xitu.io/2018/9/29/16624602fd5d9c4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/></div><ul><li>1bit:一般是符号位，不做处理</li><li>41bit:用来记录时间戳，这里可以记录 69 年，如果设置好起始时间比如今年是 2018 年，那么可以用到 2089 年，到时候怎么办？要是这个系统能用 69 年，我相信这个系统早都重构了好多次了。</li><li>10bit:10bit 用来记录机器 ID，总共可以记录 1024 台机器，一般用前 5 位代表数据中心，后面 5 位是某个数据中心的机器 ID</li><li>12bit:循环位，用来对同一个毫秒之内产生不同的 ID，12 位可以最多记录 4095 个，也就是在同一个机器同一毫秒最多记录 4095 个，多余的需要进行等待下毫秒。</li></ul><p>上面只是一个将 64bit 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p><ul><li>服务目前 QPS10 万，预计几年之内会发展到百万。</li><li>当前机器三地部署，上海，北京，深圳都有。</li><li>当前机器 10 台左右，预计未来会增加至百台。</li></ul><p>这个时候我们根据上面的场景可以再次合理的划分 62bit,QPS 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p><p>机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit,那么还剩下 64-10-3-7-41-1 = 2bit,还剩下 2bit 可以用来进行扩展。</p><div align="center"><img src="https://user-gold-cdn.xitu.io/2018/9/29/16624909d2007c22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/></div><p>适用场景:当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。</p><p>优点：</p><ul><li>毫秒数在高位，自增序列在低位，整个 ID 都是趋势递增的。</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</li><li>可以根据自身业务特性分配 bit 位，非常灵活。</li></ul><p>缺点：</p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><h3 id="一个简单的-snowflake"><a class="markdownIt-Anchor" href="#一个简单的-snowflake"></a> 一个简单的 Snowflake</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedId</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId; <span class="comment">// 这个就是代表了机器id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId; <span class="comment">// 这个就是代表了机房id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence; <span class="comment">// 这个就是代表了一毫秒内生成的多个id的最新序号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedId</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId, <span class="keyword">long</span> sequence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sanity check for workerId</span></span><br><span class="line">        <span class="comment">// 这儿就不检查了，要求就是你传递进来的机房id和机器id不能超过32，不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是二进制运算，就是5 bit最多只能有31个数字，也就是说机器id最多只能是32以内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是一个意思，就是5 bit最多只能有31个数字，机房id最多只能是32以内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getWorkerId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDatacenterId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是核心方法，通过调用nextId()方法，让当前这台机器上的snowflake算法程序生成一个全局唯一的id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这儿就是获取当前时间戳，单位是毫秒</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">"clock is moving backwards. Rejecting requests until %d."</span>, lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                String.format(<span class="string">"Clock moved backwards. Refusing to generate id for %d milliseconds"</span>,</span><br><span class="line">                              lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是说假设在同一个毫秒内，又发送了一个请求生成一个id</span></span><br><span class="line">        <span class="comment">// 这个时候就得把seqence序号给递增1，最多就是4096</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个意思是说一个毫秒内最多只能有4096个数字，无论你传递多少进来，</span></span><br><span class="line">            <span class="comment">//这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这儿记录一下最近一次生成id的时间戳，单位是毫秒</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这儿就是最核心的二进制位运算操作，生成一个64bit的id</span></span><br><span class="line">        <span class="comment">// 先将当前时间戳左移，放到41 bit那儿；将机房id左移放到5 bit那儿；将机器id左移放到5 bit那儿；将序号放最后12 bit</span></span><br><span class="line">        <span class="comment">// 最后拼接起来成一个64 bit的二进制数字，转换成10进制就是个long型</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId</span><br><span class="line">            &lt;&lt; workerIdShift) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了雪花算法的实现，在 nextId 中是我们生成雪花算法的关键。</p><h3 id="防止时钟回拨"><a class="markdownIt-Anchor" href="#防止时钟回拨"></a> 防止时钟回拨</h3><p>因为机器的原因会发生时间回拨，我们的雪花算法是强依赖我们的时间的，如果时间发生回拨，有可能会生成重复的 ID，在我们上面的 nextId 中我们用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨，普通的算法会直接抛出异常,这里我们可以对其进行优化,一般分为两个情况:</p><ul><li>如果时间回拨时间较短，比如配置 5ms 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li><li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:</li></ul><ol><li>直接拒绝，抛出异常，打日志，通知 RD 时钟回滚。</li><li>利用扩展位，上面我们讨论过不同业务场景位数可能用不到那么多，那么我们可以把扩展位数利用起来了，比如当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。2 位的扩展位允许我们有 3 次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li></ol><p>通过上面的几种策略可以比较的防护我们的时钟回拨，防止出现回拨之后大量的异常出现。下面是修改之后的代码，这里修改了时钟回拨的逻辑:</p><div align="center"><img src="https://user-gold-cdn.xitu.io/2018/9/29/166252f2a1edac10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/></div><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">百度分布式 ID</a></li><li><a href="https://juejin.im/post/5bb0217ef265da0ac2567b42" target="_blank" rel="noopener">如果再有人问你分布式 ID，这篇文章丢给他</a></li><li><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">理解分布式 id 生成算法 SnowFlake</a></li><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式 ID 生成系统</a></li><li><a href="https://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">UUID 规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式-id&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式-id&quot;&gt;&lt;/a&gt; 分布式 ID&lt;/h1&gt;
&lt;h2 id=&quot;uuid&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#uuid&quot;&gt;&lt;/a&gt; UU
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/categories/design/distributed/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存</title>
    <link href="https://dunwu.github.io/blog/design/distributed/distributed-cache/"/>
    <id>https://dunwu.github.io/blog/design/distributed/distributed-cache/</id>
    <published>2019-06-27T07:36:00.000Z</published>
    <updated>2019-08-21T03:34:57.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式缓存"><a class="markdownIt-Anchor" href="#分布式缓存"></a> 分布式缓存</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>使用缓存的好处：</p><ul><li>提升数据读取速度</li><li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li><li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li></ul><p>根据业务场景，通常缓存有以下几种使用方式</p><ul><li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li><li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li><li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li></ul><p>缓存分类：</p><ul><li>应用内缓存：如：EHCache</li><li>分布式缓存：如：Memached、Redis</li></ul><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3><p>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p><p>解决方案：</p><ul><li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。</li><li>还有一个简单的方案，就是将缓存失效时间分散开，不要所有缓存时间长度都设置成 5 分钟或者 10 分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li></ul><p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p><h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3><p>缓存穿透是指：用户查询的数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p><p>解决方案：</p><ol><li>在封装的缓存 SET 和 GET 部分增加个步骤，如果查询一个 KEY 不存在，就以这个 KEY 为前缀设定一个标识 KEY；以后再查询该 KEY 的时候，先查询标识 KEY，如果标识 KEY 存在，就返回一个协定好的非 false 或者 NULL 值，然后 APP 做相应的处理，这样缓存层就不会被穿透。当然这个验证 KEY 的失效时间不能太长。</li><li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</li><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li></ol><h3 id="缓存预热"><a class="markdownIt-Anchor" href="#缓存预热"></a> 缓存预热</h3><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p>解决方案：</p><ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol><h3 id="缓存更新"><a class="markdownIt-Anchor" href="#缓存更新"></a> 缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><ol><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ol><p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h3 id="缓存降级"><a class="markdownIt-Anchor" href="#缓存降级"></a> 缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://juejin.im/entry/57e39e320e3dd90058021bff" target="_blank" rel="noopener">分布式缓存架构基础</a></li><li><a href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&amp;utm_campaign=client_share&amp;from=singlemessage&amp;timestamp=1521281305&amp;app=news_article&amp;utm_source=weixin&amp;iid=28128279343&amp;utm_medium=toutiao_android&amp;weixin_list=1&amp;wxshare_count=2&amp;pbid=6517746516513195523" target="_blank" rel="noopener">阿里 P8 技术专家细究分布式缓存问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式缓存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式缓存&quot;&gt;&lt;/a&gt; 分布式缓存&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/categories/design/distributed/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/tags/distributed/"/>
    
      <category term="cache" scheme="https://dunwu.github.io/blog/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://dunwu.github.io/blog/design/distributed/distributed-transaction/"/>
    <id>https://dunwu.github.io/blog/design/distributed/distributed-transaction/</id>
    <published>2019-06-21T03:30:00.000Z</published>
    <updated>2019-08-21T05:20:29.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h1><blockquote><p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p></blockquote><p>分布式事务的实现主要有以下 5 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h2 id="两阶段提交"><a class="markdownIt-Anchor" href="#两阶段提交"></a> 两阶段提交</h2><blockquote><p>两阶段提交（Two-phase Commit，2PC）通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><p>参考实现：<a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">https://github.com/changmingxie/tcc-transaction</a></p></blockquote><h3 id="运行过程"><a class="markdownIt-Anchor" href="#运行过程"></a> 运行过程</h3><h4 id="准备阶段"><a class="markdownIt-Anchor" href="#准备阶段"></a> 准备阶段</h4><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式事务两阶段提交-01.jpg!zp" /></div><h4 id="提交阶段"><a class="markdownIt-Anchor" href="#提交阶段"></a> 提交阶段</h4><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式事务两阶段提交-02.jpg!zp" /></div>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ul><li><strong>同步阻塞</strong> - 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</li><li><strong>单点问题</strong> - 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</li><li><strong>数据不一致</strong> - 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li><li><strong>太过保守</strong> - 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li></ul><h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3><ul><li>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致</li><li>缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</li></ul><h2 id="补偿事务"><a class="markdownIt-Anchor" href="#补偿事务"></a> 补偿事务</h2><blockquote><p>补偿事务（TCC），全称是：<code>Try</code>、<code>Confirm</code>、<code>Cancel</code>。</p><p>其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><p>TCC 的。</p><ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li><li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul></blockquote><p>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p><ol><li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li><li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li><li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li></ol><p>优缺点：</p><ul><li>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</li><li>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li></ul><p>这种方案几乎很少人使用，因为<strong>事务回滚</strong>实际上是<strong>严重依赖于自己写代码来回滚和补偿</strong>了，会造成补偿代码巨大。</p><p>但是，也有特殊的使用场景：一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付</strong>、<strong>交易</strong>相关的场景，会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p><h2 id="本地消息表异步确保"><a class="markdownIt-Anchor" href="#本地消息表异步确保"></a> 本地消息表（异步确保）</h2><blockquote><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式事务本地消息.jpg!zp" /></div><p>这种方案遵循 BASE 理论，采用的是最终一致性。</p><p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p><h3 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h3><ul><li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li><li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li></ul><h2 id="mq-事务消息"><a class="markdownIt-Anchor" href="#mq-事务消息"></a> MQ 事务消息</h2><p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><ol><li>Prepared 消息，会拿到消息的地址。</li><li>执行本地事务。</li><li>通过第一阶段拿到的地址去访问消息，并修改状态。</li></ol><p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><h3 id="优缺点-3"><a class="markdownIt-Anchor" href="#优缺点-3"></a> 优缺点</h3><ul><li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li><li>缺点：实现难度大，主流 MQ 不支持。</li></ul><h3 id="两阶段提交方案xa-方案"><a class="markdownIt-Anchor" href="#两阶段提交方案xa-方案"></a> 两阶段提交方案/XA 方案</h3><p>所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 <code>Spring + JTA</code> 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-XA.png"/></div><h3 id="本地消息表"><a class="markdownIt-Anchor" href="#本地消息表"></a> 本地消息表</h3><p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ol><p>这个方案说实话最大的问题就在于<strong>严重依赖于数据库的消息表来管理事务</strong>啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-local-message-table.png"/></div><h3 id="可靠消息最终一致性方案"><a class="markdownIt-Anchor" href="#可靠消息最终一致性方案"></a> 可靠消息最终一致性方案</h3><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li></ol><div align="center"><img src="https://github.com/doocs/advanced-java/blob/master/images/distributed-transaction-reliable-message.png"/></div><h3 id="最大努力通知方案"><a class="markdownIt-Anchor" href="#最大努力通知方案"></a> 最大努力通知方案</h3><p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><h3 id="你们公司是如何处理分布式事务的"><a class="markdownIt-Anchor" href="#你们公司是如何处理分布式事务的"></a> 你们公司是如何处理分布式事务的？</h3><p>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p><p>当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式事务&quot;&gt;&lt;/a&gt; 分布式事务&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。&lt;/str
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/categories/design/distributed/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/tags/distributed/"/>
    
      <category term="transaction" scheme="https://dunwu.github.io/blog/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式会话</title>
    <link href="https://dunwu.github.io/blog/design/distributed/distributed-session/"/>
    <id>https://dunwu.github.io/blog/design/distributed/distributed-session/</id>
    <published>2019-06-04T15:42:00.000Z</published>
    <updated>2019-08-21T05:20:31.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式会话"><a class="markdownIt-Anchor" href="#分布式会话"></a> 分布式会话</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><h3 id="什么是-session"><a class="markdownIt-Anchor" href="#什么是-session"></a> 什么是 Session？</h3><p>session 是啥？浏览器有个 cookie，在一段时间内这个 cookie 都存在，然后每次发请求过来都带上一个特殊的 <code>jsessionid cookie</code>，就根据这个东西，在服务端可以维护一个对应的 session 域，里面可以放点数据。</p><p>一般的话只要你没关掉浏览器，cookie 还在，那么对应的那个 session 就在，但是如果 cookie 没了，session 也就没了。常见于什么购物车之类的东西，还有登录状态保存之类的。</p><h3 id="什么是分布式-session"><a class="markdownIt-Anchor" href="#什么是分布式-session"></a> 什么是分布式 Session？</h3><p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p><p>分布式 Session 的几种实现策略：</p><ol><li>粘性 session</li><li>应用服务器间的 session 复制共享</li><li>基于缓存的 session 共享 ✅</li></ol><blockquote><p>推荐：基于缓存的 session 共享</p></blockquote><h2 id="粘性-session"><a class="markdownIt-Anchor" href="#粘性-session"></a> 粘性 Session</h2><blockquote><p>粘性 Session（Sticky Sessions）需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p><p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/MultiNode-StickySessions.jpg!zp" /></div><h2 id="session-复制共享"><a class="markdownIt-Anchor" href="#session-复制共享"></a> session 复制共享</h2><blockquote><p>Session 复制共享（Session Replication）在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p><p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/MultiNode-SessionReplication.jpg!zp" /></div><h2 id="基于缓存的-session-共享"><a class="markdownIt-Anchor" href="#基于缓存的-session-共享"></a> 基于缓存的 session 共享</h2><blockquote><p>使用一个单独的存储服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p><p>缺点：需要去实现存取 Session 的代码。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/MultiNode-SpringSession.jpg!zp" /></div><h2 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h2><h3 id="jwt-token"><a class="markdownIt-Anchor" href="#jwt-token"></a> JWT Token</h3><p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p><h3 id="tomcat-redis"><a class="markdownIt-Anchor" href="#tomcat-redis"></a> tomcat + redis</h3><p>这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 <code>Tomcat RedisSessionManager</code> 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。</p><p>在 tomcat 的配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">"&#123;redis.host&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">"&#123;redis.port&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">database</span>=<span class="string">"&#123;redis.dbnum&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后指定 redis 的 host 和 port 就 ok 了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">sentinelMaster</span>=<span class="string">"mymaster"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">sentinels</span>=<span class="string">"&lt;sentinel1-ip&gt;:26379,&lt;sentinel2-ip&gt;:26379,&lt;sentinel3-ip&gt;:26379"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。</p><h3 id="spring-session-redis"><a class="markdownIt-Anchor" href="#spring-session-redis"></a> spring session + redis</h3><p>上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于 web 容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p><p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 sping session 是一个很好的选择。</p><p>在 pom.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 spring 配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisHttpSessionConfiguration"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInactiveIntervalInSeconds"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_hostname&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_port&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_pwd&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePool"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 web.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/putIntoSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putIntoSession</span><span class="params">(HttpServletRequest request, String username)</span> </span>&#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"name"</span>,  <span class="string">"leo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getFromSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromSession</span><span class="params">(HttpServletRequest request, Model model)</span></span>&#123;</span><br><span class="line">        String name = request.getSession().getAttribute(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是 ok 的，给 sping session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。</p><p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">集群/分布式环境 Session 的几种策略</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式会话&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式会话&quot;&gt;&lt;/a&gt; 分布式会话&lt;/h1&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/categories/design/distributed/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/tags/distributed/"/>
    
      <category term="session" scheme="https://dunwu.github.io/blog/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://dunwu.github.io/blog/design/distributed/distributed-lock/"/>
    <id>https://dunwu.github.io/blog/design/distributed/distributed-lock/</id>
    <published>2019-06-04T15:42:00.000Z</published>
    <updated>2019-08-21T04:00:17.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h1><p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p><p>分布式锁的解决方案大致有以下几种：</p><ul><li>基于数据库实现</li><li>基于缓存（redis，memcached 等）实现</li><li>基于 Zookeeper 实现 ✅</li></ul><blockquote><p>注：推荐基于 ZooKeeper 实现分布式锁，具体原因看完本文即可明了。</p></blockquote><h2 id="分布式锁思路"><a class="markdownIt-Anchor" href="#分布式锁思路"></a> 分布式锁思路</h2><p>分布式锁的总体思路大同小异，仅在实现细节上有所不同。</p><p>分布式锁的主要思路如下：</p><ol><li><strong>互斥</strong> - 创建锁必须是唯一的，表现形式为向数据存储服务器或容器插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。</li><li>避免永远不释放锁 - 数据库分布式锁和缓存分布式锁（Redis）的思路都是引入超时机制，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 ZooKeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。</li><li>容错（只要大部分 redis 节点创建了这把锁就可以）</li></ol><h2 id="数据库分布式锁"><a class="markdownIt-Anchor" href="#数据库分布式锁"></a> 数据库分布式锁</h2><h3 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><p>（2）获取锁</p><p>想要锁住某个方法时，执行以下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>成功插入则获取锁。</p><p>（3）释放锁</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ul><li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ul><h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h3><ul><li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li><li>写一个定时任务，隔一段时间清除一次过期的数据。</li><li>写一个 while 循环，不断的重试插入，直到成功。</li><li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><ul><li>优点: 直接借助数据库，容易理解。</li><li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li></ul><h2 id="redis-分布式锁"><a class="markdownIt-Anchor" href="#redis-分布式锁"></a> Redis 分布式锁</h2><p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p><h3 id="实现思路"><a class="markdownIt-Anchor" href="#实现思路"></a> 实现思路</h3><p>这个分布式锁有 3 个重要的考量点：</p><ol><li>互斥（只能有一个客户端获取锁）</li><li>不能死锁</li><li>容错（只要大部分 redis 节点创建了这把锁就可以）</li></ol><p>对应的 Redis 指令如下：</p><ul><li><code>setnx</code> - <code>setnx key val</code>：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li><li><code>expire</code> - <code>expire key timeout</code>：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li><li><code>delete</code> - <code>delete key</code>：删除 key</li></ul><h3 id="具体实现-2"><a class="markdownIt-Anchor" href="#具体实现-2"></a> 具体实现</h3><p>（1）申请锁</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> resource_name <span class="comment">my_random_value NX PX 30000</span></span><br></pre></td></tr></table></figure><p>执行这个命令就 ok。</p><ul><li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li><li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li></ul><p>（2）释放锁</p><p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h3><p>为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p><p>但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p><h3 id="redlock-算法"><a class="markdownIt-Anchor" href="#redlock-算法"></a> RedLock 算法</h3><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li></ol><p><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a> 。</p><h2 id="zookeeper-分布式锁"><a class="markdownIt-Anchor" href="#zookeeper-分布式锁"></a> ZooKeeper 分布式锁</h2><h3 id="实现思路-2"><a class="markdownIt-Anchor" href="#实现思路-2"></a> 实现思路</h3><p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p><ol><li>创建一个目录 mylock；</li><li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li><li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol><h3 id="具体实现-3"><a class="markdownIt-Anchor" href="#具体实现-3"></a> 具体实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZooKeeperSession</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>, <span class="number">50000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connectedSemaphore.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ZooKeeper session established......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">acquireDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span></span><br><span class="line">                    Stat stat = zk.exists(path, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放掉一个分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseDistributedLock</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.delete(path, -<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"release the lock for product[id="</span> + productId + <span class="string">"]......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立zk session的watcher</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Receive watched event: "</span> + event.getState());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装单例的静态内部类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> bingo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2018/11/29</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperSession instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ZooKeeperSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化单例的便捷方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以采用另一种方式，创建临时顺序节点：</p><p>如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperDistributedLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String locksRoot = <span class="string">"/locks"</span>;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String waitNode;</span><br><span class="line">    <span class="keyword">private</span> String lockNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperDistributedLock</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String address = <span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(address, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            connectedLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">            connectedLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 传入进去的locksRoot + “/” + productId</span></span><br><span class="line">    <span class="comment">// 假设productId代表了一个商品id，比如说1</span></span><br><span class="line">    <span class="comment">// locksRoot = locks</span></span><br><span class="line">    <span class="comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span></span><br><span class="line">            lockNode = zk.create(locksRoot + <span class="string">"/"</span> + productId, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看看刚创建的节点是不是最小的节点</span></span><br><span class="line">     <span class="comment">// locks：10000000000，10000000001，10000000002</span></span><br><span class="line">            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="keyword">false</span>);</span><br><span class="line">            Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lockNode.equals(locksRoot+<span class="string">"/"</span>+ locks.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                <span class="comment">//如果是最小的节点,则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不是最小的节点，找到比自己小1的节点</span></span><br><span class="line">  <span class="keyword">int</span> previousLockIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(lockNode.equals(locksRoot + “/” + locks.get(i))) &#123;</span><br><span class="line">             previousLockIndex = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.waitNode = locks.get(previousLockIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(String waitNode, <span class="keyword">long</span> waitTime)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        Stat stat = zk.exists(locksRoot + <span class="string">"/"</span> + waitNode, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除/locks/10000000000节点</span></span><br><span class="line">            <span class="comment">// 删除/locks/10000000001节点</span></span><br><span class="line">            System.out.println(<span class="string">"unlock "</span> + lockNode);</span><br><span class="line">            zk.delete(lockNode, -<span class="number">1</span>);</span><br><span class="line">            lockNode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h3><p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p><ul><li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li><li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li></ul><p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p><h2 id="分布式锁方案对比"><a class="markdownIt-Anchor" href="#分布式锁方案对比"></a> 分布式锁方案对比</h2><ul><li><p>数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐</p></li><li><p>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</p></li><li><p>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</p></li></ul><p>另外一点就是，如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p><p>总体上来说，ZooKeeper 实现分布式锁更加的简单，可靠性更高。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">分布式锁实现汇总</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式锁&quot;&gt;&lt;/a&gt; 分布式锁&lt;/h1&gt;
&lt;p&gt;Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。&lt;/p&gt;
&lt;p&gt;分布式锁的
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/categories/design/distributed/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/blog/tags/distributed/"/>
    
      <category term="lock" scheme="https://dunwu.github.io/blog/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>网络通信知识点面经</title>
    <link href="https://dunwu.github.io/blog/communication/network-interview/"/>
    <id>https://dunwu.github.io/blog/communication/network-interview/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-11-21T12:10:33.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信知识点面经"><a class="markdownIt-Anchor" href="#网络通信知识点面经"></a> 网络通信知识点面经</h1><!-- TOC depthFrom:2 depthTo:4 --><ul><li><a href="#1-%E7%BB%BC%E5%90%88">1. 综合</a><ul><li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82">1.1. 计算机网络如何分层？</a></li></ul></li><li><a href="#2-http">2. HTTP</a></li><li><a href="#3-dns">3. DNS</a></li><li><a href="#4-tcpudp">4. TCP/UDP</a><ul><li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF-tcp">4.1. 什么是 TCP？</a></li><li><a href="#42-tcp-%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88">4.2. TCP 的特性是什么？</a></li><li><a href="#43-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">4.3. TCP 三次握手</a></li><li><a href="#44-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.4. TCP 四次挥手</a></li><li><a href="#45-tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.5. TCP 滑动窗口</a></li><li><a href="#46-tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.6. TCP 重传机制</a></li></ul></li></ul><!-- /TOC --><h2 id="1-综合"><a class="markdownIt-Anchor" href="#1-综合"></a> 1. 综合</h2><h3 id="11-计算机网络如何分层"><a class="markdownIt-Anchor" href="#11-计算机网络如何分层"></a> 1.1. 计算机网络如何分层？</h3><blockquote><p>❓ 问题：计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p><p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/network-layers.png!zp"/></div><p>计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。</p><ul><li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li><li>五层协议分层是一种折中方案，在现实中更为流行。</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/overview/网络分层架构图.png!zp"/></div><p><strong>物理层</strong></p><blockquote><p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p><p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p></blockquote><ul><li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li><li>数据单元：比特流。</li><li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li></ul><p><strong>数据链路层</strong></p><blockquote><p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p><p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p></blockquote><ul><li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul><p><strong>网络层</strong></p><blockquote><p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p><p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p></blockquote><ul><li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li><li>主要协议：<code>IP</code>。</li><li>数据单元：IP 数据报（packet）。</li><li>典型设备：网关、路由器。</li></ul><p><strong>传输层</strong></p><blockquote><p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p><p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p></blockquote><ul><li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li><li>主要协议：<code>TCP</code>、<code>UDP</code>。</li><li>数据单元：报文段（segment）或用户数据报。</li></ul><p><sub>~**会话层**~</sub></p><blockquote><p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p></blockquote><p><sub>~**表示层**~</sub></p><blockquote><p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p></blockquote><p><strong>应用层</strong></p><blockquote><p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p><p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p></blockquote><ul><li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li><li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li><li>数据单元：报文（message）。</li></ul><h2 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h2><blockquote><p>扩展阅读：<a href="http.md">超文本传输协议 HTTP</a></p></blockquote><h2 id="3-dns"><a class="markdownIt-Anchor" href="#3-dns"></a> 3. DNS</h2><blockquote><p>扩展阅读：<a href="dns.md">域名系统 DNS</a></p></blockquote><h2 id="4-tcpudp"><a class="markdownIt-Anchor" href="#4-tcpudp"></a> 4. TCP/UDP</h2><blockquote><p>扩展阅读：<a href="tcp.md">传输控制协议 TCP</a>，<a href="udp.md">用户数据报协议 UDP</a></p></blockquote><h3 id="41-什么是-tcp"><a class="markdownIt-Anchor" href="#41-什么是-tcp"></a> 4.1. 什么是 TCP？</h3><p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。</p><h3 id="42-tcp-的特性是什么"><a class="markdownIt-Anchor" href="#42-tcp-的特性是什么"></a> 4.2. TCP 的特性是什么？</h3><ul><li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li><li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：<ul><li>数据包的序列号和校验码</li><li>确认包和自动重传<ul><li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li><li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li></ul></li></ul></li><li><code>基于字节流的</code><ul><li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li><li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li></ul></li></ul><h3 id="43-tcp-三次握手"><a class="markdownIt-Anchor" href="#43-tcp-三次握手"></a> 4.3. TCP 三次握手</h3><blockquote><p>❓ 问题：三次握手有什么用？什么是三次握手？为什么需要三次握手？</p></blockquote><p>（1）三次握手有什么用？</p><ul><li>三次握手负责建立 TCP 双向连接。</li></ul><p>（2）什么是三次握手？</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/三次握手.gif!zp"/></div><p>如上图所示，三次握手流程如下：</p><ol><li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li><li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li><li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li></ol><p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p><blockquote><p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p></blockquote><p>（3）为什么需要三次握手？</p><p>为了便于说明，假设客户端为 A, 服务端为 B。</p><ol><li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li><li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li><li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li></ol><h3 id="44-tcp-四次挥手"><a class="markdownIt-Anchor" href="#44-tcp-四次挥手"></a> 4.4. TCP 四次挥手</h3><blockquote><p>❓ 问题：四次挥手有什么用？什么是四次挥手？为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p></blockquote><p>（1）四次挥手有什么用？</p><ul><li>四次挥手负责断开 TCP 连接。</li></ul><p>（2）什么是四次挥手？</p><p>如上图所示，四次挥手流程如下：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/四次挥手.gif!zp"/></div><ol><li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li><li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li><li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li><li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li></ol><p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p><ul><li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li><li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li></ul><h3 id="45-tcp-滑动窗口"><a class="markdownIt-Anchor" href="#45-tcp-滑动窗口"></a> 4.5. TCP 滑动窗口</h3><blockquote><p>❓ 问题：什么是滑动窗口？滑动窗口原理是什么？</p></blockquote><p>什么是滑动窗口？</p><p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p><p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p><p>滑动窗口原理是什么？</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265819762.png!zp"/></div><ol><li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li><li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li><li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li><li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li></ol><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265927658.png!zp"/></div><p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p><h3 id="46-tcp-重传机制"><a class="markdownIt-Anchor" href="#46-tcp-重传机制"></a> 4.6. TCP 重传机制</h3><blockquote><p>❓ 问题：为什么需要重传机制？TCP 有哪些重传机制，原理是什么？</p></blockquote><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>TCP 重传机制主要有两种：</p><ul><li>超时重传机制</li><li>快速重传机制</li></ul><p>（1）超时重传机制</p><p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p><p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p><p>这种机制的重点是 RTO 的设置：</p><ul><li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li></ul><p>（2）快速重传机制</p><p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p><p>当接收方收到乱序片段时，需要重复发送 ACK。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络通信知识点面经&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络通信知识点面经&quot;&gt;&lt;/a&gt; 网络通信知识点面经&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:4 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="application" scheme="https://dunwu.github.io/blog/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 UDP</title>
    <link href="https://dunwu.github.io/blog/communication/udp/"/>
    <id>https://dunwu.github.io/blog/communication/udp/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2019-11-21T12:10:52.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559263939493.png!zp"/></div><p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p><p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p><p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p><p>以下情况使用 UDP 代替 TCP：</p><ul><li>你需要低延迟</li><li>相对于数据丢失更糟的是数据延迟</li><li>你想实现自己的错误校正方法</li></ul><h3 id="udp-特点"><a class="markdownIt-Anchor" href="#udp-特点"></a> UDP 特点</h3><ol><li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li><li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li><li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li><li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li><li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li><li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li></ol><h3 id="udp-应用场景"><a class="markdownIt-Anchor" href="#udp-应用场景"></a> UDP 应用场景</h3><ol><li>名字转换（DNS）</li><li>文件传送（TFTP）</li><li>路由选择协议（RIP）</li><li>IP 地址配置（BOOTP，DHTP）</li><li>网络管理（SNMP）</li><li>远程文件服务（NFS）</li><li>IP 电话</li><li>流式多媒体通信</li></ol><h2 id="udp-报文"><a class="markdownIt-Anchor" href="#udp-报文"></a> UDP 报文</h2><p>UDP 数据报分为数据字段和首部字段。<br />首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p><p><strong>首部各字段意义</strong>：</p><ol><li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li><li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li><li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li><li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://dunwu.test.upcdn.net/snap/155926393949
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 Websocket</title>
    <link href="https://dunwu.github.io/blog/communication/websocket/"/>
    <id>https://dunwu.github.io/blog/communication/websocket/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2019-11-21T12:10:52.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><h3 id="websocket-是什么"><a class="markdownIt-Anchor" href="#websocket-是什么"></a> WebSocket 是什么</h3><p><a href="http://websocket.org/" target="_blank" rel="noopener">WebSocket</a> 是一种网络通信协议。<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 定义了它的通信标准。</p><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><h3 id="为什么需要-websocket"><a class="markdownIt-Anchor" href="#为什么需要-websocket"></a> 为什么需要 WebSocket</h3><p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p><p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/ajax-long-polling.png!zp"/></div><p>因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/java/spring/web/websockets-flow.png!zp"/></div><h3 id="websocket-如何工作"><a class="markdownIt-Anchor" href="#websocket-如何工作"></a> WebSocket 如何工作？</h3><p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p><p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p><h2 id="websocket-客户端"><a class="markdownIt-Anchor" href="#websocket-客户端"></a> WebSocket 客户端</h2><p>在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。</p><h3 id="客户端-api"><a class="markdownIt-Anchor" href="#客户端-api"></a> 客户端 API</h3><p>以下 API 用于创建 WebSocket 对象。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var Socket = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h4 id="websocket-属性"><a class="markdownIt-Anchor" href="#websocket-属性"></a> WebSocket 属性</h4><p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Socket.readyState</td><td>只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td>Socket.bufferedAmount</td><td>只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h4 id="websocket-事件"><a class="markdownIt-Anchor" href="#websocket-事件"></a> WebSocket 事件</h4><p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>事件</th><th>事件处理程序</th><th>描述</th></tr></thead><tbody><tr><td>open</td><td>Socket.onopen</td><td>连接建立时触发</td></tr><tr><td>message</td><td>Socket.onmessage</td><td>客户端接收服务端数据时触发</td></tr><tr><td>error</td><td>Socket.onerror</td><td>通信发生错误时触发</td></tr><tr><td>close</td><td>Socket.onclose</td><td>连接关闭时触发</td></tr></tbody></table><h4 id="websocket-方法"><a class="markdownIt-Anchor" href="#websocket-方法"></a> WebSocket 方法</h4><p>以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Socket.send()</td><td>使用连接发送数据</td></tr><tr><td>Socket.close()</td><td>关闭连接</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 WebSocket 对象</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9998/echo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 web socket 连接成功触发事件</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 使用 send() 方法发送数据</span></span><br><span class="line">ws.send(<span class="string">'发送数据'</span>)</span><br><span class="line">alert(<span class="string">'数据发送中...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端数据时触发事件</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> received_msg = evt.data</span><br><span class="line">alert(<span class="string">'数据已接收...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 web socket 连接成功触发事件</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'连接已关闭...'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="websocket-服务端"><a class="markdownIt-Anchor" href="#websocket-服务端"></a> WebSocket 服务端</h2><p>WebSocket 在服务端的实现非常丰富。Node.js、Java、C++、Python 等多种语言都有自己的解决方案。</p><p>以下，介绍我在学习 WebSocket 过程中接触过的 WebSocket 服务端解决方案。</p><h3 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h3><p>常用的 Node 实现有以下三种。</p><ul><li><a href="https://github.com/uWebSockets/uWebSockets" target="_blank" rel="noopener">µWebSockets</a></li><li><a href="http://socket.io/" target="_blank" rel="noopener">Socket.IO</a></li><li><a href="https://github.com/theturtle32/WebSocket-Node" target="_blank" rel="noopener">WebSocket-Node</a></li></ul><h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h3><p>Java 的 web 一般都依托于 servlet 容器。</p><p>我使用过的 servlet 容器有：Tomcat、Jetty、Resin。其中 Tomcat7、Jetty7 及以上版本均开始支持 WebSocket（推荐较新的版本，因为随着版本的更迭，对 WebSocket 的支持可能有变更）。</p><p>此外，Spring 框架对 WebSocket 也提供了支持。</p><p>虽然，以上应用对于 WebSocket 都有各自的实现。但是，它们都遵循<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 的通信标准，并且 Java API 统一遵循 <a href="http://www.jcp.org/en/jsr/detail?id=356" target="_blank" rel="noopener">JSR 356 - JavaTM API for WebSocket </a> 规范。所以，在实际编码中，API 差异不大。</p><h4 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h4><p>Spring 对于 WebSocket 的支持基于下面的 jar 包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Spring 实现 WebSocket 服务器大概分为以下几步：</p><p><strong>创建 WebSocket 处理器</strong></p><p>扩展 <code>TextWebSocketHandler</code> 或 <code>BinaryWebSocketHandler</code> ，你可以覆写指定的方法。Spring 在收到 WebSocket 事件时，会自动调用事件对应的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WebSocketHandler</code> 源码如下，这意味着你的处理器大概可以处理哪些 WebSocket 事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 收到消息时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传输消息出错时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 断开连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否处理分片消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置 WebSocket</strong></p><p>配置有两种方式：注解和 xml 。其作用就是将 WebSocket 处理器添加到注册中心。</p><ol><li>实现 <code>WebSocketConfigurer</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">"/myHandler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>xml 方式</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket/spring-websocket.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">"/myHandler"</span> <span class="attr">handler</span>=<span class="string">"myHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myHandler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.MyHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>更多配置细节可以参考：<a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></p></blockquote><h4 id="javaxwebsocket"><a class="markdownIt-Anchor" href="#javaxwebsocket"></a> javax.websocket</h4><p>如果不想使用 Spring 框架的 WebSocket API，你也可以选择基本的 javax.websocket。</p><p>首先，需要引入 API jar 包。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To write basic javax.websocket against --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用嵌入式 jetty，你还需要引入它的实现包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To run javax.websocket in embedded server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-server-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- To run javax.websocket client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-client-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@ServerEndpoint</strong></p><p>这个注解用来标记一个类是 WebSocket 的处理器。</p><p>然后，你可以在这个类中使用下面的注解来表明所修饰的方法是触发事件的回调</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到消息触发事件</span></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接触发事件</span></span><br><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, EndpointConfig config, @PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接触发事件</span></span><br><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输消息错误触发事件</span></span><br><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServerEndpointConfig.Configurator</strong></p><p>编写完处理器，你需要扩展 ServerEndpointConfig.Configurator 类完成配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerConfigurator</span> <span class="keyword">extends</span> <span class="title">ServerEndpointConfig</span>.<span class="title">Configurator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> </span>&#123;</span><br><span class="line">        HttpSession httpSession = (HttpSession) request.getHttpSession();</span><br><span class="line">        sec.getUserProperties().put(HttpSession<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">httpSession</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就没有然后了，就是这么简单。</p><h2 id="websocket-代理"><a class="markdownIt-Anchor" href="#websocket-代理"></a> WebSocket 代理</h2><p>如果把 WebSocket 的通信看成是电话连接，Nginx 的角色则像是电话接线员，负责将发起电话连接的电话转接到指定的客服。</p><p>Nginx 从 <a href="http://nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">1.3 版</a>开始正式支持 WebSocket 代理。如果你的 web 应用使用了代理服务器 Nginx，那么你还需要为 Nginx 做一些配置，使得它开启 WebSocket 代理功能。</p><p>以下为参考配置：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment"># this section is specific to the WebSockets proxying</span></span><br><span class="line">  <span class="attribute">location</span> /socket.io &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app_server_wsgiapp/socket.io;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多配置细节可以参考：<a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></p></blockquote><h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2><h3 id="http-和-websocket-有什么关系"><a class="markdownIt-Anchor" href="#http-和-websocket-有什么关系"></a> HTTP 和 WebSocket 有什么关系？</h3><p>Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。</p><h3 id="html-和-http-有什么关系"><a class="markdownIt-Anchor" href="#html-和-http-有什么关系"></a> Html 和 HTTP 有什么关系？</h3><p>Html 是超文本标记语言，是一种用于创建网页的标准标记语言。它是一种技术标准。Html5 是它的最新版本。</p><p>Http 是一种网络通信协议。其本身和 Html 没有直接关系。</p><h2 id="完整示例"><a class="markdownIt-Anchor" href="#完整示例"></a> 完整示例</h2><p>如果需要完整示例代码，可以参考我的 Github 代码：</p><ul><li><a href="https://github.com/dunwu/spring-notes/tree/master/codes/web/websocket" target="_blank" rel="noopener">Spring 对 WebSocket 支持的示例</a></li><li><a href="https://github.com/dunwu/javaee-notes/tree/master/codes/websocket" target="_blank" rel="noopener">嵌入式 Jetty 服务器的 WebSocket 示例</a></li></ul><p>spring-websocket 和 jetty 9.3 版本似乎存在兼容性问题，Tomcat 则木有问题。</p><p>我尝试了好几次，没有找到解决方案，只好使用 Jetty 官方的嵌入式示例在 Jetty 中使用 WebSocket 。</p><h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h2><ul><li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">知乎高票答案——WebSocket 是什么原理</a> - 对 WebSocket 原理的阐述简单易懂。</li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a> - 阮一峰大神的科普一如既往的浅显易懂。</li><li><a href="https://www.fullstackpython.com/websockets.html" target="_blank" rel="noopener">WebSockets</a> - by <em>fullstackpython</em></li><li><a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></li><li><a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></li><li><a href="http://tomcat.apache.org/tomcat-7.0-doc/web-socket-howto.html" target="_blank" rel="noopener">Tomcat7 WebSocket 文档</a></li><li><a href="https://www.eclipse.org/jetty/documentation/9.4.7.v20170914/websocket-intro.html" target="_blank" rel="noopener">Jetty WebSocket 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;h3 id=&quot;websocket-是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#websocket-是什么&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 TCP</title>
    <link href="https://dunwu.github.io/blog/communication/tcp/"/>
    <id>https://dunwu.github.io/blog/communication/tcp/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2019-11-21T12:10:52.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3><p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。TCP 由 RFC 793 定义。</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559263786555.png!zp"/></div><h3 id="tcp-的特性"><a class="markdownIt-Anchor" href="#tcp-的特性"></a> TCP 的特性</h3><ul><li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li><li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：<ul><li>数据包的序列号和校验码</li><li>确认包和自动重传<ul><li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li><li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li></ul></li></ul></li><li><code>基于字节流的</code><ul><li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li><li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li></ul></li></ul><h3 id="tcp-的适用场景"><a class="markdownIt-Anchor" href="#tcp-的适用场景"></a> TCP 的适用场景</h3><p>基于以上特性，为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。但要注意的是，在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，这时可以考虑在适用情况下切换到 UDP。</p><p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p><p>以下情况使用 TCP 代替 UDP：</p><ul><li>你需要数据完好无损。</li><li>你想对网络吞吐量自动进行最佳评估。</li></ul><h3 id="tcp-报文"><a class="markdownIt-Anchor" href="#tcp-报文"></a> TCP 报文</h3><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264511812.png!zp"/></div><p>报文字段不一一阐述，重点关注以下几点：</p><ul><li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li><li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li><li>注意上图中的四个非常重要的东西：<ul><li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li><li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li><li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li><li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li></ul></li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264593860.png!zp"/></div><h2 id="tcp-通信流程"><a class="markdownIt-Anchor" href="#tcp-通信流程"></a> TCP 通信流程</h2><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559264679371.png!zp"/></div><p>TCP 完整的通信分为三块：</p><ol><li>三次握手建立连接</li><li>数据传输</li><li>四次挥手端口连接</li></ol><h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3><p>（1）三次握手有什么用？</p><ul><li>三次握手负责建立 TCP 双向连接。</li></ul><p>（2）什么是三次握手？</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/三次握手.gif!zp"/></div><p>如上图所示，三次握手流程如下：</p><ol><li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li><li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li><li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li></ol><p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p><blockquote><p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p></blockquote><p>（3）为什么需要三次握手？</p><p>为了便于说明，假设客户端为 A, 服务端为 B。</p><ol><li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li><li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li><li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li></ol><h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3><p>（1）四次挥手有什么用？</p><ul><li>四次挥手负责断开 TCP 连接。</li></ul><p>（2）什么是四次挥手？</p><p>如上图所示，四次挥手流程如下：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/四次挥手.gif!zp"/></div><ol><li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li><li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li><li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li><li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li></ol><p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p><ul><li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li><li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li></ul><h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2><p>什么是滑动窗口？</p><p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p><p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p><p>滑动窗口原理是什么？</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265819762.png!zp"/></div><ol><li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li><li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li><li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li><li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li></ol><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559265927658.png!zp"/></div><p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p><h2 id="tcp-重传机制"><a class="markdownIt-Anchor" href="#tcp-重传机制"></a> TCP 重传机制</h2><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>TCP 重传机制主要有两种：</p><ul><li>超时重传机制</li><li>快速重传机制</li></ul><h3 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h3><p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p><p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p><p>这种机制的重点是 RTO 的设置：</p><ul><li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li></ul><h3 id="快速重传机制"><a class="markdownIt-Anchor" href="#快速重传机制"></a> 快速重传机制</h3><p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p><p>当接收方收到乱序片段时，需要重复发送 ACK。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></li><li><a href="https://juejin.im/post/5a7835a46fb9a063606eb801" target="_blank" rel="noopener">图解 TCP 三次握手与四次分手</a></li><li><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP 的三次握手与四次挥手（详解+动图）</a></li><li><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678" target="_blank" rel="noopener">TCP 详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;h3 id=&quot;什么是-tcp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是-tcp&quot;&gt;&lt;/a&gt; 什么是 TCP&lt;
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络通信之 CDN</title>
    <link href="https://dunwu.github.io/blog/communication/cdn/"/>
    <id>https://dunwu.github.io/blog/communication/cdn/</id>
    <published>2019-05-29T15:19:00.000Z</published>
    <updated>2019-11-21T12:10:33.396Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559138689425.png!zp"/></div><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="cdn-是什么"><a class="markdownIt-Anchor" href="#cdn-是什么"></a> CDN 是什么</h3><p>CDN(<strong>Content Delivery Network</strong>)，即<strong>内容分发网络</strong>。</p><p>CDN 是一个全球性的代理服务器分布式网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。CDN 的 DNS 解析会告知客户端连接哪台服务器。CDN 的关键技术主要有内容存储和分发技术。</p><h3 id="cdn-的优缺点"><a class="markdownIt-Anchor" href="#cdn-的优缺点"></a> CDN 的优缺点</h3><ul><li>优点<ul><li><strong>访问加速</strong> - 由于 CDN 就近服务，大大降低了网络传播时延，所以自然提高了访问速度。</li><li><strong>降低负载</strong> - 如果 CDN 已经能获取数据，那么就不必请求源站，这自然降低了源站（服务器）的负载。</li></ul></li><li>缺点<ul><li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li><li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li><li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li></ul></li></ul><h2 id="cdn-原理"><a class="markdownIt-Anchor" href="#cdn-原理"></a> CDN 原理</h2><p>CDN 的基本原理是：</p><ul><li>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中；</li><li>在用户访问网站时，实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息来选择最佳缓存服务器；</li><li>然后，将用户的请求重新导向最佳的缓存服务器上，由缓存服务器直接响应用户请求。</li></ul><p>CDN 网络架构主要由两大部分，分为<strong>中心</strong>和<strong>边缘</strong>两部分：</p><ul><li>中心指 CDN 网管中心和 DNS 重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房；</li><li>边缘主要指异地节点，CDN 分发的载体，主要由 Cache 和负载均衡器等组成。</li></ul><p>CDN 是一个策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>内容管理</strong>和<strong>网络请求的重定向</strong>４个要件。</p><h3 id="分布式存储"><a class="markdownIt-Anchor" href="#分布式存储"></a> 分布式存储</h3><p>CDN 网络将存储资源分布到各个地理位置、各个网段。存储系统作为 CDN 系统密不可分的一部分，将 CDN 分发的文件和数据库表记录内容存储起来，提供持续服务。存储系统采用三级存储架构，包括核心存储、CDN 服务节点分布式缓存和终端本地缓存。任意一个点的存储崩溃或失效，并不影响系统服务的可用性。</p><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559140068433.png!zp"/></div><p>如 CDN 系统在 5 大运营商（中国电信、中国网通、中国铁通、中国移动、中国联通）以及 2 大专有网络（中国教育和科研计算机网、中国科技网）都布有 CDN 节点。<strong>这样就消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。</strong></p><h3 id="内容管理"><a class="markdownIt-Anchor" href="#内容管理"></a> 内容管理</h3><p>内容管理和全局的网络流量管理(Traffic Management)是 CDN 的核心所在。<strong>通过用户就近性和服务器负载的判断，CDN 确保内容以一种极为高效的方式为用户的请求提供服务</strong>。总的来说，内容服务基于<strong>缓存服务器</strong>，也称作<strong>代理缓存(Surrogate)</strong>，它位于网络的边缘，距用户仅有&quot;一跳&quot;(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于 CDN 服务提供商的数据中心）的一个透明镜像。这样的架构使得 CDN 服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。据统计，采用 CDN 技术，能处理整个网站页面的 70%～ 95％的内容访问量，减轻服务器的压力，提升了网站的性能和可扩展性。</p><h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3><p>CDN 负载均衡系统实现 CDN 的<strong>内容路由功能</strong>。它的作用是将用户的请求导向整个 CDN 网络中的最佳节点。最佳节点的选定可以根据多种策略，例如<strong>距离最近</strong>、<strong>节点负载最轻</strong>等。负载均衡系统是整个 CDN 的核心，负载均衡的准确性和效率直接决定了整个 CDN 的效率和性能。通常负载均衡可以分为两个层次：<strong>全局负载均衡（GSLB）<strong>和</strong>本地负载均衡（SLB）</strong>。</p><h3 id="网络请求的重定向"><a class="markdownIt-Anchor" href="#网络请求的重定向"></a> 网络请求的重定向</h3><p>当用户访问了使用 CDN 服务的资源时，DNS 域名服务器通过 CNAME 方式将最终域名请求重定向到 CDN 系统中的智能 DNS 负载均衡系统。<strong>智能 DNS 负载均衡系统通过一组预先定义好的策略（如内容类型、地理区域、网络负载状况等），将当时能够最快响应用户的节点地址提供给用户，使用户可以得到快速的服务</strong>。</p><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li></ul></blockquote><h2 id="cdn-访问流程"><a class="markdownIt-Anchor" href="#cdn-访问流程"></a> CDN 访问流程</h2><div align="center"><img src="http://dunwu.test.upcdn.net/snap/1559126750010.png!zp"/></div><ol><li>用户在浏览器中访问域名，域名解析的请求被发往网站的 DNS 域名解析服务器；</li><li>由于网站的 DNS 域名解析服务器对此域名的解析设置了 CNAME，请求被指向 CDN 网络中的智能 DNS 负载均衡系统；</li><li>智能 DNS 负载均衡系统对域名进行智能解析，将响应速度最快的节点 IP 返回给用户；浏览器在得到速度最快节点的 IP 地址以后，向 CDN 节点发出访问请求；</li><li>由于是第一次访问，CDN 节点将回到源站取用户请求的数据并发给用户；</li><li>当有其他用户再次访问同样内容时，CDN 将直接将数据返回给客户，完成请求/服务过程。</li></ol><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li></ul></blockquote><h2 id="推送和拉取"><a class="markdownIt-Anchor" href="#推送和拉取"></a> 推送和拉取</h2><p>CDN 服务有推送和拉取两种方式：</p><h3 id="cdn-推送"><a class="markdownIt-Anchor" href="#cdn-推送"></a> CDN 推送</h3><p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p><p>优点在于节省源站带宽，提前将要分发的内容放到 CDN 节点上了，当某个流量高峰来临时，不会把你的源站带宽占满（源站还要留点带宽提供动态 HTML 啊）。</p><p>缺点是需要针对 CDN 做接口开发，在被分发内容生成时主动上传给 CDN。</p><h3 id="cdn-拉取"><a class="markdownIt-Anchor" href="#cdn-拉取"></a> CDN 拉取</h3><p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p><p><a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p><p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p><p>优点在于实现简单。</p><blockquote><p>参考：<a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></p></blockquote><h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2><ul><li>文章<ul><li><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">Wikipedia - CDN</a></li><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li><li><a href="https://www.cnblogs.com/losbyday/p/5843960.html" target="_blank" rel="noopener">CDN 技术详解</a></li><li><a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></li></ul></li><li>CDN 资源<ul><li><a href="https://staticfile.org/" target="_blank" rel="noopener">https://staticfile.org/</a></li><li><a href="https://unpkg.com/" target="_blank" rel="noopener">https://unpkg.com/</a></li><li><a href="https://cdnjs.com/" target="_blank" rel="noopener">https://cdnjs.com/</a></li><li><a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li><li><a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="noopener">https://github.com/jsdelivr/jsdelivr</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://dunwu.test.upcdn.net/snap/1559138689425.png!zp&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Title</title>
    <link href="https://dunwu.github.io/blog/design/architecture/README/"/>
    <id>https://dunwu.github.io/blog/design/architecture/README/</id>
    <published>2019-03-08T05:16:53.000Z</published>
    <updated>2019-05-08T10:07:49.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构设计"><a class="markdownIt-Anchor" href="#架构设计"></a> 架构设计</h1><p>架构设计是为业务服务，<strong>脱离业务实际的架构设计都是纸上谈兵</strong>。</p><p>架构设计需要根据架构师自身的经验，在实现业务功能、性能、扩展性、系统复杂度等维度上综合考量以及权衡。而架构设计的经验需要架构师不断的学习、不断的积累。性能、扩展性、系统复杂度等方面有很多个专题，有必要针对每个专题由浅入深的去理解、掌握。</p><h2 id="专题"><a class="markdownIt-Anchor" href="#专题"></a> 专题</h2><h2 id="如何设计"><a class="markdownIt-Anchor" href="#如何设计"></a> 如何设计</h2><h3 id="第一步需求分析"><a class="markdownIt-Anchor" href="#第一步需求分析"></a> 第一步：需求分析</h3><p>需求分析阶段，要做的就是<strong>分析使用场景，约束和假设</strong>。</p><p>这个阶段，应该以审视的角度，不断提问、求证，以挖掘用户真实的需求。</p><ul><li>系统是什么？系统有什么功能？</li><li>谁是系统的用户群体？用户群体的规模是多大？</li><li>系统的输入输出分别是什么？</li><li>系统希望处理多少数据？</li><li>系统希望每秒钟处理多少请求？</li><li>系统希望的读写比率？</li></ul><h3 id="第二步概要设计"><a class="markdownIt-Anchor" href="#第二步概要设计"></a> 第二步：概要设计</h3><p>创造一个高层级的设计</p><h3 id="第三步详细设计"><a class="markdownIt-Anchor" href="#第三步详细设计"></a> 第三步：详细设计</h3><ul><li>数据库选型：SQL 还是 NOSQL</li><li>数据库模型</li><li>API 和面向对象设计</li></ul><h3 id="第四步扩展设计"><a class="markdownIt-Anchor" href="#第四步扩展设计"></a> 第四步：扩展设计</h3><ul><li>负载均衡</li><li>水平扩展</li><li>缓存</li><li>数据库分片</li><li>消息队列</li></ul><h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li>文章<ul><li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">系统设计入门</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;架构设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#架构设计&quot;&gt;&lt;/a&gt; 架构设计&lt;/h1&gt;
&lt;p&gt;架构设计是为业务服务，&lt;strong&gt;脱离业务实际的架构设计都是纸上谈兵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;架构设计需要根据架构师自
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/blog/categories/design/architecture/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/blog/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>HBase 维护</title>
    <link href="https://dunwu.github.io/blog/bigdata/hbase/hbase-ops/"/>
    <id>https://dunwu.github.io/blog/bigdata/hbase/hbase-ops/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-05-08T10:07:48.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hbase-维护"><a class="markdownIt-Anchor" href="#hbase-维护"></a> HBase 维护</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82">环境要求</a></li><li><a href="#%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%B3">引用和引申</a><ul><li><a href="#%E5%BC%95%E7%94%B3">引申</a></li></ul></li></ul><!-- /TOC --><h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2><ul><li><code>backup-masters</code> - 默认情况下不存在。列出主服务器应在其上启动备份主进程的主机，每行一个主机。</li><li><code>hadoop-metrics2-hbase.properties</code> - 用于连接 HBase Hadoop 的 Metrics2 框架。</li><li><code>hbase-env.cmd</code> and <a href="http://hbase-env.sh" target="_blank" rel="noopener">hbase-env.sh</a> - 用于 Windows 和 Linux / Unix 环境的脚本，用于设置 HBase 的工作环境，包括 Java，Java 选项和其他环境变量的位置。</li><li><code>hbase-policy.xml</code> - RPC 服务器用于对客户端请求进行授权决策的默认策略配置文件。仅在启用 HBase 安全性时使用。</li><li><code>hbase-site.xml</code> - 主要的 HBase 配置文件。此文件指定覆盖 HBase 默认配置的配置选项。您可以在 docs / hbase-default.xml 中查看（但不要编辑）默认配置文件。您还可以在 HBase Web UI 的 HBase 配置选项卡中查看群集的整个有效配置（默认值和覆盖）。</li><li><code>log4j.properties</code> - log4j 日志配置。</li><li><code>regionservers</code> - 包含应在 HBase 集群中运行 RegionServer 的主机列表。默认情况下，此文件包含单个条目 localhost。它应包含主机名或 IP 地址列表，每行一个，并且如果群集中的每个节点将在其 localhost 接口上运行 RegionServer，则应仅包含 localhost。</li></ul><h2 id="环境要求"><a class="markdownIt-Anchor" href="#环境要求"></a> 环境要求</h2><ul><li>Java<ul><li>HBase 2.0+ 要求 JDK8+</li><li>HBase 1.2+ 要求 JDK7+</li></ul></li><li>SSH - 环境要支持 SSH</li><li>DNS - 环境中要在 hosts 配置本机 hostname 和本机 IP</li><li>NTP - HBase 集群的时间要同步，可以配置统一的 NTP</li><li>平台 - 生产环境不推荐部署在 Windows 系统中</li><li>Hadoop - 依赖 Hadoop 配套版本</li><li>Zookeeper - 依赖 Zookeeper 配套版本</li></ul><h2 id="运行模式"><a class="markdownIt-Anchor" href="#运行模式"></a> 运行模式</h2><h3 id="单点"><a class="markdownIt-Anchor" href="#单点"></a> 单点</h3><p>hbase-site.xml 配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://namenode.example.org:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分布式"><a class="markdownIt-Anchor" href="#分布式"></a> 分布式</h3><p>hbase-site.xm 配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://namenode.example.org:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node-a.example.com,node-b.example.com,node-c.example.com<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引用和引申"><a class="markdownIt-Anchor" href="#引用和引申"></a> 引用和引申</h2><h3 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h3><ul><li><a href="http://hbase.apache.org/book.html#configuration" target="_blank" rel="noopener">Apache HBase Configuration</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hbase-维护&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hbase-维护&quot;&gt;&lt;/a&gt; HBase 维护&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络之传输层</title>
    <link href="https://dunwu.github.io/blog/communication/network-transport/"/>
    <id>https://dunwu.github.io/blog/communication/network-transport/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-11-21T12:10:33.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p></blockquote><h2 id="udp-和-tcp-的特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-的特点"></a> UDP 和 TCP 的特点</h2><ul><li><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p></li><li><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p></li></ul><h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092392065.png!zp"/></div><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092419042.png!zp"/></div><ul><li><p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="tcp-的三次握手"><a class="markdownIt-Anchor" href="#tcp-的三次握手"></a> TCP 的三次握手</h2><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092794258.png!zp"/></div><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="tcp-的四次挥手"><a class="markdownIt-Anchor" href="#tcp-的四次挥手"></a> TCP 的四次挥手</h2><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092825974.png!zp"/></div><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p></li></ul><h2 id="tcp-可靠传输"><a class="markdownIt-Anchor" href="#tcp-可靠传输"></a> TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"/></div> <br><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"/></div> <br><p>其中 RTT<sub>d</sub> 为偏差的加权平均值。</p><h2 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h2><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092841802.png!zp"/></div><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><h2 id="tcp-流量控制"><a class="markdownIt-Anchor" href="#tcp-流量控制"></a> TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="tcp-拥塞控制"><a class="markdownIt-Anchor" href="#tcp-拥塞控制"></a> TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551092981695.png!zp"/></div><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551093119265.png!zp"/></div><h3 id="1-慢开始与拥塞避免"><a class="markdownIt-Anchor" href="#1-慢开始与拥塞避免"></a> 1. 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><h3 id="2-快重传与快恢复"><a class="markdownIt-Anchor" href="#2-快重传与快恢复"></a> 2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/transport/1551093167163.png!zp"/></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之数据链路层</title>
    <link href="https://dunwu.github.io/blog/communication/network-data-link/"/>
    <id>https://dunwu.github.io/blog/communication/network-data-link/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-11-21T12:10:33.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p><ul><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul></blockquote><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li>链路是从一个节点到相邻节点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（网络适配器）和软件（协议）。</li><li>数据链路层三个基本问题：封装成帧、透明传输、差错检测。</li><li>数据链路层有两种信道类型：点对点信道（主要使用 <code>PPP</code>）和广播信道（主要使用 <code>CSMA/CD</code>）。</li><li>以太网 MAC 层的地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用及使用场合。</li></ul><h2 id="基本问题"><a class="markdownIt-Anchor" href="#基本问题"></a> 基本问题</h2><h3 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h3><p>为网络层传下来的 IP 数据报添加首部和尾部，用于标记帧的开始和结束。</p><p>为了提高传输效率，应该让数据部分长度尽可能大于首部和尾部。但是，每种链路层协议都限制了帧的数据部分长度上线——最大传送单元 MTU（Maximum Transfer Unit）</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/数据链路帧.png!zp"/></div><h3 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h3><p><strong>透明</strong>表示：某一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/经过字节填充后发送的数据.png!zp"/></div><h3 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h3><p>目前数据链路层广泛使用了<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C" target="_blank" rel="noopener"><strong>循环冗余检验 CRC（Cyclic redundancy check）</strong></a>来检查比特差错。</p><h2 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h2><p>点对点信道使用一对一的点对点通信方式。</p><p>对于点对点的链路，点对点协议 PPP（Point-to-Point Protocol）是使用最广泛的数据链路层协议。</p><h3 id="ppp-协议"><a class="markdownIt-Anchor" href="#ppp-协议"></a> PPP 协议</h3><p>互联网用户通常都要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/PPP协议.png!zp"/></div><p>PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/PPP帧.png!zp"/></div><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><h2 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h2><p>广播信道(broadcast channel)是通过广播的方式传输信息的信息通道。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="csmacd-协议"><a class="markdownIt-Anchor" href="#csmacd-协议"></a> CSMA/CD 协议</h3><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p><ul><li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</li><li><strong>碰撞检测</strong> ：即边发送边检测。若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。计算退避等待时间采用的是<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二进制指数退避算法</a>。</li></ul><h2 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h2><p>局域网 LAN（Local Area Network）是指在某一区域内由多台计算机互联成的计算机组。</p><p>局域网的拓扑结构通常为总线型和环型。</p><p>局域网技术主要有：以太网、令牌环网、FDDI 网和无线局域网等。</p><h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2><p>以太网（Ethernet）是一种星型拓扑结构局域网。</p><p>以太网是目前应用最广泛的局域网。</p><p>以太网使用 CSMA/CD 协议。</p><h2 id="mac-地址"><a class="markdownIt-Anchor" href="#mac-地址"></a> MAC 地址</h2><p>MAC 地址（Media Access Control Address），也称为以太网地址或物理地址，它是一个用来确认网上设备位置的地址。</p><p>MAC 地址长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/data-link/MAC帧.png!zp"/></div><h2 id="设备"><a class="markdownIt-Anchor" href="#设备"></a> 设备</h2><h3 id="适配器"><a class="markdownIt-Anchor" href="#适配器"></a> 适配器</h3><p>网络适配器一般指网卡。</p><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>网卡和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而网卡和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行。</p><h3 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器</h3><p>集线器（Hub）的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p><p>使用集线器可以在物理层扩展以太网。</p><h3 id="网桥"><a class="markdownIt-Anchor" href="#网桥"></a> 网桥</h3><p>网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。</p><h3 id="以太网交换机"><a class="markdownIt-Anchor" href="#以太网交换机"></a> 以太网交换机</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p><ul><li>以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。</li><li>交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</li><li>用户独占传输媒体的带宽，若一个接口到主机的带宽是 10Mbit 每秒，那么有 10 个接口的交换机的总容量是 100Mbit 每秒。这是交换机的最大优点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据链路层（Data Link Layer）&lt;/strong&gt; - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之网络层</title>
    <link href="https://dunwu.github.io/blog/communication/network-network/"/>
    <id>https://dunwu.github.io/blog/communication/network-network/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-11-21T12:10:33.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>网络层（network layer）</strong> - 为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p><ul><li>主要协议：<code>IP</code>、<code>ICMP</code>。</li><li>数据单元：IP 数据报（packet）。</li><li>典型设备：网关、路由器。</li></ul></blockquote><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程间通信的可靠性由运输层负责。</p><h2 id="ip-协议"><a class="markdownIt-Anchor" href="#ip-协议"></a> IP 协议</h2><p>网际协议 IP (Internet Protocol) 定义了三种功能：</p><ol><li>IP 定义了在 TCP/IP 互联网上数据传送的基本单元和数据格式。</li><li>IP 软件完成路由选择功能，选择数据传送的路径。</li><li>IP 包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。</li></ol><h3 id="相关协议"><a class="markdownIt-Anchor" href="#相关协议"></a> 相关协议</h3><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1550912617336.png!zp"/></div><h3 id="分类的-ip-地址"><a class="markdownIt-Anchor" href="#分类的-ip-地址"></a> 分类的 IP 地址</h3><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h4 id="1-分类"><a class="markdownIt-Anchor" href="#1-分类"></a> 1. 分类</h4><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086738403.png!zp"/></div><h4 id="2-子网划分"><a class="markdownIt-Anchor" href="#2-子网划分"></a> 2. 子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><h4 id="3-无分类"><a class="markdownIt-Anchor" href="#3-无分类"></a> 3. 无分类</h4><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h3 id="ip-地址与物理地址"><a class="markdownIt-Anchor" href="#ip-地址与物理地址"></a> IP 地址与物理地址</h3><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551088476626.png!zp"/></div><ul><li>物理地址是数据链路层和物理层使用的地址。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551088631948.png!zp"/></div><h3 id="ip-数据报格式"><a class="markdownIt-Anchor" href="#ip-数据报格式"></a> IP 数据报格式</h3><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1550913213250.png!zp"/></div><ul><li><strong>版本</strong> - 有 4（IPv4）和 6（IPv6）两个值。</li><li><strong>首部长度</strong> - 占 4 位，因此最大十进制数值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> - 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> - 包括首部长度和数据部分长度。占 16 位，因此数据报的最大长度为 2 <sup>16</sup> - 1 = 65535 字节。</li><li><strong>生存时间</strong> - TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> - 指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> - 因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong> - 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong> - 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1550913364479.png!zp"/></div><h2 id="地址解析协议-arp"><a class="markdownIt-Anchor" href="#地址解析协议-arp"></a> 地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086787261.png!zp"/></div><p>ARP 实现由 IP 地址得到 MAC 地址。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086769846.png!zp"/></div><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086833117.png!zp"/></div><h2 id="网际控制报文协议-icmp"><a class="markdownIt-Anchor" href="#网际控制报文协议-icmp"></a> 网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086857345.png!zp"/></div><p>ICMP 报文分为差错报告报文和询问报文。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086870897.png!zp"/></div><h3 id="1-ping"><a class="markdownIt-Anchor" href="#1-ping"></a> 1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="2-traceroute"><a class="markdownIt-Anchor" href="#2-traceroute"></a> 2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="虚拟专用网-vpn"><a class="markdownIt-Anchor" href="#虚拟专用网-vpn"></a> 虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086901339.png!zp"/></div><h2 id="网络地址转换-nat"><a class="markdownIt-Anchor" href="#网络地址转换-nat"></a> 网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><h2 id="路由器的结构"><a class="markdownIt-Anchor" href="#路由器的结构"></a> 路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086930371.png!zp"/></div><h2 id="路由器分组转发流程"><a class="markdownIt-Anchor" href="#路由器分组转发流程"></a> 路由器分组转发流程</h2><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086952828.png!zp"/></div><h2 id="路由选择协议"><a class="markdownIt-Anchor" href="#路由选择协议"></a> 路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><h3 id="1-内部网关协议-rip"><a class="markdownIt-Anchor" href="#1-内部网关协议-rip"></a> 1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-ospf"><a class="markdownIt-Anchor" href="#2-内部网关协议-ospf"></a> 2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议-bgp"><a class="markdownIt-Anchor" href="#3-外部网关协议-bgp"></a> 3. 外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/network/1551086977310.png!zp"/></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;网络层（network layer）&lt;/strong&gt; - 为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要协议：&lt;code&gt;IP&lt;/
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>UML 教程</title>
    <link href="https://dunwu.github.io/blog/design/UML/"/>
    <id>https://dunwu.github.io/blog/design/UML/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-08-21T05:20:27.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uml-教程"><a class="markdownIt-Anchor" href="#uml-教程"></a> UML 教程</h1><blockquote><p>关键词：<code>部署图</code>, <code>组件图</code>, <code>包图</code>, <code>类图</code>, <code>复合结构图</code>, <code>对象图</code>, <code>活动图</code>, <code>状态机图</code>, <code>用例图</code>, <code>通信图</code>, <code>交互概述图</code>, <code>时序图</code>, <code>时间图</code></p></blockquote><!-- TOC depthFrom:2 depthTo:2 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E5%9B%BE">部署图</a></li><li><a href="#%E7%BB%84%E4%BB%B6%E5%9B%BE">组件图</a></li><li><a href="#%E5%8C%85%E5%9B%BE">包图</a></li><li><a href="#%E7%B1%BB%E5%9B%BE">类图</a></li><li><a href="#%E5%A4%8D%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE">复合结构图</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE">对象图</a></li><li><a href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE">活动图</a></li><li><a href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9B%BE">状态机图</a></li><li><a href="#%E7%94%A8%E4%BE%8B%E5%9B%BE">用例图</a></li><li><a href="#%E9%80%9A%E4%BF%A1%E5%9B%BE">通信图</a></li><li><a href="#%E4%BA%A4%E4%BA%92%E6%A6%82%E8%BF%B0%E5%9B%BE">交互概述图</a></li><li><a href="#%E6%97%B6%E5%BA%8F%E5%9B%BE">时序图</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%9B%BE">时间图</a></li><li><a href="#uml-%E5%B7%A5%E5%85%B7">UML 工具</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9">更多内容</a></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="uml-图类型"><a class="markdownIt-Anchor" href="#uml-图类型"></a> UML 图类型</h3><p>UML 图类型如下图所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-diagrams.png"/></div><h4 id="结构式建模图"><a class="markdownIt-Anchor" href="#结构式建模图"></a> <a href="UML%E7%BB%93%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9B%BE.md">结构式建模图</a></h4><blockquote><p>结构式建模图（Structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素’建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。</p></blockquote><ul><li><a href="#%E7%B1%BB%E5%9B%BE">类图</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE">对象图</a></li><li><a href="#%E5%8C%85%E5%9B%BE">包图</a></li><li><a href="#%E7%BB%84%E4%BB%B6%E5%9B%BE">组件图</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E5%9B%BE">部署图</a></li><li><a href="#%E5%A4%8D%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE">复合结构图</a></li></ul><h4 id="行为式建模图"><a class="markdownIt-Anchor" href="#行为式建模图"></a> <a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md">行为式建模图</a></h4><blockquote><p>行为式建模图（Behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。</p></blockquote><ul><li><a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md#%E6%B4%BB%E5%8A%A8%E5%9B%BE">活动图</a></li><li><a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md#%E7%8A%B6%E6%80%81%E5%9B%BE">状态图</a></li><li><a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md#%E7%94%A8%E4%BE%8B%E5%9B%BE">用例图</a></li><li><a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md#%E9%80%9A%E4%BF%A1%E5%9B%BE">通信图</a></li><li><a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md#%E4%BA%A4%E4%BA%92%E6%A6%82%E8%BF%B0%E5%9B%BE">交互概述图</a></li><li><a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md#%E6%97%B6%E5%BA%8F%E5%9B%BE">时序图</a></li><li><a href="UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.md#%E6%97%B6%E9%97%B4%E5%9B%BE">时间图</a></li></ul><h3 id="uml-概念"><a class="markdownIt-Anchor" href="#uml-概念"></a> UML 概念</h3><p>UML 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。</p><ul><li>对于结构而言 - 执行者，属性，类，元件，接口，对象，包。</li><li>对于行为而言 - 活动（UML），事件（UML），消息（UML），方法（UML），操作（UML），状态（UML），用例（UML）。</li><li>对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。</li><li>其他概念<ul><li>构造型—这规范符号应用到的模型</li><li>多重性—多重性标记法与资料库建模基数对应，例如：<code>1, 0..1, 1..*</code></li></ul></li></ul><h2 id="部署图"><a class="markdownIt-Anchor" href="#部署图"></a> 部署图</h2><blockquote><p><strong>部署图（Deployment Diagram）用于对系统的物理结构建模</strong>。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-deployment-diagram-example.png"/></div><h3 id="节点"><a class="markdownIt-Anchor" href="#节点"></a> 节点</h3><p>节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-node.gif"/></div><h3 id="节点实例"><a class="markdownIt-Anchor" href="#节点实例"></a> 节点实例</h3><p>图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-node-instance.gif"/></div><h3 id="节点构造型"><a class="markdownIt-Anchor" href="#节点构造型"></a> 节点构造型</h3><p>为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-node-stereotype.gif"/></div><h3 id="工件"><a class="markdownIt-Anchor" href="#工件"></a> 工件</h3><p>工件是<a href="http://www.sparxsystems.cn/platforms/software_development.html" target="_blank" rel="noopener">软件开发</a>过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。</p><p>工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-artifact.gif"/></div><h3 id="关联"><a class="markdownIt-Anchor" href="#关联"></a> 关联</h3><p>在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-network-model.gif"/></div><h3 id="作为容器的节点"><a class="markdownIt-Anchor" href="#作为容器的节点"></a> 作为容器的节点</h3><p>节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-embedded-model.gif"/></div><h2 id="组件图"><a class="markdownIt-Anchor" href="#组件图"></a> 组件图</h2><blockquote><p><strong>组件图（Component Diagram）描绘了组成一个软件系统的模块和嵌入控件</strong>。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-component-diagram.gif"/></div><p>上图演示了一些组件和它们的内部关系。装配连接器（Assembly connectors）“连接”由&quot;Product&quot;和&quot;Customer&quot;的提供接口到由 &quot;Order&quot;指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“Order”需要的 &quot;Payment&quot;需求接口。</p><p>实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。</p><h3 id="表现组件"><a class="markdownIt-Anchor" href="#表现组件"></a> 表现组件</h3><p>组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-representing-components.gif"/></div><h3 id="装配连接器"><a class="markdownIt-Anchor" href="#装配连接器"></a> 装配连接器</h3><p>装配连接器在组件 “Component1”的需求接口和另一个组件 “Component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-required-interfaces.gif"/></div><h3 id="带端口组件"><a class="markdownIt-Anchor" href="#带端口组件"></a> 带端口组件</h3><p>使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-component-with-ports.gif"/></div><h2 id="包图"><a class="markdownIt-Anchor" href="#包图"></a> 包图</h2><blockquote><p><strong>包图（Package Diagram）用来表现包和它所包含元素的组织</strong>。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 UML 元素。</p></blockquote><p>下面是一个包图的例子。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-package-diagram.gif"/></div><p>包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。</p><p>包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-package.gif"/></div><p>在 UML2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。</p><ul><li><strong>包的合并</strong> - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。</li><li><strong>包的导入</strong> - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。</li><li><strong>嵌套连接符</strong> - 源包和目标包间的嵌套连接符说明目标包完全包含源包。</li></ul><h2 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h2><blockquote><p><strong>类图（Class Diagram）展示了面向对象系统的构造模块</strong>。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（Generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。</p></blockquote><p>下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 “Account” 使用 “AddressBook”，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，“Contact” 和 &quot;ContactGroup&quot;值被包含在 &quot;AddressBook&quot;中。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-class-diagram.png"/></div><h3 id="类classes"><a class="markdownIt-Anchor" href="#类classes"></a> 类（Classes）</h3><p>类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。</p><h3 id="类的标柱class-notation"><a class="markdownIt-Anchor" href="#类的标柱class-notation"></a> 类的标柱（Class Notation）</h3><p>类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。</p><p>在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如：“center” 属性显示初始化的值。最后面的分栏显示操作，如： setWidth，setLength 和 setPosition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 &quot;+&quot;号，这个属性或操作是公共的 ; “-” 号则代表这个属性或操作是私有的。 “#“号是这个属性或操作被定义为保护的，” ~” 号代表包的可见性。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-class.gif"/></div><h3 id="接口interfaces"><a class="markdownIt-Anchor" href="#接口interfaces"></a> 接口（Interfaces）</h3><p>接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-class-interface.gif"/></div><p>接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interface.gif"/></div><h3 id="表tables"><a class="markdownIt-Anchor" href="#表tables"></a> 表（Tables）</h3><p>表尽管不是基本 UML 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«PK»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«FK»。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-table.gif"/></div><h3 id="关联associations"><a class="markdownIt-Anchor" href="#关联associations"></a> 关联（Associations）</h3><p>关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 “playsFor” 将变成&quot;Player&quot;类中的实例变量。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-associations.gif"/></div><h3 id="泛化generalizations"><a class="markdownIt-Anchor" href="#泛化generalizations"></a> 泛化（Generalizations）</h3><p>泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“Circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 “Shape” 是抽象的，类名显示为斜体。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-generalizations.gif"/></div><p>下图显示了与上图相同信息的视图。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-generalizations-02.gif"/></div><h3 id="聚合aggregations"><a class="markdownIt-Anchor" href="#聚合aggregations"></a> 聚合（Aggregations）</h3><p>聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。</p><p>聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。</p><p>下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-aggregations.gif"/></div><h3 id="关联类association-classes"><a class="markdownIt-Anchor" href="#关联类association-classes"></a> 关联类（Association Classes）</h3><p>关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-association-classes.gif"/></div><h3 id="依赖dependencies"><a class="markdownIt-Anchor" href="#依赖dependencies"></a> 依赖（Dependencies）</h3><p>依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。</p><h3 id="跟踪traces"><a class="markdownIt-Anchor" href="#跟踪traces"></a> 跟踪（Traces）</h3><p>跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。</p><h3 id="实现realizations"><a class="markdownIt-Anchor" href="#实现realizations"></a> 实现（Realizations）</h3><p>是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-realizations.gif"/></div><h3 id="嵌套nestings"><a class="markdownIt-Anchor" href="#嵌套nestings"></a> 嵌套（Nestings）</h3><p>嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 EA 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-nestings.gif"/></div><h2 id="复合结构图"><a class="markdownIt-Anchor" href="#复合结构图"></a> 复合结构图</h2><blockquote><p><strong>复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。</strong></p></blockquote><p>类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-composite-structure-diagram.gif"/></div><h3 id="部件"><a class="markdownIt-Anchor" href="#部件"></a> 部件</h3><p>部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。<br />部件在类或组件内部显示为不加修饰的方框。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-part.gif"/></div><h3 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h3><p>端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。<br />端口显示为所属类元边界指定的方框。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-port.gif"/></div><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。<br />当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interface.gif"/></div><p>注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。<br />提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interface-02.gif"/></div><h3 id="委托"><a class="markdownIt-Anchor" href="#委托"></a> 委托</h3><p>委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-delegate.gif"/></div><h3 id="协作"><a class="markdownIt-Anchor" href="#协作"></a> 协作</h3><p>协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。<br />协作元素显示为椭圆。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-collaboration.gif"/></div><h3 id="角色绑定"><a class="markdownIt-Anchor" href="#角色绑定"></a> 角色绑定</h3><p>角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-role-binding.gif"/></div><h3 id="表现"><a class="markdownIt-Anchor" href="#表现"></a> 表现</h3><p>表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-represent.gif"/></div><p>发生<br />发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-occurrence.gif"/></div><h2 id="对象图"><a class="markdownIt-Anchor" href="#对象图"></a> 对象图</h2><blockquote><p><strong>对象图（Object Diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系</strong>。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。</p></blockquote><h3 id="类和对象元素"><a class="markdownIt-Anchor" href="#类和对象元素"></a> 类和对象元素</h3><p>下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object.gif"/></div><h3 id="运行状态"><a class="markdownIt-Anchor" href="#运行状态"></a> 运行状态</h3><p>类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-run-time-state.gif"/></div><h3 id="类和对象图示例"><a class="markdownIt-Anchor" href="#类和对象图示例"></a> 类和对象图示例</h3><p>下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object-diagram.gif"/></div><h2 id="活动图"><a class="markdownIt-Anchor" href="#活动图"></a> 活动图</h2><blockquote><p>UML 中，活动图用来展示活动的顺序。<strong>显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径</strong>。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。<br />一个活动图的示例如下所示。</p></blockquote><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-diagram.gif"/></div><p>下面描述组成活动图的元素。</p><h3 id="活动"><a class="markdownIt-Anchor" href="#活动"></a> 活动</h3><p>活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity.gif"/></div><h3 id="动作"><a class="markdownIt-Anchor" href="#动作"></a> 动作</h3><p>一个动作代表活动中的一个步骤。动作用圆角矩形表示。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-action.gif"/></div><h3 id="动作约束"><a class="markdownIt-Anchor" href="#动作约束"></a> 动作约束</h3><p>动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-conditions.gif"/></div><h3 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h3><p>控制流显示一个动作到下一个动作的流。表示为带箭头实线</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-edge.gif"/></div><h3 id="初始节点"><a class="markdownIt-Anchor" href="#初始节点"></a> 初始节点</h3><p>一个开始或起始点用大黑圆点表示，如下图。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-initial.gif"/></div><h3 id="结束节点"><a class="markdownIt-Anchor" href="#结束节点"></a> 结束节点</h3><p>结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-final.gif"/></div><p>流结束节点表示为内部为叉号的圆环。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-flow-final.gif"/></div><p>这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。</p><h3 id="对象和对象流"><a class="markdownIt-Anchor" href="#对象和对象流"></a> 对象和对象流</h3><p>对象流是对象和数据转递的通道。对象显示为矩形。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-object.gif"/></div><p>对象流显示为带箭头的连接器，表明方向和通过的对象。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object-flow.gif"/></div><p>一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-object-flow-alt.gif"/></div><p>数据存储显示为带 «datastore» 关键字的对象。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-data-store.gif"/></div><h3 id="判断节点和合并节点"><a class="markdownIt-Anchor" href="#判断节点和合并节点"></a> 判断节点和合并节点</h3><p>判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-decision-or-merge.gif"/></div><h3 id="分叉和结合节点"><a class="markdownIt-Anchor" href="#分叉和结合节点"></a> 分叉和结合节点</h3><p>分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-fork-and-join.gif"/></div><p>结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。</p><h3 id="扩展域"><a class="markdownIt-Anchor" href="#扩展域"></a> 扩展域</h3><p>扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 “iterative”， “parallel” 或 &quot;stream&quot;显示在区域的左上角</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-expansion-region.gif"/></div><h3 id="异常处理器"><a class="markdownIt-Anchor" href="#异常处理器"></a> 异常处理器</h3><p>异常处理器在活动图中可以建模。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-exception-handler.gif"/></div><h3 id="可中断活动区"><a class="markdownIt-Anchor" href="#可中断活动区"></a> 可中断活动区</h3><p>可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 “Close Order” 动作，定单处理&quot;Process Order&quot; 动作会执行直到完成，除非&quot;Cancel Request&quot;取消请求中断被接受，这会将控制传递给&quot;Cancel Order&quot;动作。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interruptible-activity-region.gif"/></div><h3 id="分割"><a class="markdownIt-Anchor" href="#分割"></a> 分割</h3><p>一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 &quot;accounting department&quot;中执行的，有在 &quot;customer&quot;中执行的。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-activity-partitions.gif"/></div><h2 id="状态机图"><a class="markdownIt-Anchor" href="#状态机图"></a> 状态机图</h2><blockquote><p><strong>状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</strong></p></blockquote><p>如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-diagram.gif"/></div><p>门可以处于以下的三种状态之一： &quot;Opened&quot;打开状态， &quot;Closed&quot;关闭状态，或者&quot;Locked&quot;锁定状态。 它分别响应事件：“Open”开门， “Close”关门， “Lock”锁门 和 “Unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorWay-&gt;isEmpty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。</p><h3 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h3><p>状态被表示为圆角矩形，状态名写在里面。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state.gif"/></div><h3 id="起始和结束状态"><a class="markdownIt-Anchor" href="#起始和结束状态"></a> 起始和结束状态</h3><p>初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-initial-and-final.gif"/></div><h3 id="转移"><a class="markdownIt-Anchor" href="#转移"></a> 转移</h3><p>一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“Trigger”触发器，一个“Guard”监护条件和一个“effect”效果。如下所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-transition.gif"/></div><p>&quot;Trigger&quot;触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。&quot;Guard&quot;监护是一个条件，而且必须为真，以便于让触发器引起转移。效果&quot;Effect&quot;是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。</p><h3 id="状态活动"><a class="markdownIt-Anchor" href="#状态活动"></a> 状态活动</h3><p>在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-entry-and-exit.gif"/></div><p>可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。</p><h3 id="自转移"><a class="markdownIt-Anchor" href="#自转移"></a> 自转移</h3><p>一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-self-transition.gif"/></div><h3 id="复合状态"><a class="markdownIt-Anchor" href="#复合状态"></a> 复合状态</h3><p>一个状态机图可以有子状态机图，如下图所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-compound.gif"/></div><p>可选择不同方式显示相同信息，如下图所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-composite.gif"/></div><p>上面版本的标注说明&quot;Check PIN&quot;的子状态机图显示在单独的图中。</p><h3 id="入口点"><a class="markdownIt-Anchor" href="#入口点"></a> 入口点</h3><p>有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从&quot;初始化&quot;状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 “Ready” 状态开始。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-entry-point.gif"/></div><p>下图显示了状态机的上一层。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-entry-point-higher.gif"/></div><h3 id="出口点"><a class="markdownIt-Anchor" href="#出口点"></a> 出口点</h3><p>有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-exit-point.gif"/></div><h3 id="选择伪状态"><a class="markdownIt-Anchor" href="#选择伪状态"></a> 选择伪状态</h3><p>选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-choice.gif"/></div><h3 id="连接伪状态"><a class="markdownIt-Anchor" href="#连接伪状态"></a> 连接伪状态</h3><p>连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-junction.gif"/></div><h3 id="终止伪状态"><a class="markdownIt-Anchor" href="#终止伪状态"></a> 终止伪状态</h3><p>进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-terminate.gif"/></div><h3 id="历史状态"><a class="markdownIt-Anchor" href="#历史状态"></a> 历史状态</h3><p>历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。</p><p>在这个状态机中，当洗衣机运行时，它会按照&quot;Washing&quot; 到 Rinsing&quot;再到&quot;Spinning&quot;来进行。如果电源被切断 ，洗衣机会停止运行并进入&quot;Power Off&quot; 状态。当电源恢复，运行状态在&quot;History State&quot;符号处进入，表示它会从上次离开的地方恢复。</p><h3 id="并发区"><a class="markdownIt-Anchor" href="#并发区"></a> 并发区</h3><p>一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 “Applying Brakes”， “front brake&quot;和&quot;rear brakes” 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-concurrent-regions.gif"/></div><h2 id="用例图"><a class="markdownIt-Anchor" href="#用例图"></a> 用例图</h2><blockquote><p><strong>用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。</strong></p></blockquote><h3 id="执行者"><a class="markdownIt-Anchor" href="#执行者"></a> 执行者</h3><p>用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-actor.gif"/></div><p>在下图中，执行者可以详细的泛化其他执行者:</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-generalize.gif"/></div><h3 id="用例"><a class="markdownIt-Anchor" href="#用例"></a> 用例</h3><p>用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case.gif"/></div><p>使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 &quot;Customer&quot;使用 &quot;Withdraw&quot;用例。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-use.gif"/></div><p>用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-multiplicity-use.gif"/></div><h3 id="用例定义"><a class="markdownIt-Anchor" href="#用例定义"></a> 用例定义</h3><p>一个典型的用例包括:</p><ul><li><strong>名称和描述</strong> - 用例通常用一个动词词组定义，而且有一个简短的文字说明。</li><li><strong>需求</strong> - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。</li><li><strong>约束</strong> - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为&quot;真&quot;。不变化条件说明用例整个执行过程中该条件始终为&quot;真&quot;。</li><li><strong>情形</strong> - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。</li><li><strong>情形图</strong></li><li><strong>附加信息</strong></li></ul><h3 id="包含用例"><a class="markdownIt-Anchor" href="#包含用例"></a> 包含用例</h3><p>用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认”<Card Identification> 在运行时，被用例“取钱”<Withdraw>当作一个子部分。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-include.gif"/></div><p>用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。</p><h3 id="扩展用例"><a class="markdownIt-Anchor" href="#扩展用例"></a> 扩展用例</h3><p>一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”<Get Approval>用例将有选择的扩展常规的“修改订单”<Modify Order>用例。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-extend.gif"/></div><p><strong>扩展点</strong> - 扩展用例的加入点被定义为扩展点。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-extend-with-condition.gif"/></div><p><strong>系统边界</strong> - 它用来显示用例在系统内部，执行者在系统的外部。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-use-case-system-boundary.gif"/></div><h2 id="通信图"><a class="markdownIt-Anchor" href="#通信图"></a> 通信图</h2><blockquote><p>通信图，以前称之为协作图，是一种交互图，<strong>所显示消息与时序图相似，但是它更侧重于对象间的联系</strong>。</p></blockquote><p>在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。</p><p>下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-communications-diagram.gif"/></div><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-diagram.gif"/></div><h2 id="交互概述图"><a class="markdownIt-Anchor" href="#交互概述图"></a> 交互概述图</h2><blockquote><p><strong>一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。</strong></p></blockquote><h3 id="交互发生"><a class="markdownIt-Anchor" href="#交互发生"></a> 交互发生</h3><p>交互发生引用现有的交互图。显示为一个引用框，左上角显示 “ref” 。被引用的图名显示在框的中央。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interaction-overview-01.gif"/></div><h3 id="交互元素"><a class="markdownIt-Anchor" href="#交互元素"></a> 交互元素</h3><p>交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interaction-overview-02.gif"/></div><h3 id="将它们放在一起"><a class="markdownIt-Anchor" href="#将它们放在一起"></a> 将它们放在一起</h3><p>所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-interaction-overview-diagram.gif"/></div><h2 id="时序图"><a class="markdownIt-Anchor" href="#时序图"></a> 时序图</h2><blockquote><p><strong>时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。</strong></p></blockquote><h3 id="生命线"><a class="markdownIt-Anchor" href="#生命线"></a> 生命线</h3><p>一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是&quot;self&quot;，则说明该生命线代表控制带时序图的类元。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-lifelines.gif"/></div><p>有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-more-lifelines.gif"/></div><h3 id="消息"><a class="markdownIt-Anchor" href="#消息"></a> 消息</h3><p>消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-messages.gif"/></div><h3 id="执行发生"><a class="markdownIt-Anchor" href="#执行发生"></a> 执行发生</h3><p>向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。</p><h3 id="内部通信"><a class="markdownIt-Anchor" href="#内部通信"></a> 内部通信</h3><p>内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-recursion.gif"/></div><h3 id="迷路消息和拾取消息"><a class="markdownIt-Anchor" href="#迷路消息和拾取消息"></a> 迷路消息和拾取消息</h3><p>迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-lost-and-found.gif"/></div><h3 id="生命线开始与结束"><a class="markdownIt-Anchor" href="#生命线开始与结束"></a> 生命线开始与结束</h3><p>生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（Child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-lost-and-found.gif"/></div><h3 id="时间和期限约束"><a class="markdownIt-Anchor" href="#时间和期限约束"></a> 时间和期限约束</h3><p>消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-time.gif"/></div><h3 id="复合片段"><a class="markdownIt-Anchor" href="#复合片段"></a> 复合片段</h3><p>如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:</p><ul><li>选择性片段 (显示 “alt”) 为 if…then…else 结构建模。</li><li>选项片段 (显示 “opt”) 为 “switch”(开关) 结构建模。</li><li>中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。</li><li>并行片段(显示 “par”) 为并发处理建模。</li><li>弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。</li><li>严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。</li><li>非片段 (显示 “neg”) 包含了一系列不可用的消息。</li><li>关键片段 具有关键部分。</li><li>忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。</li><li>考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。</li><li>断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。</li><li>循环片段 包含一系列被重复的消息。</li></ul><p>下图显示的是循环片段：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-fragment.gif"/></div><p>这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带&quot;ref&quot;，将被参考图名显示在方框的中间。</p><h3 id="门"><a class="markdownIt-Anchor" href="#门"></a> 门</h3><p>门是连接片段内消息和片段外消息的连接点。 在 EA 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：&quot; top level diagram&quot;中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-top-level-diagram.gif"/></div><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-nested-diagram.gif"/></div><h3 id="部分分解"><a class="markdownIt-Anchor" href="#部分分解"></a> 部分分解</h3><p>一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-part-decomposition.gif"/></div><h3 id="状态常量延续"><a class="markdownIt-Anchor" href="#状态常量延续"></a> 状态常量/延续</h3><p>状态常量是生命线的约束，运行时始终为&quot;真&quot;。显示为两侧半圆的矩形，如下图：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-sequence-state-invariant.gif"/></div><p>延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。</p><h2 id="时间图"><a class="markdownIt-Anchor" href="#时间图"></a> 时间图</h2><blockquote><p><strong>UML 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。</strong></p></blockquote><h3 id="状态生命线"><a class="markdownIt-Anchor" href="#状态生命线"></a> 状态生命线</h3><p>状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，X 轴显示经过的时间，Y 轴被标为给出状态的列表。状态生命线如下所示：</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-state-lifeline.gif"/></div><h3 id="值生命线"><a class="markdownIt-Anchor" href="#值生命线"></a> 值生命线</h3><p>值生命线显示随时间变化，一个单项的值的变化。X 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-value-lifeline.gif"/></div><h3 id="将它们放在一起-2"><a class="markdownIt-Anchor" href="#将它们放在一起-2"></a> 将它们放在一起</h3><p>状态和值的生命线能叠加组合。它们必须有相同的 X 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。</p><div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/uml/uml-timing-diagram.gif"/></div><h2 id="uml-工具"><a class="markdownIt-Anchor" href="#uml-工具"></a> UML 工具</h2><p>UML 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 UML 工具：</p><h3 id="亿图"><a class="markdownIt-Anchor" href="#亿图"></a> 亿图</h3><blockquote><p>国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。</p><p><a href="http://www.edrawsoft.cn/" target="_blank" rel="noopener">亿图官网</a></p></blockquote><div align="center"><img src="http://www.edrawsoft.cn/images/software/createsoftware.png"/></div><h3 id="visio"><a class="markdownIt-Anchor" href="#visio"></a> Visio</h3><blockquote><p>Office 的绘图工具，特点是简单、清晰。</p><p><a href="https://products.office.com/zh-cn/visio/flowchart-software" target="_blank" rel="noopener">Visio 官网</a></p></blockquote><div align="center"><img src="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RE2jMC4?ver=5361&q=90&h=675&w=830&b=%23FFFFFFFF&aim=true"/></div><h3 id="staruml"><a class="markdownIt-Anchor" href="#staruml"></a> StarUML</h3><blockquote><p>样式精美，功能全面的 UML 工具。</p><p><a href="http://staruml.io/" target="_blank" rel="noopener">StarUML 官网</a></p></blockquote><div align="center"><img src="http://staruml.io/image/screenshot_jumbotron.png"/></div><h3 id="astah"><a class="markdownIt-Anchor" href="#astah"></a> Astah</h3><blockquote><p>样式不错，功能全面的绘图工具。</p><p><a href="http://astah.net/" target="_blank" rel="noopener">Astah 官网</a></p></blockquote><div align="center"><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1539757904141&di=7e4f71d0a00ffcd87e0e5aa62f0ed168&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D3525476819%2C2924170461%26fm%3D214%26gp%3D0.jpg"/></div><h3 id="argouml"><a class="markdownIt-Anchor" href="#argouml"></a> ArgoUML</h3><blockquote><p>UML 工具。</p><p><a href="https://argouml.en.softonic.com/?ex=CAT-759.2" target="_blank" rel="noopener">ArgoUML 官网</a></p></blockquote><div align="center"><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f4e8a7c6923df8dcb23087c3ac7819ee/8b13632762d0f70315a83ced05fa513d2697c5ed.jpg"/></div><h3 id="processon"><a class="markdownIt-Anchor" href="#processon"></a> ProcessOn</h3><blockquote><p>在线绘图工具，特点是简洁、清晰。</p><p><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn 官网</a></p></blockquote><h3 id="drawio"><a class="markdownIt-Anchor" href="#drawio"></a> drawio</h3><blockquote><p>开源的在线绘图工具，特点是简洁、清晰。</p><p><a href="https://www.draw.io/" target="_blank" rel="noopener">drawio 官网</a></p></blockquote><h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">Wiki-UML</a></li><li><a href="https://sparxsystems.cn/resources/uml2_tutorial/index.html" target="_blank" rel="noopener">Sparx UML 教程</a></li><li><a href="https://www.omg.org/spec/UML" target="_blank" rel="noopener">OMG UML</a></li><li><a href="https://www.tutorialspoint.com/uml/index.htm" target="_blank" rel="noopener">UML Tutorial</a></li><li><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">W3Cschool UML 教程</a></li><li><a href="https://blog.csdn.net/soft_zzti/article/details/79811923" target="_blank" rel="noopener">UML 学习入门就这一篇文章</a></li><li><a href="http://www.cnblogs.com/ywqu/category/223486.html" target="_blank" rel="noopener">http://www.cnblogs.com/ywqu/category/223486.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;uml-教程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#uml-教程&quot;&gt;&lt;/a&gt; UML 教程&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;关键词：&lt;code&gt;部署图&lt;/code&gt;, &lt;code&gt;组件图&lt;/code&gt;, &lt;code&gt;包
      
    
    </summary>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/categories/design/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/blog/tags/design/"/>
    
      <category term="uml" scheme="https://dunwu.github.io/blog/tags/uml/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之物理层</title>
    <link href="https://dunwu.github.io/blog/communication/network-physical/"/>
    <id>https://dunwu.github.io/blog/communication/network-physical/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-11-21T12:10:33.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong></p><p><strong>物理层（Physical Layer）</strong> - 物理层只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p><ul><li>数据单元：比特流。</li><li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li></ul></blockquote><h2 id="通信系统模型"><a class="markdownIt-Anchor" href="#通信系统模型"></a> 通信系统模型</h2><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/physical/数据通信系统的模型.png!zp"/></div><p>通信系统模型分为三大部分：源系统（包括信源和发送器）、传输系统、目的系统（包括信宿接收器）。</p><p>重要概念：</p><ul><li><strong>信源</strong> - 也叫源点。产生各类信息的实体。</li><li><strong>信道</strong> - 通信的通道，是信号传输的媒介。</li><li><strong>信宿</strong> - 传输信息的归宿。</li><li><strong>码元</strong> - 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。</li></ul><h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/physical/通信方式.jpg!zp"/></div><p>有三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="通信信号"><a class="markdownIt-Anchor" href="#通信信号"></a> 通信信号</h2><p>通信的目的是传送消息。如语音、文字、图像、视频都是消息。数据时传送消息的实体。信号是数据的电气或电磁的表现。</p><p>模拟信号和数字信号</p><ul><li><strong>模拟信号</strong> - 模拟信号是连续的信号。</li><li><strong>数字信号</strong> - 数字信号是离散的信号。</li></ul><h2 id="调制解调"><a class="markdownIt-Anchor" href="#调制解调"></a> 调制解调</h2><p>重要概念：</p><ul><li><strong>基带信号</strong> - 来自信源的信号叫做基带信号。</li><li><strong>调制</strong> - 将各种数字基带信号转换成适于信道传输的数字调制信号(已调信号或频带信号)。简单来说：调制即，数字 -&gt; 模拟。</li><li><strong>解调</strong> - 在接收端将收到的数字频带信号还原成数字基带信号。简单来说：解调即，模拟 -&gt; 数字。</li></ul><blockquote><p>📌 提示：我们上网时所用到的调制解调器（俗称“猫”），指的就是转换数字和模拟信号的机器。</p></blockquote><p>信号要在信道上传输就要经过调制。</p><p>调制分为：基带调制和带通调制</p><h3 id="基本带通调制方法"><a class="markdownIt-Anchor" href="#基本带通调制方法"></a> 基本带通调制方法</h3><div align="center"><img src="http://dunwu.test.upcdn.net/cs/network/physical/基本调制方法.png!zp"/></div><p>如果你收听过广播，一定经常听到 AM、FM 这两个关键词，这是什么意思呢？答案如下：</p><ul><li><strong>调幅（AM）</strong> - 即载波的<strong>振幅</strong>随基带数字信号而变化。</li><li><strong>调频（FM）</strong> - 即载波的<strong>频率</strong>随基带数字信号而变化。</li><li><strong>调相（PM）</strong> - 即载波的<strong>初始相位</strong>随基带数字信号而变化。</li></ul><blockquote><p>📌 提示：我们收听广播时，为了接收不同广播台的信号，就要调整 AM 或 FM，指的就是这里的调制方法。</p></blockquote><h2 id="通信媒介"><a class="markdownIt-Anchor" href="#通信媒介"></a> 通信媒介</h2><p>通信媒介分为两大类：</p><ul><li>导引型 - 双绞线、电缆、光纤</li><li>非导引型 - 无线、红外线、大气、激光</li></ul><h2 id="信道复用"><a class="markdownIt-Anchor" href="#信道复用"></a> 信道复用</h2><p>信道复用就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输一路信号。</p><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理层（Physical Layer）&lt;/strong&gt; - 物理层只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据单元：比特流。&lt;
      
    
    </summary>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
