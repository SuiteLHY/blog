<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&amp;apos;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https:&#x2F;&#x2F;dunwu.github.io&#x2F;blog&#x2F;page&#x2F;6&#x2F;index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&amp;apos;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">71</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/theory/distributed-base-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/theory/distributed-base-theory/" class="post-title-link" itemprop="url">分布式系统基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-09 17:43:00" itemprop="dateCreated datePublished" datetime="2018-07-09T17:43:00+08:00">2018-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 16:33:49" itemprop="dateModified" datetime="2019-11-27T16:33:49+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">系统原理</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/theory/distributed-base-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/theory/distributed-base-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式系统基本原理"><a class="markdownIt-Anchor" href="#分布式系统基本原理"></a> 分布式系统基本原理</h1>
<h2 id="1-分布式术语"><a class="markdownIt-Anchor" href="#1-分布式术语"></a> 1. 分布式术语</h2>
<h3 id="11-异常"><a class="markdownIt-Anchor" href="#11-异常"></a> 1.1. 异常</h3>
<h4 id="111-服务器宕机"><a class="markdownIt-Anchor" href="#111-服务器宕机"></a> 1.1.1. 服务器宕机</h4>
<p>内存错误、服务器停电等都会导致服务器宕机，此时节点无法正常工作，称为不可用。</p>
<p>服务器宕机会导致节点失去所有内存信息，因此需要将内存信息保存到持久化介质上。</p>
<h4 id="112-网络异常"><a class="markdownIt-Anchor" href="#112-网络异常"></a> 1.1.2. 网络异常</h4>
<p>有一种特殊的网络异常称为——<strong>网络分区</strong> ，即集群的所有节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<h4 id="113-磁盘故障"><a class="markdownIt-Anchor" href="#113-磁盘故障"></a> 1.1.3. 磁盘故障</h4>
<p>磁盘故障是一种发生概率很高的异常。</p>
<p>使用冗余机制，将数据存储到多台服务器。</p>
<h3 id="12-超时"><a class="markdownIt-Anchor" href="#12-超时"></a> 1.2. 超时</h3>
<p>在分布式系统中，一个请求除了成功和失败两种状态，还存在着超时状态。</p>
<p>可以将服务器的操作设计为具有 <strong>幂等性</strong> ，即执行多次的结果与执行一次的结果相同。如果使用这种方式，当出现超时的时候，可以不断地重新请求直到成功。</p>
<h3 id="13-衡量指标"><a class="markdownIt-Anchor" href="#13-衡量指标"></a> 1.3. 衡量指标</h3>
<h4 id="131-性能"><a class="markdownIt-Anchor" href="#131-性能"></a> 1.3.1. 性能</h4>
<p>常见的性能指标有：吞吐量、响应时间。</p>
<p>其中，吞吐量指系统在某一段时间可以处理的请求总数，通常为每秒的读操作数或者写操作数；响应时间指从某个请求发出到接收到返回结果消耗的时间。</p>
<p>这两个指标往往是矛盾的，追求高吞吐的系统，往往很难做到低响应时间，解释如下：</p>
<ul>
<li>
<p>在无并发的系统中，吞吐量为响应时间的倒数，例如响应时间为 10 ms，那么吞吐量为 100 req/s，因此高吞吐也就意味着低响应时间。</p>
</li>
<li>
<p>但是在并发的系统中，由于一个请求在调用 I/O 资源的时候，需要进行等待。服务器端一般使用的是异步等待方式，即等待的请求被阻塞之后不需要一直占用 CPU 资源。这种方式能大大提高 CPU 资源的利用率，例如上面的例子中，单个请求在无并发的系统中响应时间为 10 ms，如果在并发的系统中，那么吞吐量将大于 100 req/s。因此为了追求高吞吐量，通常会提高并发程度。但是并发程度的增加，会导致请求的平均响应时间也增加，因为请求不能马上被处理，需要和其它请求一起进行并发处理，响应时间自然就会增高。</p>
</li>
</ul>
<h4 id="132-可用性"><a class="markdownIt-Anchor" href="#132-可用性"></a> 1.3.2. 可用性</h4>
<p>可用性指系统在面对各种异常时可以提供正常服务的能力。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<h4 id="133-一致性"><a class="markdownIt-Anchor" href="#133-一致性"></a> 1.3.3. 一致性</h4>
<p>可以从两个角度理解一致性：从客户端的角度，读写操作是否满足某种特性；从服务器的角度，多个数据副本之间是否一致。</p>
<h4 id="134-可扩展性"><a class="markdownIt-Anchor" href="#134-可扩展性"></a> 1.3.4. 可扩展性</h4>
<p>指系统通过扩展集群服务器规模来提高性能的能力。理想的分布式系统需要实现“线性可扩展”，即随着集群规模的增加，系统的整体性能也会线性增加。</p>
<h2 id="2-数据分布"><a class="markdownIt-Anchor" href="#2-数据分布"></a> 2. 数据分布</h2>
<p>分布式存储系统的数据分布在多个节点中，常用的数据分布方式有哈希分布和顺序分布。</p>
<p>数据库的水平切分（Sharding）也是一种分布式存储方法，下面的数据分布方法同样适用于 Sharding。</p>
<h3 id="21-哈希分布"><a class="markdownIt-Anchor" href="#21-哈希分布"></a> 2.1. 哈希分布</h3>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<p><strong>一致性哈希</strong></p>
<p>Distributed Hash Table（DHT）：对于哈希空间 [0, 2<sup>n</sup>-1]，将该哈希空间看成一个哈希环，将每个节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<p>一致性哈希的优点是在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将数据对象 C 重新存放到节点 X 上即可，对于节点 A、B、D 都没有影响。</p>
<h3 id="22-顺序分布"><a class="markdownIt-Anchor" href="#22-顺序分布"></a> 2.2. 顺序分布</h3>
<p>哈希分布式破坏了数据的有序性，顺序分布则不会。</p>
<p>顺序分布的数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如下图中，User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p>
<p>顺序分布的优点是可以充分利用每个节点的空间，而哈希分布很难控制一个节点存储多少数据。</p>
<p>但是顺序分布需要使用一个映射表来存储数据到节点的映射，这个映射表通常使用单独的节点来存储。当数据量非常大时，映射表也随着变大，那么一个节点就可能无法存放下整个映射表。并且单个节点维护着整个映射表的开销很大，查找速度也会变慢。为了解决以上问题，引入了一个中间层，也就是 Meta 表，从而分担映射表的维护工作。</p>
<h3 id="23-负载均衡"><a class="markdownIt-Anchor" href="#23-负载均衡"></a> 2.3. 负载均衡</h3>
<p>衡量负载的因素很多，如 CPU、内存、磁盘等资源使用情况、读写请求数等。</p>
<p>分布式系统存储应当能够自动负载均衡，当某个节点的负载较高，将它的部分数据迁移到其它节点。</p>
<p>每个集群都有一个总控节点，其它节点为工作节点，由总控节点根据全局负载信息进行整体调度，工作节点定时发送心跳包（Heartbeat）将节点负载相关的信息发送给总控节点。</p>
<p>一个新上线的工作节点，由于其负载较低，如果不加控制，总控节点会将大量数据同时迁移到该节点上，造成该节点一段时间内无法工作。因此负载均衡操作需要平滑进行，新加入的节点需要较长的一段时间来达到比较均衡的状态。</p>
<h2 id="3-分布式理论"><a class="markdownIt-Anchor" href="#3-分布式理论"></a> 3. 分布式理论</h2>
<h3 id="31-cap"><a class="markdownIt-Anchor" href="#31-cap"></a> 3.1. CAP</h3>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式理论-CAP.jpg" width="450"/>
</div>
<h4 id="311-一致性"><a class="markdownIt-Anchor" href="#311-一致性"></a> 3.1.1. 一致性</h4>
<p>一致性指的是多个数据副本是否能保持一致的特性。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<h4 id="312-可用性"><a class="markdownIt-Anchor" href="#312-可用性"></a> 3.1.2. 可用性</h4>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="313-分区容忍性"><a class="markdownIt-Anchor" href="#313-分区容忍性"></a> 3.1.3. 分区容忍性</h4>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h4 id="314-权衡"><a class="markdownIt-Anchor" href="#314-权衡"></a> 3.1.4. 权衡</h4>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="32-base"><a class="markdownIt-Anchor" href="#32-base"></a> 3.2. BASE</h3>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式理论-BASE.png" />
</div>
<h4 id="321-基本可用"><a class="markdownIt-Anchor" href="#321-基本可用"></a> 3.2.1. 基本可用</h4>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h4 id="322-软状态"><a class="markdownIt-Anchor" href="#322-软状态"></a> 3.2.2. 软状态</h4>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。</p>
<h4 id="323-最终一致性"><a class="markdownIt-Anchor" href="#323-最终一致性"></a> 3.2.3. 最终一致性</h4>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="4-分布式事务问题"><a class="markdownIt-Anchor" href="#4-分布式事务问题"></a> 4. 分布式事务问题</h2>
<h3 id="41-两阶段提交2pc"><a class="markdownIt-Anchor" href="#41-两阶段提交2pc"></a> 4.1. 两阶段提交（2PC）</h3>
<p>两阶段提交（Two-phase Commit，2PC）</p>
<p>主要用于实现分布式事务，分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</p>
<p>通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<h4 id="411-运行过程"><a class="markdownIt-Anchor" href="#411-运行过程"></a> 4.1.1. 运行过程</h4>
<h5 id="准备阶段"><a class="markdownIt-Anchor" href="#准备阶段"></a> 准备阶段</h5>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式事务两阶段提交-01.jpg" />
</div>
<h5 id="提交阶段"><a class="markdownIt-Anchor" href="#提交阶段"></a> 提交阶段</h5>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式事务两阶段提交-02.jpg" />
</div>
需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。
<h4 id="412-问题"><a class="markdownIt-Anchor" href="#412-问题"></a> 4.1.2. 问题</h4>
<h5 id="同步阻塞"><a class="markdownIt-Anchor" href="#同步阻塞"></a> 同步阻塞</h5>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p>
<h5 id="单点问题"><a class="markdownIt-Anchor" href="#单点问题"></a> 单点问题</h5>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p>
<h5 id="数据不一致"><a class="markdownIt-Anchor" href="#数据不一致"></a> 数据不一致</h5>
<p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
<h5 id="太过保守"><a class="markdownIt-Anchor" href="#太过保守"></a> 太过保守</h5>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<h4 id="413-pc-优缺点"><a class="markdownIt-Anchor" href="#413-pc-优缺点"></a> 4.1.3. PC 优缺点</h4>
<p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致）<br />
缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p>
<h3 id="42-补偿事务tcc"><a class="markdownIt-Anchor" href="#42-补偿事务tcc"></a> 4.2. 补偿事务（TCC）</h3>
<p>补偿事务（TCC）其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ol>
<li>Try 阶段主要是对业务系统做检测及资源预留。</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ol>
<p>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p>
<ol>
<li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li>
<li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li>
<li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li>
</ol>
<h4 id="421-tcc-优缺点"><a class="markdownIt-Anchor" href="#421-tcc-优缺点"></a> 4.2.1. TCC 优缺点</h4>
<ul>
<li>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</li>
<li>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li>
</ul>
<h3 id="43-本地消息表异步确保"><a class="markdownIt-Anchor" href="#43-本地消息表异步确保"></a> 4.3. 本地消息表（异步确保）</h3>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式事务本地消息.jpg" />
</div>
<p>这种方案遵循 BASE 理论，采用的是最终一致性。</p>
<p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p>
<h4 id="431-本地消息表优缺点"><a class="markdownIt-Anchor" href="#431-本地消息表优缺点"></a> 4.3.1. 本地消息表优缺点</h4>
<ul>
<li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li>
<li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li>
</ul>
<h3 id="44-mq-事务消息"><a class="markdownIt-Anchor" href="#44-mq-事务消息"></a> 4.4. MQ 事务消息</h3>
<p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p>
<ol>
<li>Prepared 消息，会拿到消息的地址。</li>
<li>执行本地事务。</li>
<li>通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ol>
<p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<h4 id="441-mq-事务消息优缺点"><a class="markdownIt-Anchor" href="#441-mq-事务消息优缺点"></a> 4.4.1. MQ 事务消息优缺点</h4>
<ul>
<li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li>
<li>缺点：实现难度大，主流 MQ 不支持。</li>
</ul>
<h2 id="5-共识性问题"><a class="markdownIt-Anchor" href="#5-共识性问题"></a> 5. 共识性问题</h2>
<h3 id="51-paxos"><a class="markdownIt-Anchor" href="#51-paxos"></a> 5.1. Paxos</h3>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<p>算法需要满足 safety 和 liveness 两方面的约束要求（实际上这两个基础属性是大部分分布式算法都该考虑的）：</p>
<ul>
<li>safety：保证决议结果是对的，无歧义的，不会出现错误情况。
<ul>
<li>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；</li>
<li>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；</li>
</ul>
</li>
<li>liveness：保证决议过程能在有限时间内完成。
<ul>
<li>决议总会产生，并且 learners 能获得被批准（chosen）的决议。</li>
</ul>
</li>
</ul>
<p>基本过程包括 proposer 提出提案，先争取大多数 acceptor 的支持，超过一半支持时，则发送结案结果给所有人进行确认。一个潜在的问题是 proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新的一轮提案的 proposer 都恰好故障，系统则永远无法达成一致（概率很小）。</p>
<p>Paxos 能保证在超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 的正常节点存在时，系统能达成共识。</p>
<h4 id="511-单个提案者多接收者"><a class="markdownIt-Anchor" href="#511-单个提案者多接收者"></a> 5.1.1. 单个提案者+多接收者</h4>
<p>如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接收者的投票，即可认为通过，因为系统中不存在其他的提案。</p>
<p>但一旦提案者故障，则系统无法工作。</p>
<h4 id="512-多个提案者单个接收者"><a class="markdownIt-Anchor" href="#512-多个提案者单个接收者"></a> 5.1.2. 多个提案者+单个接收者</h4>
<p>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。</p>
<p>缺陷也是容易发生单点故障，包括接收者故障或首个提案者节点故障。</p>
<p>以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。</p>
<p>当提案者和接收者都推广到多个的情形，会出现一些挑战。</p>
<h4 id="513-多个提案者多个接收者"><a class="markdownIt-Anchor" href="#513-多个提案者多个接收者"></a> 5.1.3. 多个提案者+多个接收者</h4>
<p>既然限定单提案者或单接收者都会出现故障，那么就得允许出现多个提案者和多个接收者。问题一下子变得复杂了。</p>
<p>一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个数字来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。</p>
<p>另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。</p>
<p>如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。</p>
<p>此外，提案者即便收到了多数接收者的投票，也不敢说就一定通过。因为在此过程中系统可能还有其它的提案。</p>
<h3 id="52-raft"><a class="markdownIt-Anchor" href="#52-raft"></a> 5.2. Raft</h3>
<p>Raft 算法是 Paxos 算法的一种简化实现。</p>
<p>包括三种角色：leader、candidate 和 follower，其基本过程为：</p>
<ul>
<li><strong>Leader 选举</strong> - 每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；</li>
<li><strong>同步 log</strong> - leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；</li>
</ul>
<p><em>注：此处 log 并非是指日志消息，而是各种事件的发生记录。</em></p>
<h4 id="521-单个-candidate-的竞选"><a class="markdownIt-Anchor" href="#521-单个-candidate-的竞选"></a> 5.2.1. 单个 Candidate 的竞选</h4>
<p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-01.gif" />
</div>
<ul>
<li>此时 A 发送投票请求给其它所有节点。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-02.gif" />
</div>
<ul>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-03.gif" />
</div>
<ul>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-04.gif" />
</div>
<h4 id="522-多个-candidate-竞选"><a class="markdownIt-Anchor" href="#522-多个-candidate-竞选"></a> 5.2.2. 多个 Candidate 竞选</h4>
<ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-multi-candidate-01.gif" />
</div>
<ul>
<li>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-multi-candidate-02.gif" />
</div>
<h4 id="523-同步日志"><a class="markdownIt-Anchor" href="#523-同步日志"></a> 5.2.3. 同步日志</h4>
<ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-01.gif" />
</div>
<ul>
<li>Leader 会把修改复制到所有 Follower。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-02.gif" />
</div>
<ul>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-03.gif" />
</div>
<ul>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-04.gif" />
</div>
<h2 id="6-分布式缓存问题"><a class="markdownIt-Anchor" href="#6-分布式缓存问题"></a> 6. 分布式缓存问题</h2>
<h3 id="61-缓存雪崩"><a class="markdownIt-Anchor" href="#61-缓存雪崩"></a> 6.1. 缓存雪崩</h3>
<p>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>解决方案：</p>
<ul>
<li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。</li>
<li>还有一个简单的方案，就是将缓存失效时间分散开，不要所有缓存时间长度都设置成 5 分钟或者 10 分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
</ul>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<h3 id="62-缓存穿透"><a class="markdownIt-Anchor" href="#62-缓存穿透"></a> 6.2. 缓存穿透</h3>
<p>缓存穿透是指：用户查询的数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p>
<p>解决方案：</p>
<ol>
<li>在封装的缓存 SET 和 GET 部分增加个步骤，如果查询一个 KEY 不存在，就以这个 KEY 为前缀设定一个标识 KEY；以后再查询该 KEY 的时候，先查询标识 KEY，如果标识 KEY 存在，就返回一个协定好的非 false 或者 NULL 值，然后 APP 做相应的处理，这样缓存层就不会被穿透。当然这个验证 KEY 的失效时间不能太长。</li>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h3 id="63-缓存预热"><a class="markdownIt-Anchor" href="#63-缓存预热"></a> 6.3. 缓存预热</h3>
<p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="64-缓存更新"><a class="markdownIt-Anchor" href="#64-缓存更新"></a> 6.4. 缓存更新</h3>
<p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="65-缓存降级"><a class="markdownIt-Anchor" href="#65-缓存降级"></a> 6.5. 缓存降级</h3>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li>杨传辉. 大规模分布式存储系统: 原理解析与架构实战[M]. 机械工业出版社, 2013.</li>
<li><a href="https://www.gitbook.com/book/yeasy/blockchain_guide/details" target="_blank" rel="noopener">区块链技术指南</a></li>
<li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener">NEAT ALGORITHMS - PAXOS</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">分布式技术实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">2018-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 15:27:02" itemprop="dateModified" datetime="2019-11-27T15:27:02+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/分布式技术实现/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式技术实现"><a class="markdownIt-Anchor" href="#分布式技术实现"></a> 分布式技术实现</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">1. 分布式事务</a></li>
<li><a href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">2. 分布式锁</a>
<ul>
<li><a href="#21-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">2.1. 基于数据库实现分布式锁</a></li>
<li><a href="#22-%E5%9F%BA%E4%BA%8E-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">2.2. 基于 Redis 实现分布式锁</a></li>
<li><a href="#23-%E5%9F%BA%E4%BA%8E-zookeeper-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">2.3. 基于 ZooKeeper 实现分布式锁</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F-session">3. 分布式 Session</a>
<ul>
<li><a href="#31-sticky-sessions">3.1. Sticky Sessions</a></li>
<li><a href="#32-session-replication">3.2. Session Replication</a></li>
<li><a href="#33-session-server">3.3. Session Server</a></li>
</ul>
</li>
<li><a href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8">4. 分布式存储</a></li>
<li><a href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">5. 分布式缓存</a></li>
<li><a href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">6. 分布式计算</a></li>
<li><a href="#7-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">7. 负载均衡</a>
<ul>
<li><a href="#71-%E7%AE%97%E6%B3%95">7.1. 算法</a></li>
<li><a href="#72-%E5%AE%9E%E7%8E%B0">7.2. 实现</a></li>
</ul>
</li>
<li><a href="#8-%E8%B5%84%E6%96%99">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-分布式事务"><a class="markdownIt-Anchor" href="#1-分布式事务"></a> 1. 分布式事务</h2>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">分布式原理#4-分布式事务问题</a></p>
</blockquote>
<h2 id="2-分布式锁"><a class="markdownIt-Anchor" href="#2-分布式锁"></a> 2. 分布式锁</h2>
<p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<h3 id="21-基于数据库实现分布式锁"><a class="markdownIt-Anchor" href="#21-基于数据库实现分布式锁"></a> 2.1. 基于数据库实现分布式锁</h3>
<h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4>
<h5 id="1-创建表"><a class="markdownIt-Anchor" href="#1-创建表"></a> 1. 创建表</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-获取锁"><a class="markdownIt-Anchor" href="#2-获取锁"></a> 2. 获取锁</h5>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<h5 id="3-释放锁"><a class="markdownIt-Anchor" href="#3-释放锁"></a> 3. 释放锁</h5>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4>
<ol>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<h4 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h4>
<ol>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ol>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4>
<ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h3 id="22-基于-redis-实现分布式锁"><a class="markdownIt-Anchor" href="#22-基于-redis-实现分布式锁"></a> 2.2. 基于 Redis 实现分布式锁</h3>
<p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h4 id="redis-命令"><a class="markdownIt-Anchor" href="#redis-命令"></a> Redis 命令</h4>
<ul>
<li>setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li>expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li>delete - delete key：删除 key</li>
</ul>
<h4 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h4>
<p>单点实现步骤：</p>
<ol>
<li>获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="问题-2"><a class="markdownIt-Anchor" href="#问题-2"></a> 问题</h4>
<ul>
<li>单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。</li>
<li>如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况</li>
</ul>
<h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4>
<p>可以考虑使用 <a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">redisson 的解决方案</a>。</p>
<h3 id="23-基于-zookeeper-实现分布式锁"><a class="markdownIt-Anchor" href="#23-基于-zookeeper-实现分布式锁"></a> 2.3. 基于 ZooKeeper 实现分布式锁</h3>
<h4 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h4>
<p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h4>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="3-分布式-session"><a class="markdownIt-Anchor" href="#3-分布式-session"></a> 3. 分布式 Session</h2>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于 cache DB 缓存的 session 共享</li>
</ol>
<h3 id="31-sticky-sessions"><a class="markdownIt-Anchor" href="#31-sticky-sessions"></a> 3.1. Sticky Sessions</h3>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/MultiNode-StickySessions.jpg" />
</div>
<h3 id="32-session-replication"><a class="markdownIt-Anchor" href="#32-session-replication"></a> 3.2. Session Replication</h3>
<p>在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/MultiNode-SessionReplication.jpg" />
</div>
<h3 id="33-session-server"><a class="markdownIt-Anchor" href="#33-session-server"></a> 3.3. Session Server</h3>
<p>使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/MultiNode-SpringSession.jpg" />
</div>
<h2 id="4-分布式存储"><a class="markdownIt-Anchor" href="#4-分布式存储"></a> 4. 分布式存储</h2>
<p>通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">分布式原理.md#2-数据分布</a></p>
</blockquote>
<h2 id="5-分布式缓存"><a class="markdownIt-Anchor" href="#5-分布式缓存"></a> 5. 分布式缓存</h2>
<p>使用缓存的好处：</p>
<ul>
<li>提升数据读取速度</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>应用内缓存：如：EHCache</li>
<li>分布式缓存：如：Memached、Redis</li>
</ul>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#6-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">分布式原理.md#6-分布式缓存问题</a></p>
</blockquote>
<h2 id="6-分布式计算"><a class="markdownIt-Anchor" href="#6-分布式计算"></a> 6. 分布式计算</h2>
<h2 id="7-负载均衡"><a class="markdownIt-Anchor" href="#7-负载均衡"></a> 7. 负载均衡</h2>
<h3 id="71-算法"><a class="markdownIt-Anchor" href="#71-算法"></a> 7.1. 算法</h3>
<h4 id="轮询round-robin"><a class="markdownIt-Anchor" href="#轮询round-robin"></a> 轮询（Round Robin）</h4>
<p>轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之轮询-01.jpg" width="640"/>
</div>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之轮询-02.jpg" width="640"/>
</div>
<h4 id="加权轮询weighted-round-robbin"><a class="markdownIt-Anchor" href="#加权轮询weighted-round-robbin"></a> 加权轮询（Weighted Round Robbin）</h4>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之加权轮询.jpg" width="640"/>
</div>
<h4 id="最少连接least-connections"><a class="markdownIt-Anchor" href="#最少连接least-connections"></a> 最少连接（least Connections）</h4>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之最少连接-01.jpg" width="640"/>
</div>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之最少连接-02.jpg" width="640"/>
</div>
<h4 id="加权最少连接weighted-least-connection"><a class="markdownIt-Anchor" href="#加权最少连接weighted-least-connection"></a> 加权最少连接（Weighted Least Connection）</h4>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之加权最少连接.jpg" width="640"/>
</div>
<h4 id="随机算法random"><a class="markdownIt-Anchor" href="#随机算法random"></a> 随机算法（Random）</h4>
<p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之随机.jpg" width="640"/>
</div>
<h4 id="源地址哈希法-ip-hash"><a class="markdownIt-Anchor" href="#源地址哈希法-ip-hash"></a> 源地址哈希法 (IP Hash)</h4>
<p>源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。</p>
<ul>
<li>优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。</li>
<li>缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/负载均衡算法之IpHash.jpg" width="640"/>
</div>
<h3 id="72-实现"><a class="markdownIt-Anchor" href="#72-实现"></a> 7.2. 实现</h3>
<h4 id="http-重定向"><a class="markdownIt-Anchor" href="#http-重定向"></a> HTTP 重定向</h4>
<p>HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/Http重定向.png" width="640"/>
</div>
<h4 id="dns-重定向"><a class="markdownIt-Anchor" href="#dns-重定向"></a> DNS 重定向</h4>
<p>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>缺点：</p>
<ul>
<li>DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/Dns重定向.png" width="640"/>
</div>
<h4 id="修改-mac-地址"><a class="markdownIt-Anchor" href="#修改-mac-地址"></a> 修改 MAC 地址</h4>
<p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/修改Mac地址.png" width="640"/>
</div>
<h4 id="修改-ip-地址"><a class="markdownIt-Anchor" href="#修改-ip-地址"></a> 修改 IP 地址</h4>
<p>在网络层修改请求的目的 IP 地址。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/修改IP地址.png" width="640"/>
</div>
<h4 id="代理自动配置"><a class="markdownIt-Anchor" href="#代理自动配置"></a> 代理自动配置</h4>
<p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>PAC 服务器是用来判断一个请求是否要经过代理。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/代理自动配置.jpg" width="640"/>
</div>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/分布式问题分析.md</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></li>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">https://juejin.im/post/5a20cd8bf265da43163cdd9a</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器</a></li>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">https://github.com/L316476844/distributed-session</a></li>
<li><a href="https://juejin.im/entry/57e39e320e3dd90058021bff" target="_blank" rel="noopener">分布式缓存架构基础</a></li>
<li><a href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&amp;utm_campaign=client_share&amp;from=singlemessage&amp;timestamp=1521281305&amp;app=news_article&amp;utm_source=weixin&amp;iid=28128279343&amp;utm_medium=toutiao_android&amp;weixin_list=1&amp;wxshare_count=2&amp;pbid=6517746516513195523" target="_blank" rel="noopener">阿里 P8 技术专家细究分布式缓存问题</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/theory/load-balance-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/theory/load-balance-theory/" class="post-title-link" itemprop="url">负载均衡基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:50:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:50:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 15:58:45" itemprop="dateModified" datetime="2019-11-27T15:58:45+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">系统原理</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/theory/load-balance-theory/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/theory/load-balance-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="负载均衡基本原理"><a class="markdownIt-Anchor" href="#负载均衡基本原理"></a> 负载均衡基本原理</h1>
<h2 id="1-负载均衡简介"><a class="markdownIt-Anchor" href="#1-负载均衡简介"></a> 1. 负载均衡简介</h2>
<p>系统的扩展可分为垂直扩展和水平扩展。</p>
<ul>
<li>垂直扩展，是从单机的角度通过增加硬件处理能力，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升。这种方式不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。</li>
<li>水平扩展，是通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。
<ul>
<li>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</li>
<li>负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</li>
</ul>
</li>
</ul>
<p>负载均衡的作用（解决的问题）：</p>
<ul>
<li>解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；</li>
<li>提供故障转移，实现高可用；</li>
<li>通过添加或减少服务器数量，提供网站伸缩性（扩展性）；</li>
<li>安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）</li>
</ul>
<h2 id="2-负载均衡分类"><a class="markdownIt-Anchor" href="#2-负载均衡分类"></a> 2. 负载均衡分类</h2>
<p>根据实现技术不同，可分为反向代理、HTTP 重定向、DNS 重定向、修改 IP 地址、修改 MAC 地址等。</p>
<h3 id="21-反向代理"><a class="markdownIt-Anchor" href="#21-反向代理"></a> 2.1. 反向代理</h3>
<blockquote>
<p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>反向代理的作用是保护网站安全，所有互联网的请求都必须经过代理服务器，相当于在 web 服务器和可能的网络攻击之间建立了一个屏障。</p>
<p>优点：部署简单</p>
<p>缺点：可能成为系统瓶颈</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/代理自动配置.jpg!zp" width="640"/>
</div>
<h3 id="22-http-重定向"><a class="markdownIt-Anchor" href="#22-http-重定向"></a> 2.2. HTTP 重定向</h3>
<blockquote>
<p>HTTP 重定向服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/Http重定向.png!zp" width="640"/>
</div>
<h3 id="23-dns-重定向"><a class="markdownIt-Anchor" href="#23-dns-重定向"></a> 2.3. DNS 重定向</h3>
<blockquote>
<p><strong>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。</strong></p>
<p>大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>优点：</p>
<ul>
<li>使用简单：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li>提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能；</li>
</ul>
<p>缺点：</p>
<ul>
<li>可用性差：DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li>扩展性低：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li>维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ul>
<p>建议：</p>
<ul>
<li>将 DNS 作为第一级负载均衡，A 记录对应着内部负载均衡的 IP 地址，通过内部负载均衡将请求分发到真实的 Web 服务器上。一般用于互联网公司，复杂的业务系统不合适使用。</li>
</ul>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/Dns重定向.png!zp" width="640"/>
</div>
<h3 id="24-修改-ip-地址"><a class="markdownIt-Anchor" href="#24-修改-ip-地址"></a> 2.4. 修改 IP 地址</h3>
<blockquote>
<p><strong>在网络层修改请求的目的 IP 地址来进行负载均衡。</strong></p>
<p>用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然后将请求目的地址修改为，获得的真实 ip 地址，不需要经过用户进程处理。真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器，再将数据包源地址修改为自身的 ip 地址，发送给用户浏览器。</p>
<p>IP 负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式：</p>
<ol>
<li>负载均衡服务器在修改目的 ip 地址的同时修改源地址。将数据包源地址设为自身盘，即<a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">网络地址转换（NAT）</a>。</li>
<li>将负载均衡服务器同时作为真实物理服务器集群的网关服务器。</li>
</ol>
<p>优点：在内核进程完成数据分发，比在应用层分发性能更好；</p>
<p>缺点：所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽；</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/修改IP地址.png!zp" width="640"/>
</div>
<h3 id="25-修改-mac-地址"><a class="markdownIt-Anchor" href="#25-修改-mac-地址"></a> 2.5. 修改 MAC 地址</h3>
<blockquote>
<p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<p>实际处理服务器 ip 和数据请求目的 ip 一致，不需要经过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。也称为直接路由模式（DR 模式）。</p>
<p>优点：性能好；</p>
<p>缺点：配置复杂；</p>
<p>建议：DR 模式是目前使用最广泛的一种负载均衡方式。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/修改Mac地址.png!zp" width="640"/>
</div>
<h3 id="26-混合负载均衡"><a class="markdownIt-Anchor" href="#26-混合负载均衡"></a> 2.6. 混合负载均衡</h3>
<p>由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。</p>
<p>此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。</p>
<p>方式一，如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200106747-94797427.png"/></div>
<p>以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。</p>
<p>方式二，如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200117825-1452672107.png"/></div>
<p>以上模式，适合动态请求场景。</p>
<p>因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。</p>
<h2 id="3-负载均衡算法"><a class="markdownIt-Anchor" href="#3-负载均衡算法"></a> 3. 负载均衡算法</h2>
<p>常用的负载均衡算法有：轮询、随机、最少连接、源地址散列、加权等方式。</p>
<h3 id="31-轮询"><a class="markdownIt-Anchor" href="#31-轮询"></a> 3.1. 轮询</h3>
<blockquote>
<p>轮询（Round Robin）算法将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。</p>
<ul>
<li>优点：服务器请求数目相同；</li>
<li>缺点：服务器压力不一样，不适合服务器配置不同的情况；</li>
</ul>
</blockquote>
<p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之轮询-01.jpg!zp" width="640"/>
</div>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之轮询-02.jpg!zp" width="640"/>
</div>
<p>算法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer pos = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roundRobin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet());</span><br><span class="line">    String server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; keyList.size()) &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        server = keyList.get(pos);</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(server);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="311-加权轮询"><a class="markdownIt-Anchor" href="#311-加权轮询"></a> 3.1.1. 加权轮询</h4>
<blockquote>
<p>加权轮询（Weighted Round Robbin）算法在轮询算法的基础上，通过加权的方式，进行负载服务器分配。</p>
<ul>
<li>优点：根据权重，调节转发服务器的请求数目；</li>
<li>缺点：使用相对复杂；</li>
</ul>
</blockquote>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之加权轮询.jpg!zp" width="640"/>
</div>
<p>算法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weightRoundRobin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    List&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;String&gt; it = keySet.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        String server = it.next();</span><br><span class="line">        <span class="keyword">int</span> weithgt = serverMap.get(server);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weithgt; i++) &#123;</span><br><span class="line">            servers.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; keySet.size()) &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        server = servers.get(pos);</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(server);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-最少连接"><a class="markdownIt-Anchor" href="#32-最少连接"></a> 3.2. 最少连接</h3>
<blockquote>
<p>最少连接（Least Busy）算法将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。</p>
<ul>
<li>优点：根据服务器当前的请求处理情况，动态分配；</li>
<li>缺点：算法实现相对复杂，需要监控服务器请求连接数；</li>
</ul>
</blockquote>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之最少连接-01.jpg!zp" width="640"/>
</div>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之最少连接-02.jpg!zp" width="640"/>
</div>
<h4 id="321-加权最少连接"><a class="markdownIt-Anchor" href="#321-加权最少连接"></a> 3.2.1. 加权最少连接</h4>
<blockquote>
<p>加权最少连接（Weighted Least Connection）在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之加权最少连接.jpg!zp" width="640"/>
</div>
### 3.3. 随机
<blockquote>
<p>随机（Random）算法将请求随机分配到各个服务器。</p>
<ul>
<li>优点：使用简单；</li>
<li>缺点：不适合机器配置不同的场景；</li>
</ul>
</blockquote>
<p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之随机.jpg!zp" width="640"/>
</div>
<h3 id="34-哈希hash"><a class="markdownIt-Anchor" href="#34-哈希hash"></a> 3.4. 哈希（Hash）</h3>
<h4 id="341-普通-hash"><a class="markdownIt-Anchor" href="#341-普通-hash"></a> 3.4.1. 普通 Hash</h4>
<blockquote>
<p>根据 IP 地址进行 Hash 计算，得到 IP 地址。</p>
<ul>
<li>优点：将来自同一 IP 地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。</li>
<li>缺点：目标服务器宕机后，会话会丢失；</li>
</ul>
</blockquote>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/负载均衡算法之IpHash.jpg!zp" width="640"/>
</div>
<p>算法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet());</span><br><span class="line">    String remoteIp = <span class="string">"192.168.2.215"</span>;</span><br><span class="line">    <span class="keyword">int</span> hashCode = remoteIp.hashCode();</span><br><span class="line">    <span class="keyword">int</span> idx = hashCode % keyList.size();</span><br><span class="line">    String server = keyList.get(Math.abs(idx));</span><br><span class="line">    System.out.println(server);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="342-一致性哈希"><a class="markdownIt-Anchor" href="#342-一致性哈希"></a> 3.4.2. 一致性哈希</h4>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
<h2 id="4-硬件负载均衡"><a class="markdownIt-Anchor" href="#4-硬件负载均衡"></a> 4. 硬件负载均衡</h2>
<p>采用硬件的方式实现负载均衡，一般是单独的负载均衡服务器，价格昂贵，一般土豪级公司可以考虑，业界领先的有两款，F5 和 A10。</p>
<ul>
<li>使用硬件负载均衡，主要考虑一下几个方面：</li>
<li>功能考虑：功能全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡；</li>
<li>性能考虑：一般软件负载均衡支持到 5 万级并发已经很困难了，硬件负载均衡可以支持</li>
<li>稳定性：商用硬件负载均衡，经过了良好的严格的测试，从经过大规模使用，在稳定性方面高；</li>
<li>安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙，防 DDOS 攻击等安全功能；</li>
<li>维护角度：提供良好的维护管理界面，售后服务和技术支持；</li>
<li>土豪公司：F5 Big Ip 价格：15w~55w 不等；A10 价格：55w-100w 不等；</li>
</ul>
<p>缺点</p>
<ul>
<li>价格昂贵；</li>
<li>扩展能力差；</li>
</ul>
<p>小结</p>
<ul>
<li>一般硬件的负载均衡也要做双机高可用，因此成本会比较高。</li>
<li>互联网公司一般使用开源软件，因此大部分应用采用软件负载均衡；部分采用硬件负载均衡。</li>
</ul>
<p>比如某互联网公司，目前是使用几台 F5 做全局负载均衡，内部使用 Nginx 等软件负载均衡。</p>
<h2 id="5-ngnix-负载均衡"><a class="markdownIt-Anchor" href="#5-ngnix-负载均衡"></a> 5. Ngnix 负载均衡</h2>
<p>Ngnix 是一款轻量级的 Web 服务器/反向代理服务器，工作在七层 Http 协议的负载均衡系统。具有高性能、高并发、低内存使用等特点。是一个轻量级的 Http 和反向代理服务器。Nginx 使用 epoll and kqueue 作为开发模型。能够支持高达 50,000 个并发连接数的响应。</p>
<p>操作系统：Liunx，Windows（Linux、FreeBSD、Solaris、Mac OS X、AIX 以及 Microsoft Windows）</p>
<p>开发语言：C</p>
<p>并发性能：官方支持每秒 5 万并发，实际国内一般到每秒 2 万并发，有优化到每秒 10 万并发的。具体性能看应用场景。</p>
<h3 id="51-ngnix-特点"><a class="markdownIt-Anchor" href="#51-ngnix-特点"></a> 5.1. Ngnix 特点</h3>
<ul>
<li>模块化设计：良好的扩展性，可以通过模块方式进行功能扩展。</li>
<li>高可靠性：主控进程和 worker 是同步实现的，一个 worker 出现问题，会立刻启动另一个 worker。</li>
<li>内存消耗低：一万个长连接（keep-alive）,仅消耗 2.5MB 内存。</li>
<li>支持热部署：不用停止服务器，实现更新配置文件，更换日志文件、更新服务器程序版本。</li>
<li>并发能力强：官方数据每秒支持 5 万并发；</li>
<li>功能丰富：优秀的反向代理功能和灵活的负载均衡策略</li>
</ul>
<h3 id="52-ngnix-功能"><a class="markdownIt-Anchor" href="#52-ngnix-功能"></a> 5.2. Ngnix 功能</h3>
<h4 id="521-基本功能"><a class="markdownIt-Anchor" href="#521-基本功能"></a> 5.2.1. 基本功能</h4>
<ul>
<li>支持静态资源的 web 服务器。</li>
<li>http,smtp,pop3 协议的反向代理服务器、缓存、负载均衡；</li>
<li>支持 FASTCGI（fpm）</li>
<li>支持模块化，过滤器（让文本可以实现压缩，节约带宽）,ssl 及图像大小调整。</li>
<li>内置的健康检查功能</li>
<li>基于名称和 ip 的虚拟主机</li>
<li>定制访问日志</li>
<li>支持平滑升级</li>
<li>支持 KEEPALIVE</li>
<li>支持 url rewrite</li>
<li>支持路径别名</li>
<li>支持基于 IP 和用户名的访问控制。</li>
<li>支持传输速率限制，支持并发数限制。</li>
</ul>
<h4 id="522-扩展功能"><a class="markdownIt-Anchor" href="#522-扩展功能"></a> 5.2.2. 扩展功能</h4>
<h4 id="523-性能"><a class="markdownIt-Anchor" href="#523-性能"></a> 5.2.3. 性能</h4>
<p>Nginx 的高并发，官方测试支持 5 万并发连接。实际生产环境能到 2-3 万并发连接数。10000 个非活跃的 HTTP keep-alive 连接仅占用约 2.5MB 内存。三万并发连接下，10 个 Nginx 进程，消耗内存 150M。淘宝 tengine 团队测试结果是“24G 内存机器上，处理并发请求可达 200 万”。</p>
<h3 id="53-ngnix-架构"><a class="markdownIt-Anchor" href="#53-ngnix-架构"></a> 5.3. Ngnix 架构</h3>
<h4 id="531-nginx-的基本工作模式"><a class="markdownIt-Anchor" href="#531-nginx-的基本工作模式"></a> 5.3.1. Nginx 的基本工作模式</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227195943640-864372763.jpg"/></div>
<p>一个 master 进程，生成一个或者多个 worker 进程。但是这里 master 是使用 root 身份启动的，因为 nginx 要工作在 80 端口。而只有管理员才有权限启动小于低于 1023 的端口。master 主要是负责的作用只是启动 worker，加载配置文件，负责系统的平滑升级。其它的工作是交给 worker。那么当 worker 被启动之后，也只是负责一些 web 最简单的工作，而其他的工作都是有 worker 中调用的模块来实现的。</p>
<p>模块之间是以流水线的方式实现功能的。流水线，指的是一个用户请求，由多个模块组合各自的功能依次实现完成的。比如：第一个模块只负责分析请求首部，第二个模块只负责查找数据，第三个模块只负责压缩数据，依次完成各自工作。来实现整个工作的完成。</p>
<p>他们是如何实现热部署的呢？其实是这样的，我们前面说 master 不负责具体的工作，而是调用 worker 工作，他只是负责读取配置文件，因此当一个模块修改或者配置文件发生变化，是由 master 进行读取，因此此时不会影响到 worker 工作。在 master 进行读取配置文件之后，不会立即的把修改的配置文件告知 worker。而是让被修改的 worker 继续使用老的配置文件工作，当 worker 工作完毕之后，直接当掉这个子进程，更换新的子进程，使用新的规则。</p>
<h4 id="532-nginx-支持的-sendfile-机制"><a class="markdownIt-Anchor" href="#532-nginx-支持的-sendfile-机制"></a> 5.3.2. Nginx 支持的 sendfile 机制</h4>
<p>Sendfile 机制，用户将请求发给内核，内核根据用户的请求调用相应用户进程，进程在处理时需要资源。此时再把请求发给内核（进程没有直接 IO 的能力），由内核加载数据。内核查找到数据之后，会把数据复制给用户进程，由用户进程对数据进行封装，之后交给内核，内核在进行 tcp/ip 首部的封装，最后再发给客户端。这个功能用户进程只是发生了一个封装报文的过程，却要绕一大圈。因此 nginx 引入了 sendfile 机制，使得内核在接受到数据之后，不再依靠用户进程给予封装，而是自己查找自己封装，减少了一个很长一段时间的浪费，这是一个提升性能的核心点。</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227195957171-1801771404.jpg"/></div>
<p>以上内容摘自网友发布的文章，简单一句话是资源的处理，直接通过内核层进行数据传递，避免了数据传递到应用层，应用层再传递到内核层的开销。</p>
<p>目前高并发的处理，一般都采用 sendfile 模式。通过直接操作内核层数据，减少应用与内核层数据传递。</p>
<h4 id="533-nginx-通信模型io-复用机制"><a class="markdownIt-Anchor" href="#533-nginx-通信模型io-复用机制"></a> 5.3.3. Nginx 通信模型（I/O 复用机制）</h4>
<p>开发模型：epoll 和 kqueue。</p>
<p>支持的事件机制：kqueue、epoll、rt signals、/dev/poll 、event ports、select 以及 poll。</p>
<p>支持的 kqueue 特性包括 EV_CLEAR、EV_DISABLE、NOTE_LOWAT、EV_EOF，可用数据的数量，错误代码.</p>
<p>支持 sendfile、sendfile64 和 sendfilev;文件 AIO；DIRECTIO;支持 Accept-filters 和 TCP_DEFER_ACCEP.</p>
<p>以上概念较多，大家自行百度或谷歌，知识领域是网络通信（BIO,NIO,AIO）和多线程方面的知识。</p>
<h3 id="54-ngnix-均衡策略"><a class="markdownIt-Anchor" href="#54-ngnix-均衡策略"></a> 5.4. Ngnix 均衡策略</h3>
<p>nginx 的负载均衡策略可以划分为两大类：内置策略和扩展策略。内置策略包含加权轮询和 ip hash，在默认情况下这两种策略会编译进 nginx 内核，只需在 nginx 配置中指明参数即可。扩展策略有很多，如 fair、通用 hash、consistent hash 等，默认不编译进 nginx 内核。由于在 nginx 版本升级中负载均衡的代码没有本质性的变化，因此下面将以 nginx1.0.15 稳定版为例，从源码角度分析各个策略。</p>
<h4 id="541-加权轮询weighted-round-robin"><a class="markdownIt-Anchor" href="#541-加权轮询weighted-round-robin"></a> 5.4.1. 加权轮询（weighted round robin）</h4>
<p>轮询的原理很简单，首先我们介绍一下轮询的基本流程。如下是处理一次请求的流程图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227201913984-412518987.jpg"/></div>
<p>图中有两点需要注意，第一，如果可以把加权轮询算法分为先深搜索和先广搜索，那么 nginx 采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；第二，当所有后端机器都 down 掉时，nginx 会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在 timeout 的状态，从而导致整个前端被夯住。</p>
<h4 id="542-ip-hash"><a class="markdownIt-Anchor" href="#542-ip-hash"></a> 5.4.2. ip hash</h4>
<p>ip hash 是 nginx 内置的另一个负载均衡的策略，流程和轮询很类似，只是其中的算法和具体的策略有些变化，如下图所示：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227201851812-352858632.jpg"/></div>
<h4 id="543-fair"><a class="markdownIt-Anchor" href="#543-fair"></a> 5.4.3. fair</h4>
<p>fair 策略是扩展策略，默认不被编译进 nginx 内核。其原理是根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流。这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此要慎用。</p>
<h4 id="544-通用-hash-一致性-hash"><a class="markdownIt-Anchor" href="#544-通用-hash-一致性-hash"></a> 5.4.4. 通用 hash、一致性 hash</h4>
<p>这两种也是扩展策略，在具体的实现上有些差别，通用 hash 比较简单，可以以 nginx 内置的变量为 key 进行 hash，一致性 hash 采用了 nginx 内置的一致性 hash 环，可以支持 memcache。</p>
<h3 id="55-ngnix-场景"><a class="markdownIt-Anchor" href="#55-ngnix-场景"></a> 5.5. Ngnix 场景</h3>
<p>Ngnix 一般作为入口负载均衡或内部负载均衡，结合反向代理服务器使用。以下架构示例，仅供参考，具体使用根据场景而定。</p>
<h4 id="551-入口负载均衡架构"><a class="markdownIt-Anchor" href="#551-入口负载均衡架构"></a> 5.5.1. 入口负载均衡架构</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202044781-2116477406.png"/></div>
<p>Ngnix 服务器在用户访问的最前端。根据用户请求再转发到具体的应用服务器或二级负载均衡服务器（LVS）</p>
<h4 id="552-内部负载均衡架构"><a class="markdownIt-Anchor" href="#552-内部负载均衡架构"></a> 5.5.2. 内部负载均衡架构</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202054421-2015542569.png"/></div>
<p>LVS 作为入口负载均衡，将请求转发到二级 Ngnix 服务器，Ngnix 再根据请求转发到具体的应用服务器。</p>
<h4 id="553-ngnix-高可用"><a class="markdownIt-Anchor" href="#553-ngnix-高可用"></a> 5.5.3. Ngnix 高可用</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202100921-915093452.png"/></div>
<p>分布式系统中，应用只部署一台服务器会存在单点故障，负载均衡同样有类似的问题。一般可采用主备或负载均衡设备集群的方式节约单点故障或高并发请求分流。</p>
<p>Ngnix 高可用，至少包含两个 Ngnix 服务器，一台主服务器，一台备服务器，之间使用 Keepalived 做健康监控和故障检测。开放 VIP 端口，通过防火墙进行外部映射。</p>
<p>DNS 解析公网的 IP 实际为 VIP。</p>
<h2 id="6-lvs-负载均衡"><a class="markdownIt-Anchor" href="#6-lvs-负载均衡"></a> 6. LVS 负载均衡</h2>
<p>LVS 是一个开源的软件，由毕业于国防科技大学的章文嵩博士于 1998 年 5 月创立，用来实现 Linux 平台下的简单负载均衡。LVS 是 Linux Virtual Server 的缩写，意思是 Linux 虚拟服务器。</p>
<p>基于 IP 层的负载均衡调度技术，它在操作系统核心层上，将来自 IP 层的 TCP/UDP 请求均衡地转移到不同的 服务器，从而将一组服务器构成一个高性能、高可用的虚拟服务器。</p>
<p>操作系统：Liunx</p>
<p>开发语言：C</p>
<p>并发性能：默认 4096，可以修改但需要重新编译。</p>
<h3 id="61-lvs-功能"><a class="markdownIt-Anchor" href="#61-lvs-功能"></a> 6.1. LVS 功能</h3>
<p>LVS 的主要功能是实现 IP 层（网络层）负载均衡，有 NAT,TUN,DR 三种请求转发模式。</p>
<h4 id="611-lvsnat-方式的负载均衡集群"><a class="markdownIt-Anchor" href="#611-lvsnat-方式的负载均衡集群"></a> 6.1.1. LVS/NAT 方式的负载均衡集群</h4>
<p>NAT 是指 Network Address Translation，它的转发流程是：Director 机器收到外界请求，改写数据包的目标地址，按相应的调度算法将其发送到相应 Real Server 上，Real Server 处理完该请求后，将结果数据包返回到其默认网关，即 Director 机器上，Director 机器再改写数据包的源地址，最后将其返回给外界。这样就完成一次负载调度。</p>
<p>构架一个最简单的 LVS/NAT 方式的负载均衡集群 Real Server 可以是任何的操作系统，而且无需做任何特殊的设定，惟一要做的就是将其默认网关指向 Director 机器。Real Server 可以使用局域网的内部 IP(192.168.0.0/24)。Director 要有两块网卡，一块网卡绑定一个外部 IP 地址 (10.0.0.1)，另一块网卡绑定局域网的内部 IP(192.168.0.254)，作为 Real Server 的默认网关。</p>
<p>LVS/NAT 方式实现起来最为简单，而且 Real Server 使用的是内部 IP，可以节省 Real IP 的开销。但因为执行 NAT 需要重写流经 Director 的数据包，在速度上有一定延迟；</p>
<p>当用户的请求非常短，而服务器的回应非常大的情况下，会对 Director 形成很大压力，成为新的瓶颈，从而使整个系统的性能受到限制。</p>
<h4 id="612-lvstun-方式的负载均衡集群"><a class="markdownIt-Anchor" href="#612-lvstun-方式的负载均衡集群"></a> 6.1.2. LVS/TUN 方式的负载均衡集群</h4>
<p>TUN 是指 IP Tunneling，它的转发流程是：Director 机器收到外界请求，按相应的调度算法,通过 IP 隧道发送到相应 Real Server，Real Server 处理完该请求后，将结果数据包直接返回给客户。至此完成一次负载调度。</p>
<p>最简单的 LVS/TUN 方式的负载均衡集群架构使用 IP Tunneling 技术，在 Director 机器和 Real Server 机器之间架设一个 IP Tunnel，通过 IP Tunnel 将负载分配到 Real Server 机器上。Director 和 Real Server 之间的关系比较松散，可以是在同一个网络中，也可以是在不同的网络中，只要两者能够通过 IP Tunnel 相连就行。收到负载分配的 Real Server 机器处理完后会直接将反馈数据送回给客户，而不必通过 Director 机器。实际应用中，服务器必须拥有正式的 IP 地址用于与客户机直接通信，并且所有服务器必须支持 IP 隧道协议。</p>
<p>该方式中 Director 将客户请求分配到不同的 Real Server，Real Server 处理请求后直接回应给用户，这样 Director 就只处理客户机与服务器的一半连接，极大地提高了 Director 的调度处理能力，使集群系统能容纳更多的节点数。另外 TUN 方式中的 Real Server 可以在任何 LAN 或 WAN 上运行，这样可以构筑跨地域的集群，其应对灾难的能力也更强，但是服务器需要为 IP 封装付出一定的资源开销，而且后端的 Real Server 必须是支持 IP Tunneling 的操作系统。</p>
<h4 id="613-lvstun-方式的负载均衡集群"><a class="markdownIt-Anchor" href="#613-lvstun-方式的负载均衡集群"></a> 6.1.3. LVS/TUN 方式的负载均衡集群</h4>
<p>DR 是指 Direct Routing，它的转发流程是：Director 机器收到外界请求，按相应的调度算法将其直接发送到相应 Real Server，Real Server 处理完该请求后，将结果数据包直接返回给客户，完成一次负载调度。</p>
<p>构架一个最简单的 LVS/DR 方式的负载均衡集群 Real Server 和 Director 都在同一个物理网段中，Director 的网卡 IP 是 192.168.0.253，再绑定另一个 IP： 192.168.0.254 作为对外界的 virtual IP，外界客户通过该 IP 来访问整个集群系统。Real Server 在 lo 上绑定 IP：192.168.0.254，同时加入相应的路由。</p>
<p>LVS/DR 方式与前面的 LVS/TUN 方式有些类似，前台的 Director 机器也是只需要接收和调度外界的请求，而不需要负责返回这些请求的反馈结果，所以能够负载更多的 Real Server，提高 Director 的调度处理能力，使集群系统容纳更多的 Real Server。但 LVS/DR 需要改写请求报文的 MAC 地址，所以所有服务器必须在同一物理网段内。</p>
<h3 id="62-lvs-架构"><a class="markdownIt-Anchor" href="#62-lvs-架构"></a> 6.2. LVS 架构</h3>
<p>LVS 架设的服务器集群系统有三个部分组成：最前端的负载均衡层（Loader Balancer），中间的服务器群组层，用 Server Array 表示，最底层的数据共享存储层，用 Shared Storage 表示。在用户看来所有的应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。</p>
<p>LVS 的体系架构如图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227220009109-1768809526.png"/></div>
<p>LVS 的各个层次的详细介绍：</p>
<p>Load Balancer 层：位于整个集群系统的最前端，有一台或者多台负载调度器（Director Server）组成，LVS 模块就安装在 Director Server 上，而 Director 的主要作用类似于一个路由器，它含有完成 LVS 功能所设定的路由表，通过这些路由表把用户的请求分发给 Server Array 层的应用服务器（Real Server）上。同时，在 Director Server 上还要安装对 Real Server 服务的监控模块 Ldirectord，此模块用于监测各个 Real Server 服务的健康状况。在 Real Server 不可用时把它从 LVS 路由表中剔除，恢复时重新加入。</p>
<p>Server Array 层：由一组实际运行应用服务的机器组成，Real Server 可以是 WEB 服务器、MAIL 服务器、FTP 服务器、DNS 服务器、视频服务器中的一个或者多个，每个 Real Server 之间通过高速的 LAN 或分布在各地的 WAN 相连接。在实际的应用中，Director Server 也可以同时兼任 Real Server 的角色。</p>
<p>Shared Storage 层：是为所有 Real Server 提供共享存储空间和内容一致性的存储区域，在物理上，一般有磁盘阵列设备组成，为了提供内容的一致性，一般可以通过 NFS 网络文件系统共享数 据，但是 NFS 在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如 Red hat 的 GFS 文件系统，oracle 提供的 OCFS2 文件系统等。</p>
<p>从整个 LVS 结构可以看出，Director Server 是整个 LVS 的核心，目前，用于 Director Server 的操作系统只能是 Linux 和 FreeBSD，linux2.6 内核不用任何设置就可以支持 LVS 功能，而 FreeBSD 作为 Director Server 的应用还不是很多，性能也不是很好。对于 Real Server，几乎可以是所有的系统平台，Linux、windows、Solaris、AIX、BSD 系列都能很好的支持。</p>
<h3 id="63-lvs-均衡策略"><a class="markdownIt-Anchor" href="#63-lvs-均衡策略"></a> 6.3. LVS 均衡策略</h3>
<p>LVS 默认支持八种负载均衡策略，简述如下：</p>
<h4 id="631-轮询调度round-robin"><a class="markdownIt-Anchor" href="#631-轮询调度round-robin"></a> 6.3.1. 轮询调度（Round Robin）</h4>
<p>调度器通过“轮询”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。</p>
<h4 id="632-加权轮询weighted-round-robin"><a class="markdownIt-Anchor" href="#632-加权轮询weighted-round-robin"></a> 6.3.2. 加权轮询（Weighted Round Robin）</h4>
<p>调度器通过“加权轮询”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器能处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p>
<h4 id="633-最少链接least-connections"><a class="markdownIt-Anchor" href="#633-最少链接least-connections"></a> 6.3.3. 最少链接（Least Connections）</h4>
<p>调度器通过“最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用“最小连接”调度算法可以较好地均衡负载。</p>
<h4 id="634-加权最少链接weighted-least-connections"><a class="markdownIt-Anchor" href="#634-加权最少链接weighted-least-connections"></a> 6.3.4. 加权最少链接（Weighted Least Connections）</h4>
<p>在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p>
<h4 id="635-基于局部性的最少链接locality-based-least-connections"><a class="markdownIt-Anchor" href="#635-基于局部性的最少链接locality-based-least-connections"></a> 6.3.5. 基于局部性的最少链接（Locality-Based Least Connections）</h4>
<p>“基于局部性的最少链接”调度算法是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。该算法根据请求的目标 IP 地址找出该目标 IP 地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接” 的原则选出一个可用的服务器，将请求发送到该服务器。</p>
<h4 id="636-带复制的基于局部性最少链接locality-based-least-connections-with-replication"><a class="markdownIt-Anchor" href="#636-带复制的基于局部性最少链接locality-based-least-connections-with-replication"></a> 6.3.6. 带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）</h4>
<p>“带复制的基于局部性最少链接”调度算法也是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。它与 LBLC 算法的不同之处是它要维护从一个目标 IP 地址到一组服务器的映射，而 LBLC 算法维护从一个目标 IP 地址到一台服务器的映射。该算法根据请求的目标 IP 地址找出该目标 IP 地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p>
<h4 id="637-目标地址散列destination-hashing"><a class="markdownIt-Anchor" href="#637-目标地址散列destination-hashing"></a> 6.3.7. 目标地址散列（Destination Hashing）</h4>
<p>“目标地址散列”调度算法根据请求的目标 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>
<h4 id="638-源地址散列source-hashing"><a class="markdownIt-Anchor" href="#638-源地址散列source-hashing"></a> 6.3.8. 源地址散列（Source Hashing）</h4>
<p>“源地址散列”调度算法根据请求的源 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>
<p>除具备以上负载均衡算法外，还可以自定义均衡策略。</p>
<h3 id="64-lvs-场景"><a class="markdownIt-Anchor" href="#64-lvs-场景"></a> 6.4. LVS 场景</h3>
<p>一般作为入口负载均衡或内部负载均衡，结合反向代理服务器使用。相关架构可参考 Ngnix 场景架构。</p>
<h2 id="7-haproxy-负载均衡"><a class="markdownIt-Anchor" href="#7-haproxy-负载均衡"></a> 7. HaProxy 负载均衡</h2>
<p>HAProxy 也是使用较多的一款负载均衡软件。HAProxy 提供高可用性、负载均衡以及基于 TCP 和 HTTP 应用的代理，支持虚拟主机，是免费、快速并且可靠的一种解决方案。特别适用于那些负载特大的 web 站点。运行模式使得它可以很简单安全的整合到当前的架构中，同时可以保护你的 web 服务器不被暴露到网络上。</p>
<h3 id="71-haproxy-特点"><a class="markdownIt-Anchor" href="#71-haproxy-特点"></a> 7.1. HaProxy 特点</h3>
<ul>
<li>支持两种代理模式：TCP（四层）和 HTTP（七层），支持虚拟主机；</li>
<li>配置简单，支持 url 检测后端服务器状态；</li>
<li>做负载均衡软件使用，在高并发情况下，处理速度高于 nginx；</li>
<li>TCP 层多用于 Mysql 从（读）服务器负载均衡。 （对 Mysql 进行负载均衡，对后端的 DB 节点进行检测和负载均衡）</li>
<li>能够补充 Nginx 的一些缺点比如 Session 的保持，Cookie 引导等工作</li>
</ul>
<h3 id="72-haproxy-均衡策略"><a class="markdownIt-Anchor" href="#72-haproxy-均衡策略"></a> 7.2. HaProxy 均衡策略</h3>
<p>支持四种常用算法：</p>
<ul>
<li>roundrobin：轮询，轮流分配到后端服务器；</li>
<li>static-rr：根据后端服务器性能分配；</li>
<li>leastconn：最小连接者优先处理；</li>
<li>source：根据请求源 IP，与 Nginx 的 IP_Hash 类似。</li>
</ul>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（1）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5043452.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（2）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5080743.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（3）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5080988.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（4）</a></li>
<li><a href="https://segmentfault.com/a/1190000004492447" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004492447</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">大型网站架构概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 16:35:52" itemprop="dateModified" datetime="2019-11-27T16:35:52+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/大型网站架构概述/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="大型网站架构概述"><a class="markdownIt-Anchor" href="#大型网站架构概述"></a> 大型网站架构概述</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9">1. 大型网站系统的特点</a></li>
<li><a href="#2-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96%E5%8E%86%E7%A8%8B">2. 大型网站架构演化历程</a>
<ul>
<li><a href="#21-%E5%88%9D%E5%A7%8B%E9%98%B6%E6%AE%B5%E6%9E%B6%E6%9E%84">2.1. 初始阶段架构</a></li>
<li><a href="#22-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E7%A6%BB">2.2. 应用服务和数据服务分离</a></li>
<li><a href="#23-%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD">2.3. 使用缓存改善性能</a></li>
<li><a href="#24-%E4%BD%BF%E7%94%A8%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4">2.4. 使用应用服务器集群</a></li>
<li><a href="#25-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">2.5. 数据库读写分离</a></li>
<li><a href="#26-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C-cdn-%E5%8A%A0%E9%80%9F">2.6. 反向代理和 CDN 加速</a></li>
<li><a href="#27-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93">2.7. 分布式文件系统和分布式数据库</a></li>
<li><a href="#28-%E4%BD%BF%E7%94%A8-nosql-%E5%92%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">2.8. 使用 NoSQL 和搜索引擎</a></li>
<li><a href="#29-%E4%B8%9A%E5%8A%A1%E6%8B%86%E5%88%86">2.9. 业务拆分</a></li>
<li><a href="#210-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1">2.10. 分布式服务</a></li>
</ul>
</li>
<li><a href="#3-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">3. 大型网站架构模式</a>
<ul>
<li><a href="#31-%E5%88%86%E5%B1%82">3.1. 分层</a></li>
<li><a href="#32-%E5%88%86%E5%89%B2">3.2. 分割</a></li>
<li><a href="#33-%E5%88%86%E5%B8%83%E5%BC%8F">3.3. 分布式</a></li>
<li><a href="#34-%E9%9B%86%E7%BE%A4">3.4. 集群</a></li>
<li><a href="#35-%E7%BC%93%E5%AD%98">3.5. 缓存</a></li>
<li><a href="#36-%E5%BC%82%E6%AD%A5">3.6. 异步</a></li>
<li><a href="#37-%E5%86%97%E4%BD%99">3.7. 冗余</a></li>
<li><a href="#38-%E8%87%AA%E5%8A%A8%E5%8C%96">3.8. 自动化</a></li>
<li><a href="#39-%E5%AE%89%E5%85%A8">3.9. 安全</a></li>
</ul>
</li>
<li><a href="#4-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%A6%81%E7%B4%A0">4. 大型网站核心架构要素</a>
<ul>
<li><a href="#41-%E6%80%A7%E8%83%BD">4.1. 性能</a></li>
<li><a href="#42-%E5%8F%AF%E7%94%A8%E6%80%A7">4.2. 可用性</a></li>
<li><a href="#43-%E4%BC%B8%E7%BC%A9%E6%80%A7">4.3. 伸缩性</a></li>
<li><a href="#44-%E6%89%A9%E5%B1%95%E6%80%A7">4.4. 扩展性</a></li>
<li><a href="#45-%E5%AE%89%E5%85%A8%E6%80%A7">4.5. 安全性</a></li>
</ul>
</li>
<li><a href="#5-%E8%B5%84%E6%96%99">5. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-大型网站系统的特点"><a class="markdownIt-Anchor" href="#1-大型网站系统的特点"></a> 1. 大型网站系统的特点</h2>
<ul>
<li>高并发、大流量</li>
<li>高可用</li>
<li>海量数据</li>
<li>用户分布广泛，网络情况复杂</li>
<li>安全环境恶劣</li>
<li>需求快速变更，迭代频繁</li>
<li>渐进式发展</li>
</ul>
<h2 id="2-大型网站架构演化历程"><a class="markdownIt-Anchor" href="#2-大型网站架构演化历程"></a> 2. 大型网站架构演化历程</h2>
<h3 id="21-初始阶段架构"><a class="markdownIt-Anchor" href="#21-初始阶段架构"></a> 2.1. 初始阶段架构</h3>
<p>问题：网站运营初期，访问用户少，一台服务器绰绰有余。</p>
<p>特征：<strong>应用程序、数据库、文件等所有的资源都在一台服务器上。</strong></p>
<p>描述：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-初始阶段架构.jpg!zp" width="400"/>
</div>
<h3 id="22-应用服务和数据服务分离"><a class="markdownIt-Anchor" href="#22-应用服务和数据服务分离"></a> 2.2. 应用服务和数据服务分离</h3>
<p>问题：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。</p>
<p>特征：<strong>应用服务器、数据库服务器、文件服务器分别独立部署。</strong></p>
<p>描述：三台服务器对性能要求各不相同：应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；文件服务器需要存储大量文件，因此需要更大容量的硬盘。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-应用服务和数据服务分离.jpg!zp" width="450"/>
</div>
<h3 id="23-使用缓存改善性能"><a class="markdownIt-Anchor" href="#23-使用缓存改善性能"></a> 2.3. 使用缓存改善性能</h3>
<p>问题：随着用户逐渐增多，数据库压力太大导致访问延迟。</p>
<p>特征：由于网站访问和财富分配一样遵循二八定律：80% 的业务访问集中在 20% 的数据上。<strong>将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。</strong></p>
<p>描述：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存，本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-使用缓存改善性能.jpg!zp" width="450"/>
</div>
<h3 id="24-使用应用服务器集群"><a class="markdownIt-Anchor" href="#24-使用应用服务器集群"></a> 2.4. 使用应用服务器集群</h3>
<p>问题：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。</p>
<p>特征：<strong>多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。</strong></p>
<p>描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-使用应用服务器集群.jpg!zp" width="500"/>
</div>
<h3 id="25-数据库读写分离"><a class="markdownIt-Anchor" href="#25-数据库读写分离"></a> 2.5. 数据库读写分离</h3>
<p>问题：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。</p>
<p>特征：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。<strong>网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。</strong></p>
<p>描述：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-数据库读写分离.jpg!zp" width="500"/>
</div>
<h3 id="26-反向代理和-cdn-加速"><a class="markdownIt-Anchor" href="#26-反向代理和-cdn-加速"></a> 2.6. 反向代理和 CDN 加速</h3>
<p>问题：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。</p>
<p>特征：<strong>采用 CDN 和反向代理加快系统的静态资源访问速度。</strong></p>
<p>描述：CDN 和反向代理的基本原理都是缓存，区别在于 CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-反向代理和CDN加速.jpg!zp" width="500"/>
</div>
<h3 id="27-分布式文件系统和分布式数据库"><a class="markdownIt-Anchor" href="#27-分布式文件系统和分布式数据库"></a> 2.7. 分布式文件系统和分布式数据库</h3>
<p>问题：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。</p>
<p>特征：<strong>数据库采用分布式数据库，文件系统采用分布式文件系统。</strong></p>
<p>描述：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-分布式文件系统和分布式数据库.jpg!zp" />
</div>
<h3 id="28-使用-nosql-和搜索引擎"><a class="markdownIt-Anchor" href="#28-使用-nosql-和搜索引擎"></a> 2.8. 使用 NoSQL 和搜索引擎</h3>
<p>问题：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。</p>
<p>特征：<strong>系统引入 NoSQL 数据库及搜索引擎。</strong></p>
<p>描述：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-使用NoSQL和搜索引擎.jpg!zp" />
</div>
<h3 id="29-业务拆分"><a class="markdownIt-Anchor" href="#29-业务拆分"></a> 2.9. 业务拆分</h3>
<p>问题：大型网站的业务场景日益复杂，分为多个产品线。</p>
<p>特征：采用分而治之的手段将整个网站业务分成不同的产品线。<strong>系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。</strong></p>
<p>描述：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。</p>
<p>纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</p>
<p>横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-业务拆分.jpg!zp" />
</div>
<h3 id="210-分布式服务"><a class="markdownIt-Anchor" href="#210-分布式服务"></a> 2.10. 分布式服务</h3>
<p>问题：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。</p>
<p>特征：<strong>公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。</strong></p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/系统架构进化-分布式服务.jpg!zp" />
</div>
<h2 id="3-大型网站架构模式"><a class="markdownIt-Anchor" href="#3-大型网站架构模式"></a> 3. 大型网站架构模式</h2>
<h3 id="31-分层"><a class="markdownIt-Anchor" href="#31-分层"></a> 3.1. 分层</h3>
<p>大型网站架构中常采用分层结构，将软件系统分为应用层、服务层、数据层：</p>
<ul>
<li><strong>应用层</strong> - 负责具体业务和视图展示。如网站首页及搜索输入和结果展示。</li>
<li><strong>服务层</strong> - 为应用层提供服务支持。如用户管理服务、购物车服务等。</li>
<li><strong>应用层</strong> - 提供数据存储访问服务。如数据库、缓存、文件、搜索引擎等。</li>
</ul>
<p>分层架构的约束：禁止跨层次的调用（应用层直接调用数据层）及逆向调用（数据层调用服务层，或者服务层调用应用层）。</p>
<p>分层结构内部还可以继续分层，如应用可以再细分为视图层和业务逻辑层；服务层也可以细分为数据接口层和逻辑处理层。</p>
<h3 id="32-分割"><a class="markdownIt-Anchor" href="#32-分割"></a> 3.2. 分割</h3>
<p>将不同的功能和服务分割开来，包装成高内聚低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。</p>
<h3 id="33-分布式"><a class="markdownIt-Anchor" href="#33-分布式"></a> 3.3. 分布式</h3>
<p>大于大型网站，分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同的服务器上，通过远程调用协同工作。</p>
<p>分布式意味可以用更多的机器工作，那么 CPU、内存、存储资源也就更丰富，能够处理的并发访问和数据量就越大，进而能够为更多的用户提供服务。</p>
<p>分布式也引入了一些问题：</p>
<ul>
<li>服务调用必须通过网络，网络延迟会影响性能</li>
<li>服务器越多，宕机概率也越大，是可用性降低</li>
<li>数据一致性非常困难，分布式事务也难以保证</li>
<li>网站依赖错综复杂，开发管理维护困难</li>
</ul>
<p>常用的分布式方案：</p>
<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
<h3 id="34-集群"><a class="markdownIt-Anchor" href="#34-集群"></a> 3.4. 集群</h3>
<p>集群即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。</p>
<p>集群需要具备伸缩性和故障转移机制：伸缩性是指可以根据用户访问量向集群添加或减少机器；故障转移是指，当某台机器出现故障时，负载均衡设备或失效转移机制将请求转发到集群中的其他机器上，从而不影响用户使用。</p>
<h3 id="35-缓存"><a class="markdownIt-Anchor" href="#35-缓存"></a> 3.5. 缓存</h3>
<p>缓存就是将数据存放在距离最近的位置以加快处理速度。缓存是改善软件性能的第一手段。</p>
<p>网站应用中，缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。</p>
<p>常见缓存手段：</p>
<ul>
<li>CDN</li>
<li>反向代理</li>
<li>本地缓存</li>
<li>分布式缓存</li>
</ul>
<p>使用缓存有两个前提：</p>
<ul>
<li>数据访问热点不均匀，频繁访问的数据应该放在缓存中</li>
<li>数据在某个时间段有效，不过很快过期，否则缓存数据会因已经失效而产生脏读</li>
</ul>
<h3 id="36-异步"><a class="markdownIt-Anchor" href="#36-异步"></a> 3.6. 异步</h3>
<p>软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展。</p>
<p>大型网站架构中，系统解耦的手段除了分层、分割、分布式等，还有一个重要手段——异步。</p>
<p>业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。</p>
<ul>
<li>在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；</li>
<li>在分布式系统中，多个服务器集群通过分布式消息队列实现异步。</li>
</ul>
<p>异步架构是典型的生产者消费模式，二者不存在直接调用。异步消息队列还有如下特性：</p>
<ul>
<li>提高系统可用性</li>
<li>加快响应速度</li>
<li>消除并发访问高峰</li>
</ul>
<h3 id="37-冗余"><a class="markdownIt-Anchor" href="#37-冗余"></a> 3.7. 冗余</h3>
<p>大型网站，出现服务器宕机是必然事件。要保证部分服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份。这样当某台服务器宕机是，可以将其上的服务和数据访问转移到其他机器上。</p>
<p>访问和负载很小的服务也必须部署 至少两台服务器构成一个集群，目的就是通过冗余实现服务高可用。数据除了定期备份，存档保存，实现 <strong>冷备份</strong> 外；为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现 <strong>热备份</strong>。</p>
<p>为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 <strong>灾备数据中心</strong>。网站程序和数据实时同步到多个灾备数据中心。</p>
<h3 id="38-自动化"><a class="markdownIt-Anchor" href="#38-自动化"></a> 3.8. 自动化</h3>
<p>大型网站架构的自动化架构设计主要集中在发布运维方面：</p>
<ul>
<li>发布过程自动化
<ul>
<li>自动化代码管理</li>
<li>自动化测试</li>
<li>自动化安全监测</li>
<li>自动化部署</li>
</ul>
</li>
<li>运维自动化
<ul>
<li>自动化监控</li>
<li>自动化报警</li>
<li>自动化失效转移</li>
<li>自动化失效恢复</li>
<li>自动化降级</li>
<li>自动化分配资源</li>
</ul>
</li>
</ul>
<h3 id="39-安全"><a class="markdownIt-Anchor" href="#39-安全"></a> 3.9. 安全</h3>
<ul>
<li><strong>密码</strong> 和 <strong>手机校验码</strong> 进行身份认证</li>
<li>登录、交易等重要操作需要对网络通信进行 <strong>加密</strong>，存储的敏感数据如用户信息等也进行加密处理</li>
<li>防止机器人程序攻击网站，使用 <strong>验证码</strong> 进行识别</li>
<li>对常见用于 <strong>攻击</strong> 网站的 XSS 攻击、SQL 注入、进行编码转换等相应处理</li>
<li>对垃圾信息、敏感信息进行 <strong>过滤</strong></li>
<li>对交易转账等重要操作根据交易模式和交易信息进行 <strong>风险控制</strong></li>
</ul>
<h2 id="4-大型网站核心架构要素"><a class="markdownIt-Anchor" href="#4-大型网站核心架构要素"></a> 4. 大型网站核心架构要素</h2>
<p><strong>架构</strong> 的一种通俗说法是：<strong>最高层次的规划，难以改变的决定。</strong></p>
<p>除了系统功能需求外，架构还需要关注以下架构要素：</p>
<h3 id="41-性能"><a class="markdownIt-Anchor" href="#41-性能"></a> 4.1. 性能</h3>
<p>性能问题无处不在，所以网站性能优化手段也十分繁多：</p>
<ul>
<li>前端
<ul>
<li>浏览器缓存</li>
<li>静态资源压缩</li>
<li>合理布局页面</li>
<li>减少 cookie 传输</li>
<li>CDN</li>
</ul>
</li>
<li>应用服务器
<ul>
<li>本地缓存</li>
<li>分布式缓存</li>
<li>异步消息队列</li>
<li>集群</li>
<li>代码层面：使用多线程、改善内存管理</li>
</ul>
</li>
<li>数据库
<ul>
<li>索引</li>
<li>数据库缓存</li>
<li>SQL 优化</li>
</ul>
</li>
</ul>
<h3 id="42-可用性"><a class="markdownIt-Anchor" href="#42-可用性"></a> 4.2. 可用性</h3>
<p>可用性指部分服务器出现故障时，还能否对用户提供服务</p>
<ul>
<li>冗余
<ul>
<li>通过负载均衡设备建立集群共同对外提供服务</li>
<li>数据存储在多台服务器，互相备份</li>
</ul>
</li>
<li>自动化：通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能</li>
</ul>
<h3 id="43-伸缩性"><a class="markdownIt-Anchor" href="#43-伸缩性"></a> 4.3. 伸缩性</h3>
<p>衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。</p>
<ul>
<li>应用服务器集群 - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可</li>
<li>缓存服务器集群 - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。</li>
<li>关系型数据库集群 - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。</li>
<li>NOSql 数据库集群 - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。</li>
</ul>
<h3 id="44-扩展性"><a class="markdownIt-Anchor" href="#44-扩展性"></a> 4.4. 扩展性</h3>
<p>衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。主要手段有：事件驱动架构和分布式服务。</p>
<h3 id="45-安全性"><a class="markdownIt-Anchor" href="#45-安全性"></a> 4.5. 安全性</h3>
<p>安全性保护网站不受恶意攻击，保护网站重要数据不被窃取。</p>
<h2 id="5-资料"><a class="markdownIt-Anchor" href="#5-资料"></a> 5. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">分布式架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 15:29:01" itemprop="dateModified" datetime="2019-11-27T15:29:01+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/分布式架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式架构"><a class="markdownIt-Anchor" href="#分布式架构"></a> 分布式架构</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<h2 id="1-分布式架构的问题"><a class="markdownIt-Anchor" href="#1-分布式架构的问题"></a> 1. 分布式架构的问题</h2>
<ul>
<li>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</li>
<li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</li>
<li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</li>
<li>服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？</li>
<li>一个服务有多个业务消费者，如何确保服务质量？</li>
<li>随着服务的不停升级，总有些意想不到的事发生，比如 cache 写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？</li>
</ul>
<h2 id="2-分布式架构的关键技术"><a class="markdownIt-Anchor" href="#2-分布式架构的关键技术"></a> 2. 分布式架构的关键技术</h2>
<h3 id="21-消息队列"><a class="markdownIt-Anchor" href="#21-消息队列"></a> 2.1. 消息队列</h3>
<p>消息队列通过消息对象分解系统耦合性，不同子系统处理同一个消息。</p>
<h4 id="211-消息队列框架"><a class="markdownIt-Anchor" href="#211-消息队列框架"></a> 2.1.1. 消息队列框架</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式架构-消息队列框架.jpg!zp" width="600"/>
</div>
<h4 id="212-消息队列原理"><a class="markdownIt-Anchor" href="#212-消息队列原理"></a> 2.1.2. 消息队列原理</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式架构-消息队列原理.jpg!zp" width="600"/>
</div>
<h3 id="22-服务化"><a class="markdownIt-Anchor" href="#22-服务化"></a> 2.2. 服务化</h3>
<p>服务框架通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用。</p>
<p>服务框架是一个点对点模型。</p>
<p>服务框架面向同构系统。</p>
<p>适合：移动应用、互联网应用、外部系统。</p>
<h4 id="221-服务化框架"><a class="markdownIt-Anchor" href="#221-服务化框架"></a> 2.2.1. 服务化框架</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式架构-服务化框架.jpg!zp" width="600"/>
</div>
<h4 id="222-服务化原理"><a class="markdownIt-Anchor" href="#222-服务化原理"></a> 2.2.2. 服务化原理</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式架构-服务化原理.jpg!zp" width="600"/>
</div>
<h4 id="223-服务治理"><a class="markdownIt-Anchor" href="#223-服务治理"></a> 2.2.3. 服务治理</h4>
<p>服务治理是服务框架/服务总线的核心功能。所谓服务治理，是指服务的提供方和消费方达成一致的约定，保证服务的高质量。服务治理功能可以解决将某些特定流量引入某一批机器，以及限制某些非法消费者的恶意访问，并在提供者处理量达到一定程度是，拒绝接受新的访问。</p>
<p>当前比较流行的服务治理框架：Dubbo。</p>
<h3 id="23-服务总线"><a class="markdownIt-Anchor" href="#23-服务总线"></a> 2.3. 服务总线</h3>
<p>服务总线同服务框架一样，均是通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用。</p>
<p>服务总线是一个总线式的模型。</p>
<p>服务总线面向同构、异构系统。</p>
<p>适合：内部系统。</p>
<h4 id="231-服务总线框架"><a class="markdownIt-Anchor" href="#231-服务总线框架"></a> 2.3.1. 服务总线框架</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式架构-服务总线框架.jpg!zp" width="600"/>
</div>
<h4 id="232-服务总线原理"><a class="markdownIt-Anchor" href="#232-服务总线原理"></a> 2.3.2. 服务总线原理</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式架构-服务总线原理.jpg!zp" width="600"/>
</div>
<h2 id="3-分布式架构的通信模式"><a class="markdownIt-Anchor" href="#3-分布式架构的通信模式"></a> 3. 分布式架构的通信模式</h2>
<h3 id="31-requestresponse-模式同步模式"><a class="markdownIt-Anchor" href="#31-requestresponse-模式同步模式"></a> 3.1. request/response 模式（同步模式）</h3>
<p>客户端发起请求一直阻塞到服务端返回请求为止。</p>
<h3 id="32-callback异步模式"><a class="markdownIt-Anchor" href="#32-callback异步模式"></a> 3.2. Callback（异步模式）</h3>
<p>客户端发送一个 RPC 请求给服务器，服务端处理后再发送一个消息给消息发送端提供的 callback 端点，此类情况非常合适以下场景：A 组件发送 RPC 请求给 B，B 处理完成后，需要通知 A 组件做后续处理。</p>
<h3 id="33-future-模式"><a class="markdownIt-Anchor" href="#33-future-模式"></a> 3.3. Future 模式</h3>
<p>客户端发送完请求后，继续做自己的事情，返回一个包含消息结果的 Future 对象。客户端需要使用返回结果时，使用 Future 对象的.get(),如果此时没有结果返回的话，会一直阻塞到有结果返回为止。</p>
<h3 id="34-oneway-模式"><a class="markdownIt-Anchor" href="#34-oneway-模式"></a> 3.4. Oneway 模式</h3>
<p>客户端调用完继续执行，不管接收端是否成功。</p>
<h3 id="35-reliable-模式"><a class="markdownIt-Anchor" href="#35-reliable-模式"></a> 3.5. Reliable 模式</h3>
<p>为保证通信可靠，将借助于消息中心来实现消息的可靠送达，请求将做持久化存储，在接收方在线时做送达，并由消息中心保证异常重试。</p>
<h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2>
<ul>
<li><a href="https://www.zhihu.com/question/22764869/answer/31277656" target="_blank" rel="noopener">https://www.zhihu.com/question/22764869/answer/31277656</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">网站的伸缩性架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 16:36:22" itemprop="dateModified" datetime="2019-11-27T16:36:22+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/网站的伸缩性架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网站的伸缩性架构"><a class="markdownIt-Anchor" href="#网站的伸缩性架构"></a> 网站的伸缩性架构</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E8%AE%BE%E8%AE%A1">1. 网站架构的伸缩性设计</a>
<ul>
<li><a href="#11-%E4%B8%8D%E5%90%8C%E5%8A%9F%E8%83%BD%E8%BF%9B%E8%A1%8C%E7%89%A9%E7%90%86%E5%88%86%E7%A6%BB%E5%AE%9E%E7%8E%B0%E4%BC%B8%E7%BC%A9">1.1. 不同功能进行物理分离实现伸缩</a></li>
<li><a href="#12-%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E9%80%9A%E8%BF%87%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E5%AE%9E%E7%8E%B0%E4%BC%B8%E7%BC%A9">1.2. 单一功能通过集群规模实现伸缩</a></li>
</ul>
</li>
<li><a href="#2-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E8%AE%BE%E8%AE%A1">2. 应用服务器集群的伸缩性设计</a>
<ul>
<li><a href="#21-http-%E9%87%8D%E5%AE%9A%E5%90%91%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.1. HTTP 重定向负载均衡</a></li>
<li><a href="#22-dns-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.2. DNS 域名解析负载均衡</a></li>
<li><a href="#23-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.3. 反向代理负载均衡</a></li>
<li><a href="#24-ip-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.4. IP 负载均衡</a></li>
<li><a href="#25-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.5. 数据链路层负载均衡</a></li>
<li><a href="#26-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">2.6. 负载均衡算法</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E8%AE%BE%E8%AE%A1">3. 分布式缓存集群的伸缩性设计</a></li>
<li><a href="#4-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E8%AE%BE%E8%AE%A1">4. 数据存储服务器集群的伸缩性设计</a>
<ul>
<li><a href="#41-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E8%AE%BE%E8%AE%A1">4.1. 关系型数据库的伸缩性设计</a></li>
<li><a href="#42-nosql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E8%AE%BE%E8%AE%A1">4.2. NoSql 数据库的伸缩性设计</a></li>
</ul>
</li>
<li><a href="#5-%E8%B5%84%E6%96%99">5. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-网站架构的伸缩性设计"><a class="markdownIt-Anchor" href="#1-网站架构的伸缩性设计"></a> 1. 网站架构的伸缩性设计</h2>
<h3 id="11-不同功能进行物理分离实现伸缩"><a class="markdownIt-Anchor" href="#11-不同功能进行物理分离实现伸缩"></a> 1.1. 不同功能进行物理分离实现伸缩</h3>
<p>纵向分离（分层后分离）：将业务处理流程上的不同部分分离部署，实现系统伸缩性。</p>
<p>横向分离（业务分割后分离）：将不同的业务模块分离部署，实现系统伸缩性。</p>
<h3 id="12-单一功能通过集群规模实现伸缩"><a class="markdownIt-Anchor" href="#12-单一功能通过集群规模实现伸缩"></a> 1.2. 单一功能通过集群规模实现伸缩</h3>
<p>将不同功能分离部署可以实现一定程度的伸缩性，但是随着网站的访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。</p>
<h2 id="2-应用服务器集群的伸缩性设计"><a class="markdownIt-Anchor" href="#2-应用服务器集群的伸缩性设计"></a> 2. 应用服务器集群的伸缩性设计</h2>
<h3 id="21-http-重定向负载均衡"><a class="markdownIt-Anchor" href="#21-http-重定向负载均衡"></a> 2.1. HTTP 重定向负载均衡</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-HTTP重定向.png!zp" width="500"/>
</div>
<p>利用 HTTP 重定向协议实现负载均衡。</p>
<p>这种负载均衡方案的优点是比较简单。缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 HTTP 302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</p>
<h3 id="22-dns-域名解析负载均衡"><a class="markdownIt-Anchor" href="#22-dns-域名解析负载均衡"></a> 2.2. DNS 域名解析负载均衡</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-DNS域名解析.png!zp" width="500"/>
</div>
<p>利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。</p>
<p>在 DNS 服务器中配置多个 A 记录，如：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">114.100.40.1</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.2</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.3</span> www.mysite.com</span><br></pre></td></tr></table></figure>
<p>每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回，这样 A 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。</p>
<p>DNS 域名解析负载均衡的优点：</p>
<ul>
<li>将负载均衡的工作转交给了 DNS，省掉了网站管理维护的麻烦。</li>
<li>同时，许多 DNS 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。</li>
</ul>
<p>DNS 域名解析负载均衡的缺点：</p>
<ul>
<li>DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。</li>
<li>DNS 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。</li>
</ul>
<h3 id="23-反向代理负载均衡"><a class="markdownIt-Anchor" href="#23-反向代理负载均衡"></a> 2.3. 反向代理负载均衡</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-反向代理.png!zp" width="500"/>
</div>
<p>大多数反向代理服务器同时提供反向代理和负载均衡的功能。</p>
<p>反向代理服务器的优点是部署简单。缺点是反向代理服务器时所有请求和响应的中转站，其性能可能会成为瓶颈。</p>
<h3 id="24-ip-负载均衡"><a class="markdownIt-Anchor" href="#24-ip-负载均衡"></a> 2.4. IP 负载均衡</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-IP层.png!zp" width="500"/>
</div>
<p>在网络层通过修改请求目标地址进行负载均衡。负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 Web 服务器 10.0.0.1，然后将目的 IP 地址修改为 10.0.0.1，不需要通过用户进程。真实 Web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 IP 地址（114.100.80.10）发送给浏览器。</p>
<p>IP 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。</p>
<h3 id="25-数据链路层负载均衡"><a class="markdownIt-Anchor" href="#25-数据链路层负载均衡"></a> 2.5. 数据链路层负载均衡</h3>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/负载均衡-数据链路层.png!zp" width="500"/>
</div>
<p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<p>这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 IP 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 IP 和负载均衡服务器 IP 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 IP 和数据请求目的 IP 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。</p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 LVS(Linux Virtual Server)。</p>
<h3 id="26-负载均衡算法"><a class="markdownIt-Anchor" href="#26-负载均衡算法"></a> 2.6. 负载均衡算法</h3>
<p>负载均衡服务器的实现可以分为两个部分：</p>
<ol>
<li>根据负载均衡算法和 Web 服务器列表计算得到集群中一台 Web 服务器的地址。</li>
<li>将请求数据发送到该地址对应的 Web 服务器上。</li>
</ol>
<p>负载均衡算法通常有以下几种：</p>
<ul>
<li><strong>轮询（Round Robin）</strong> - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。</li>
<li><strong>加权轮询（Weighted Round Robin）</strong> - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。</li>
<li><strong>随机（Random）</strong> - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。</li>
<li><strong>最少连接（Least Connection）</strong> - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。</li>
<li><strong>源地址 Hash（Source Hash）</strong> - 根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。</li>
</ul>
<h2 id="3-分布式缓存集群的伸缩性设计"><a class="markdownIt-Anchor" href="#3-分布式缓存集群的伸缩性设计"></a> 3. 分布式缓存集群的伸缩性设计</h2>
<p>一致性 HASH 算法</p>
<h2 id="4-数据存储服务器集群的伸缩性设计"><a class="markdownIt-Anchor" href="#4-数据存储服务器集群的伸缩性设计"></a> 4. 数据存储服务器集群的伸缩性设计</h2>
<h3 id="41-关系型数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#41-关系型数据库的伸缩性设计"></a> 4.1. 关系型数据库的伸缩性设计</h3>
<ul>
<li><strong>主从复制</strong> - 主流关系型数据库一般都支持主从复制。</li>
<li><strong>分库</strong> - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 Join 操作。</li>
<li><strong>分表</strong> - 使用数据库分片中间件，如 Cobar 等。</li>
</ul>
<h3 id="42-nosql-数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#42-nosql-数据库的伸缩性设计"></a> 4.2. NoSql 数据库的伸缩性设计</h3>
<p>一般而言，Nosql 不支持 SQL 和 ACID，但是强化了对于高可用和伸缩性的支持。</p>
<h2 id="5-资料"><a class="markdownIt-Anchor" href="#5-资料"></a> 5. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">网站的高可用架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 16:36:22" itemprop="dateModified" datetime="2019-11-27T16:36:22+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/网站的高可用架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网站的高可用架构"><a class="markdownIt-Anchor" href="#网站的高可用架构"></a> 网站的高可用架构</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BD%91%E7%AB%99%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E5%BA%A6%E9%87%8F">1. 网站可用性的度量</a></li>
<li><a href="#2-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84">2. 高可用的网站架构</a></li>
<li><a href="#3-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8">3. 高可用的应用</a>
<ul>
<li><a href="#31-%E9%80%9A%E8%BF%87%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%BF%9B%E8%A1%8C%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88%E8%BD%AC%E7%A7%BB">3.1. 通过负载均衡进行无状态服务的失效转移</a></li>
<li><a href="#32-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%9A%84-session-%E7%AE%A1%E7%90%86">3.2. 应用服务器集群的 Session 管理</a></li>
</ul>
</li>
<li><a href="#4-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1">4. 高可用的服务</a></li>
<li><a href="#5-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE">5. 高可用的数据</a>
<ul>
<li><a href="#51-cap-%E5%8E%9F%E7%90%86">5.1. CAP 原理</a></li>
<li><a href="#52-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD">5.2. 数据备份</a></li>
<li><a href="#53-%E5%A4%B1%E6%95%88%E8%BD%AC%E7%A7%BB">5.3. 失效转移</a></li>
</ul>
</li>
<li><a href="#6-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BD%91%E7%AB%99%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81">6. 高可用网站的软件质量保证</a></li>
<li><a href="#7-%E7%BD%91%E7%AB%99%E7%9B%91%E6%8E%A7">7. 网站监控</a></li>
<li><a href="#8-%E8%B5%84%E6%96%99">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-网站可用性的度量"><a class="markdownIt-Anchor" href="#1-网站可用性的度量"></a> 1. 网站可用性的度量</h2>
<p>网站不可用也被称作网站故障，业界通常用多个 9 来衡量网站的可用性。如 QQ 的可用性为 4 个 9，即 99.99% 可用。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">网站不可用时间 = 故障修复时间点 - 故障发现时间点</span><br><span class="line">网站年度可用性指标 = (<span class="number">1</span> - 网站不可用时间/年度总时间) * <span class="number">100</span>%</span><br></pre></td></tr></table></figure>
<h2 id="2-高可用的网站架构"><a class="markdownIt-Anchor" href="#2-高可用的网站架构"></a> 2. 高可用的网站架构</h2>
<p>大型网站的分层架构及服务器的分布式部署使得位于不同层次的服务器具有不同的可用性特点。关闭服务或服务器宕机时产生的影响也不相同，高可用的解决方案也差异甚大。</p>
<h2 id="3-高可用的应用"><a class="markdownIt-Anchor" href="#3-高可用的应用"></a> 3. 高可用的应用</h2>
<h3 id="31-通过负载均衡进行无状态服务的失效转移"><a class="markdownIt-Anchor" href="#31-通过负载均衡进行无状态服务的失效转移"></a> 3.1. 通过负载均衡进行无状态服务的失效转移</h3>
<p>应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 <strong>无状态</strong> 性。</p>
<p>所谓的 <strong>无状态</strong> 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。</p>
<p>负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。</p>
<h3 id="32-应用服务器集群的-session-管理"><a class="markdownIt-Anchor" href="#32-应用服务器集群的-session-管理"></a> 3.2. 应用服务器集群的 Session 管理</h3>
<p>应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。</p>
<p>Web 应用中将这些多次请求修改使用的上下文对象称作会话。单机情况下，Session 可由部署在服务器上的 Web 容器管理。</p>
<p>而在集群环境下，Session 管理有以下手段：</p>
<h4 id="321-session-复制"><a class="markdownIt-Anchor" href="#321-session-复制"></a> 3.2.1. Session 复制</h4>
<p>Session 复制是指应用服务器开发 Web 容器的 Session 复制功能，在集群中的几台服务器之间同步 Session 对象。</p>
<p>这种方案很简单，但当集群规模较大时，集群服务间需要大量的通信来进行 Session 复制。</p>
<h4 id="322-session-绑定"><a class="markdownIt-Anchor" href="#322-session-绑定"></a> 3.2.2. Session 绑定</h4>
<p>可以利用负载均衡的源地址 Hash 算法实现，总是将来源于同一 IP 的请求分发到同一台服务器上。这样在整个会话期间，用户所有的请求都在同一台服务器上处理，即 Session 绑定到某台特定服务器上。这种方法又被称作会话粘滞。</p>
<p>但是这种策略不符合高可用的需求，因为一旦某台服务器宕机，那么该机器上的 Session 也就不复存在了。</p>
<h4 id="323-利用-cookie-记录-session"><a class="markdownIt-Anchor" href="#323-利用-cookie-记录-session"></a> 3.2.3. 利用 Cookie 记录 Session</h4>
<p>可以将 Session 记录在客户端（浏览器 Cookie），每次请求服务器时，将 Session 放在请求中发送给服务器，服务器处理完请求后再将修改过的 Session 响应给客户端。</p>
<p>这种策略的缺点是：Cookie 有大小限制，能记录的信息有限；每次请求响应都需要传输 Cookie，影响性能；如果用户关闭 Cookie，访问就不能工作。</p>
<h4 id="324-session-服务器"><a class="markdownIt-Anchor" href="#324-session-服务器"></a> 3.2.4. Session 服务器</h4>
<p>利用独立部署的 Session 服务器（集群）统一管理 Session，应用服务器每次读写 Session 时，都访问 Session 服务器。</p>
<p>实现 Session 服务器的一种简单方法时：利用分布式缓存、数据库等，在此基础上进行包装，使其符合 Session 的存储和访问要求。</p>
<h2 id="4-高可用的服务"><a class="markdownIt-Anchor" href="#4-高可用的服务"></a> 4. 高可用的服务</h2>
<p>高可用的服务策略：</p>
<ul>
<li><strong>分级管理</strong> - 将服务根据业务重要性进行分级管理，并在服务部署上进行隔离。</li>
<li><strong>超时设置</strong> - 由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。</li>
<li><strong>异步调用</strong> - 对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免长时间等待服务响应结果。</li>
<li><strong>服务降级</strong> - 网站访问高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：拒绝服务和关闭服务。</li>
<li><strong>幂等性设计</strong> - 为了避免服务重复调用，可以通过设置编号的方式进行服务调用有效性校验，有效的操作才能继续执行。</li>
</ul>
<h2 id="5-高可用的数据"><a class="markdownIt-Anchor" href="#5-高可用的数据"></a> 5. 高可用的数据</h2>
<h3 id="51-cap-原理"><a class="markdownIt-Anchor" href="#51-cap-原理"></a> 5.1. CAP 原理</h3>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/distributed/architecture/分布式理论-CAP.jpg!zp" width="450"/>
</div>
<h4 id="511-可用性"><a class="markdownIt-Anchor" href="#511-可用性"></a> 5.1.1. 可用性</h4>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="512-分区容忍性"><a class="markdownIt-Anchor" href="#512-分区容忍性"></a> 5.1.2. 分区容忍性</h4>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h4 id="513-一致性"><a class="markdownIt-Anchor" href="#513-一致性"></a> 5.1.3. 一致性</h4>
<p>一致性指的是多个数据副本是否能保持一致的特性。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>数据一致性又可以分为以下几点：</p>
<ul>
<li>强一致性 - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。</li>
<li>最终一致性 - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。</li>
</ul>
<h4 id="514-权衡"><a class="markdownIt-Anchor" href="#514-权衡"></a> 5.1.4. 权衡</h4>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="52-数据备份"><a class="markdownIt-Anchor" href="#52-数据备份"></a> 5.2. 数据备份</h3>
<ul>
<li>冷备份：定期将数据复制到某种存储介质。</li>
<li>热备份
<ul>
<li>异步热备方式 - 异步方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。</li>
<li>同步热备方式 - 同步方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。</li>
</ul>
</li>
</ul>
<h3 id="53-失效转移"><a class="markdownIt-Anchor" href="#53-失效转移"></a> 5.3. 失效转移</h3>
<h4 id="531-失效确认"><a class="markdownIt-Anchor" href="#531-失效确认"></a> 5.3.1. 失效确认</h4>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/check-fail.png!zp" width="500" />
</div>
<p>判断服务器宕机的手段有两种：心跳检测和访问失败报告。</p>
<p>对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。</p>
<h4 id="532-访问转移"><a class="markdownIt-Anchor" href="#532-访问转移"></a> 5.3.2. 访问转移</h4>
<p>确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。</p>
<h4 id="533-数据恢复"><a class="markdownIt-Anchor" href="#533-数据恢复"></a> 5.3.3. 数据恢复</h4>
<p>因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。</p>
<h2 id="6-高可用网站的软件质量保证"><a class="markdownIt-Anchor" href="#6-高可用网站的软件质量保证"></a> 6. 高可用网站的软件质量保证</h2>
<p>高可用网站的软件质量保证的手段：</p>
<ul>
<li>自动化发布</li>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制</li>
<li>灰度发布</li>
</ul>
<h2 id="7-网站监控"><a class="markdownIt-Anchor" href="#7-网站监控"></a> 7. 网站监控</h2>
<ul>
<li>监控数据采集
<ul>
<li>用户行为日志收集</li>
<li>服务器性能监控</li>
<li>运行数据报告</li>
</ul>
</li>
<li>监控管理
<ul>
<li>系统报警</li>
<li>失效转移</li>
<li>自动优雅降级</li>
</ul>
</li>
</ul>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">网站的安全架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 16:36:22" itemprop="dateModified" datetime="2019-11-27T16:36:22+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/网站的安全架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网站的安全架构"><a class="markdownIt-Anchor" href="#网站的安全架构"></a> 网站的安全架构</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>关键词：XSS、CSRF、SQL 注入、DoS、消息摘要、加密算法、证书</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2">1. 网站安全的攻与防</a>
<ul>
<li><a href="#11-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss">1.1. 跨站脚本攻击（XSS）</a></li>
<li><a href="#12-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf">1.2. 跨站请求伪造（CSRF）</a></li>
<li><a href="#13-sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">1.3. SQL 注入攻击</a></li>
<li><a href="#14-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BBdos">1.4. 拒绝服务攻击（DoS）</a></li>
</ul>
</li>
<li><a href="#2-%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%AF%86%E9%92%A5%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86">2. 加密技术及密钥安全管理</a>
<ul>
<li><a href="#21-%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81">2.1. 消息摘要</a></li>
<li><a href="#22-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">2.2. 加密算法</a></li>
<li><a href="#23-%E8%AF%81%E4%B9%A6">2.3. 证书</a></li>
</ul>
</li>
<li><a href="#3-%E8%B5%84%E6%96%99">3. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-网站安全的攻与防"><a class="markdownIt-Anchor" href="#1-网站安全的攻与防"></a> 1. 网站安全的攻与防</h2>
<p>互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：</p>
<h3 id="11-跨站脚本攻击xss"><a class="markdownIt-Anchor" href="#11-跨站脚本攻击xss"></a> 1.1. 跨站脚本攻击（XSS）</h3>
<h4 id="111-概念"><a class="markdownIt-Anchor" href="#111-概念"></a> 1.1.1. 概念</h4>
<p>跨站脚本攻击（Cross-Site Scripting, XSS），是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。</p>
<p>XSS 攻击示例：</p>
<p>假如有下面一个 textbox</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">"value1from"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>value1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 <code>&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</code> 那么就会变成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address1"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	alert(<span class="built_in">document</span>.cookie)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!-</span> "&gt;</span></span><br></pre></td></tr></table></figure>
<p>嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。</p>
<h4 id="112-攻击手段和目的"><a class="markdownIt-Anchor" href="#112-攻击手段和目的"></a> 1.1.2. 攻击手段和目的</h4>
<p>常用的 XSS 攻击手段和目的有：</p>
<ul>
<li>盗用 cookie，获取敏感信息。</li>
<li>利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。</li>
<li>利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>
<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>
<li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。</li>
</ul>
<h4 id="113-应对手段"><a class="markdownIt-Anchor" href="#113-应对手段"></a> 1.1.3. 应对手段</h4>
<ul>
<li><strong>过滤特殊字符</strong> - 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如 <code>&gt;</code> 转义为 <code>&amp;gt</code>、<code>&lt;</code> 转义为 <code>&amp;lt</code> 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 <code>3&lt;5</code> 中的 <code>&lt;</code> 需要进行文本匹配后再转移，如：<code>&lt;img src=</code> 这样的上下文中的 <code>&lt;</code> 才转义。</li>
<li><strong>设置 Cookie 为 HttpOnly</strong> - 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
</ul>
</blockquote>
<h3 id="12-跨站请求伪造csrf"><a class="markdownIt-Anchor" href="#12-跨站请求伪造csrf"></a> 1.2. 跨站请求伪造（CSRF）</h3>
<h4 id="121-概念"><a class="markdownIt-Anchor" href="#121-概念"></a> 1.2.1. 概念</h4>
<p>跨站请求伪造（Cross-site request forgery，CSRF），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<h4 id="122-攻击手段和目的"><a class="markdownIt-Anchor" href="#122-攻击手段和目的"></a> 1.2.2. 攻击手段和目的</h4>
<p>可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。</p>
<p>CSRF 能做的事太多：</p>
<ul>
<li>以你名义发送邮件，发消息</li>
<li>用你的账号购买商品</li>
<li>用你的名义完成虚拟货币转账</li>
<li>泄露个人隐私</li>
<li>…</li>
</ul>
<h4 id="123-应对手段"><a class="markdownIt-Anchor" href="#123-应对手段"></a> 1.2.3. 应对手段</h4>
<ul>
<li><strong>表单 Token</strong> - CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。</li>
<li><strong>验证码</strong> - 请求提交是，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。</li>
<li><strong>Referer check</strong> - HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
</ul>
</blockquote>
<h3 id="13-sql-注入攻击"><a class="markdownIt-Anchor" href="#13-sql-注入攻击"></a> 1.3. SQL 注入攻击</h3>
<h4 id="131-概念"><a class="markdownIt-Anchor" href="#131-概念"></a> 1.3.1. 概念</h4>
<p>SQL 注入攻击（SQL injection），是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p>
<p>攻击示例：</p>
<p>考虑以下简单的登录表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们的处理里面的 SQL 可能是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">username:=r.Form.Get("username")</span><br><span class="line">password:=r.Form.Get("password")</span><br><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'"+username+"'</span> <span class="keyword">AND</span> <span class="keyword">password</span>=<span class="string">'"+password+"'</span><span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>如果用户的输入的用户名如下，密码任意</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">myuser' or 'foo' = 'foo' <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>那么我们的 SQL 变成了如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username=<span class="string">'myuser'</span> <span class="keyword">or</span> <span class="string">'foo'</span> = <span class="string">'foo'</span> <span class="comment">--'' AND password='xxx'</span></span><br></pre></td></tr></table></figure>
<p>在 SQL 里面 <code>--</code> 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p>
<p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%"+prod+"%'</span><span class="string">"</span></span><br><span class="line"><span class="string">Db.Exec(sql)</span></span><br></pre></td></tr></table></figure>
<p>如果攻击提交 <code>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</code> 作为变量 prod 的值，那么 sql 将会变成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql:="<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%a%'</span> exec master..xp_cmdshell <span class="string">'net user test testpass /ADD'</span><span class="comment">--%'"</span></span><br></pre></td></tr></table></figure>
<p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p>
<p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p>
<h4 id="132-攻击手段和目的"><a class="markdownIt-Anchor" href="#132-攻击手段和目的"></a> 1.3.2. 攻击手段和目的</h4>
<ul>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如 <code>SELECT * FROM sys.tables</code>）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如 <code>ALTER LOGIN sa WITH PASSWORD='xxxxxx'</code>）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell &quot;net stop iisadmin&quot;可停止服务器的 IIS 服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。</li>
</ul>
<h4 id="133-应对手段"><a class="markdownIt-Anchor" href="#133-应对手段"></a> 1.3.3. 应对手段</h4>
<ul>
<li><strong>使用参数化查询</strong> - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database/sql 里面的查询函数 <code>Prepare</code> 和 <code>Query</code> ，或者 <code>Exec(query string, args ...interface{})</code>。</li>
<li><strong>单引号转换</strong> - 在组合 SQL 字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续 2 个单引号字符）。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
</ul>
</blockquote>
<h3 id="14-拒绝服务攻击dos"><a class="markdownIt-Anchor" href="#14-拒绝服务攻击dos"></a> 1.4. 拒绝服务攻击（DoS）</h3>
<p>拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。</p>
<h4 id="141-攻击方式"><a class="markdownIt-Anchor" href="#141-攻击方式"></a> 1.4.1. 攻击方式</h4>
<ul>
<li>带宽消耗型攻击</li>
<li>资源消耗型攻击</li>
</ul>
<h4 id="142-应对手段"><a class="markdownIt-Anchor" href="#142-应对手段"></a> 1.4.2. 应对手段</h4>
<ul>
<li>防火墙 - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。</li>
<li>路由器、交换机 - 具有速度限制和访问控制能力。</li>
<li>流量清洗 - 通过采用抗 DDoS 软件处理，将正常流量和恶意流量区分开。</li>
</ul>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
</ul>
</blockquote>
<h2 id="2-加密技术及密钥安全管理"><a class="markdownIt-Anchor" href="#2-加密技术及密钥安全管理"></a> 2. 加密技术及密钥安全管理</h2>
<p>对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。</p>
<p>信息加密技术一般分为：</p>
<ul>
<li>消息摘要</li>
<li>加密算法
<ul>
<li>对称加密</li>
<li>非对称加密</li>
</ul>
</li>
<li>证书</li>
</ul>
<h3 id="21-消息摘要"><a class="markdownIt-Anchor" href="#21-消息摘要"></a> 2.1. 消息摘要</h3>
<p>常用数字签名算法：MD5、SHA 等。</p>
<p>应用场景：将用户密码以消息摘要形式保存到数据库中。</p>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/javacore/blob/master/docs/advanced/encode/java-message-digest.md" target="_blank" rel="noopener">消息摘要</a></li>
</ul>
</blockquote>
<h3 id="22-加密算法"><a class="markdownIt-Anchor" href="#22-加密算法"></a> 2.2. 加密算法</h3>
<h4 id="221-对称加密"><a class="markdownIt-Anchor" href="#221-对称加密"></a> 2.2.1. 对称加密</h4>
<p>对称加密指加密和解密所使用的密钥是同一个密钥。</p>
<p>常用对称加密算法：DES 等。</p>
<p>应用场景：Cookie 加密、通信机密等。</p>
<h4 id="222-非对称加密"><a class="markdownIt-Anchor" href="#222-非对称加密"></a> 2.2.2. 非对称加密</h4>
<p>非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。</p>
<p>常用非对称加密算法：RSA 等。</p>
<p>应用场景：HTTPS 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。</p>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://github.com/dunwu/javacore/blob/master/docs/advanced/encode/java-encryption.md" target="_blank" rel="noopener">加密</a></li>
</ul>
</blockquote>
<h4 id="223-密钥安全管理"><a class="markdownIt-Anchor" href="#223-密钥安全管理"></a> 2.2.3. 密钥安全管理</h4>
<p>保证密钥安全的方法：</p>
<ol>
<li>把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。</li>
<li>把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。</li>
</ol>
<h3 id="23-证书"><a class="markdownIt-Anchor" href="#23-证书"></a> 2.3. 证书</h3>
<p>证书可以称为信息安全加密的终极手段。公开密钥认证（英语：Public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。</p>
<p>透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 TLS 实现并在万维网的 HTTP 以 HTTPS、在电子邮件的 SMTP 以 STARTTLS 引入并广泛应用。</p>
<p>众所周知，常见的应用层协议 HTTP、FTP、Telnet 本身不保证信息安全。但是加入了 SSL/TLS 加密数据包机制的 HTTPS、FTPS、Telnets 是信息安全的。</p>
<h4 id="231-概念"><a class="markdownIt-Anchor" href="#231-概念"></a> 2.3.1. 概念</h4>
<p>传输层安全性协议（Transport Layer Security, TLS），及其前身安全套接层（Secure Sockets Layer, SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。</p>
<h4 id="232-证书原理"><a class="markdownIt-Anchor" href="#232-证书原理"></a> 2.3.2. 证书原理</h4>
<p>SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>这里有两个问题：</p>
<p>（1）<strong>如何保证公钥不被篡改？</strong></p>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<p>（2）<strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p>
<p>SSL/TLS 协议的基本过程是这样的：</p>
<ol>
<li>客户端向服务器端索要并验证公钥。</li>
<li>双方协商生成&quot;对话密钥&quot;。</li>
<li>双方采用&quot;对话密钥&quot;进行加密通信。</li>
</ol>
<blockquote>
<p>👉 参考阅读：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
</ul>
</blockquote>
<h2 id="3-资料"><a class="markdownIt-Anchor" href="#3-资料"></a> 3. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">Wiki 词条 - 跨站脚本</a></li>
<li><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">Web 安全测试之 XSS</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">Wiki 词条 - 跨站请求伪造</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈 CSRF 攻击方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">「每日一题」CSRF 是什么？</a></li>
<li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB 安全之-CSRF（跨站请求伪造）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">Wiki 词条 - SQL 注入攻击</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">避免 SQL 注入</a></li>
<li><a href="http://blog.jobbole.com/83092/" target="_blank" rel="noopener">实例讲解 SQL 注入攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">拒绝服务攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公开密钥认证</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">网站的可扩展架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 16:36:22" itemprop="dateModified" datetime="2019-11-27T16:36:22+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/网站的可扩展架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网站的可扩展架构"><a class="markdownIt-Anchor" href="#网站的可扩展架构"></a> 网站的可扩展架构</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84">1. 构建可扩展的网站架构</a></li>
<li><a href="#2-%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E6%80%A7">2. 利用分布式消息队列降低系统耦合性</a>
<ul>
<li><a href="#21-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84">2.1. 事件驱动架构</a></li>
<li><a href="#22-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">2.2. 分布式消息队列</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%89%93%E9%80%A0%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%B9%B3%E5%8F%B0">3. 利用分布式服务打造可复用的业务平台</a></li>
<li><a href="#4-%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4. 可扩展的数据结构</a></li>
<li><a href="#5-%E8%B5%84%E6%96%99">5. 资料</a></li>
</ul>
<!-- /TOC -->
<p><strong>扩展性（Extensibility）</strong> - 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则（对扩展开放、对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。</p>
<p><strong>伸缩性（Scalability）</strong> - 指系统能够通过增加减少自身资源规模的方式增减自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中 ，通常指利用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。</p>
<h2 id="1-构建可扩展的网站架构"><a class="markdownIt-Anchor" href="#1-构建可扩展的网站架构"></a> 1. 构建可扩展的网站架构</h2>
<p>低耦合的系统更容易扩展、复用。</p>
<p>设计网站可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性。</p>
<p>分层和分割不仅可以进行架构伸缩，也是模块化设计的重要手段，利用分层和分割的方式将软件分割为若干个低耦合的独立的组件模块，这些组件模块以消息传递及依赖调用的方式聚合成一个完整的系统。</p>
<p>在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器上，从物理上分离模块间的耦合关系，进一步降低耦合性提高复用性。</p>
<h2 id="2-利用分布式消息队列降低系统耦合性"><a class="markdownIt-Anchor" href="#2-利用分布式消息队列降低系统耦合性"></a> 2. 利用分布式消息队列降低系统耦合性</h2>
<h3 id="21-事件驱动架构"><a class="markdownIt-Anchor" href="#21-事件驱动架构"></a> 2.1. 事件驱动架构</h3>
<p>事件驱动架构通过在低耦合的模块间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作。典型的事件驱动架构就是操作系统中常见的生产者消费者模式。在大型网站中，最常见的实现手段就是分布式消息队列。</p>
<h3 id="22-分布式消息队列"><a class="markdownIt-Anchor" href="#22-分布式消息队列"></a> 2.2. 分布式消息队列</h3>
<p>消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后立即返回成功响应给消息生产者。消息队列服务器根据消息订阅列表查找订阅该消息的消息消费者应用程序，将消息队列中的消息按照先进先出（FIFO）的原则将消息通过远程通信接口发送给消息消费者程序。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/java/javaweb/architecture/分布式消息队列架构原理.png!zp" />
</div>
<p>在伸缩性方面，由于消息队列服务器上的数据可以看作是即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可。</p>
<p>在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完成以后，将磁盘内容加载到内存队列继续处理。</p>
<h2 id="3-利用分布式服务打造可复用的业务平台"><a class="markdownIt-Anchor" href="#3-利用分布式服务打造可复用的业务平台"></a> 3. 利用分布式服务打造可复用的业务平台</h2>
<p>分布式服务则通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。</p>
<p>大型网站分布式服务的需求与特点：</p>
<ul>
<li>负载均衡</li>
<li>失效转移</li>
<li>高效的远程通信</li>
<li>整合异构系统</li>
<li>对应用最少侵入</li>
<li>版本管理</li>
<li>实时监控</li>
</ul>
<h2 id="4-可扩展的数据结构"><a class="markdownIt-Anchor" href="#4-可扩展的数据结构"></a> 4. 可扩展的数据结构</h2>
<p>传统的关系型数据库为了保证关系运算的正确性，在设计数据库表结构的时候，就需要指定表的 schema ——字段名称，数据类型等，并要遵循特定的设计范式。这些规范带来一个问题：难以面对需求变更带来的挑战，所以有人通过预先设计一些冗余字段来应对。</p>
<p>许多 NoSql 数据库使用 ColumnFamily 设计来设计可扩展的数据结构。</p>
<h2 id="5-资料"><a class="markdownIt-Anchor" href="#5-资料"></a> 5. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E7%BD%91%E7%AB%99%E5%85%B8%E5%9E%8B%E6%95%85%E9%9A%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E5%85%B8%E5%9E%8B%E6%95%85%E9%9A%9C/" class="post-title-link" itemprop="url">网站典型故障</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-27 16:36:22" itemprop="dateModified" datetime="2019-11-27T16:36:22+08:00">2019-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E7%BD%91%E7%AB%99%E5%85%B8%E5%9E%8B%E6%95%85%E9%9A%9C/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/网站典型故障/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>786</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网站典型故障"><a class="markdownIt-Anchor" href="#网站典型故障"></a> 网站典型故障</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E8%80%97%E5%B0%BD%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E9%9A%9C">1. 海量日志耗尽磁盘空间引发的故障</a></li>
<li><a href="#2-%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E9%9A%9C">2. 高并发访问数据库引发的故障</a></li>
<li><a href="#3-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8B%E9%94%81%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E9%9A%9C">3. 高并发情况下锁引发的故障</a></li>
<li><a href="#4-%E7%BC%93%E5%AD%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E9%9A%9C">4. 缓存引发的故障</a></li>
<li><a href="#5-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%B8%8D%E5%90%8C%E6%AD%A5%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E9%9A%9C">5. 应用启动不同步引发的故障</a></li>
<li><a href="#6-%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%8B%AC%E5%8D%A0%E7%A3%81%E7%9B%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E9%9A%9C">6. 大文件读写独占磁盘引发的故障</a></li>
<li><a href="#7-%E8%B5%84%E6%96%99">7. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-海量日志耗尽磁盘空间引发的故障"><a class="markdownIt-Anchor" href="#1-海量日志耗尽磁盘空间引发的故障"></a> 1. 海量日志耗尽磁盘空间引发的故障</h2>
<p>现象：应用发布后，硬盘空间低于警戒值，服务器宕机。<br />
分析：应用部署在服务器上，不断打印日志，但不定期清理日志，导致磁盘空间最终被耗尽。<br />
总结：</p>
<ul>
<li>应用自身的日志和第三方组件日志应分别配置。</li>
<li>日志输出级别不要设置太低，导致打印很多无关痛痒的信息。</li>
</ul>
<h2 id="2-高并发访问数据库引发的故障"><a class="markdownIt-Anchor" href="#2-高并发访问数据库引发的故障"></a> 2. 高并发访问数据库引发的故障</h2>
<p>现象：数据库负载居高不下。<br />
分析：某条 sql 执行频率非常高，追查发现，被网站首页调用。<br />
总结：首页不应该访问数据库。</p>
<h2 id="3-高并发情况下锁引发的故障"><a class="markdownIt-Anchor" href="#3-高并发情况下锁引发的故障"></a> 3. 高并发情况下锁引发的故障</h2>
<p>现象：应用不定时地因为响应超时而报警，但是很快又超时接触，恢复正常。<br />
分析：某个单例对象中多处使用了 synchronized，由于 this 对象只有一个，所有的并发请求都要排队获得者唯一的一把锁。<br />
总结：使用锁操作要谨慎。</p>
<h2 id="4-缓存引发的故障"><a class="markdownIt-Anchor" href="#4-缓存引发的故障"></a> 4. 缓存引发的故障</h2>
<p>现象：没有新应用发布，但是数据库突然负载飙升，并很快失去响应。<br />
分析：缓存服务器管理失当。<br />
总结：当网站架构对缓存依赖性很强时，应该重视对缓存服务的管理。</p>
<h2 id="5-应用启动不同步引发的故障"><a class="markdownIt-Anchor" href="#5-应用启动不同步引发的故障"></a> 5. 应用启动不同步引发的故障</h2>
<p>现象：某应用发布后，服务器立即崩溃。<br />
分析：后台服务还没准备好，前台应用就开始接受请求，导致故障。<br />
总结：发布脚本中不断用 curl 命令访问后台应用特定页面，直到收到 OK，再启动前台应用。</p>
<h2 id="6-大文件读写独占磁盘引发的故障"><a class="markdownIt-Anchor" href="#6-大文件读写独占磁盘引发的故障"></a> 6. 大文件读写独占磁盘引发的故障</h2>
<p>现象：上传图片非常慢。<br />
分析：文件存储最有可能出错的地方是存储服务器。检查发现，大部分文件大小比较小，少数几个文件非常大，读写大文件比较耗时，在这个读写时间内，磁盘基本被大文件操作独占，导致其他用户的文件操作缓慢。<br />
总结：文件存储下需要根据不同文件类型和用途进行管理。</p>
<h2 id="7-资料"><a class="markdownIt-Anchor" href="#7-资料"></a> 7. 资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">大型网站技术架构</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog/page/7/">7</a><a class="extend next" rel="next" href="/blog/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">354k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:22</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>
<script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script>
<script src="/blog/js/schemes/pisces.js"></script>
<script src="/blog/js/next-boot.js"></script><script src="/blog/js/bookmark.js"></script>



  




  <script src="/blog/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
