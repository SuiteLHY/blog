<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&amp;apos;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https:&#x2F;&#x2F;dunwu.github.io&#x2F;blog&#x2F;page&#x2F;4&#x2F;index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&amp;apos;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">34</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">68</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF/" class="post-title-link" itemprop="url">代码坏味道之代码臃肿</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-21 13:20:27" itemprop="dateModified" datetime="2019-08-21T13:20:27+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/refactor/" itemprop="url" rel="index">
                    <span itemprop="name">refactor</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/refactor/代码坏味道之代码臃肿/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码坏味道之代码臃肿"><a class="markdownIt-Anchor" href="#代码坏味道之代码臃肿"></a> 代码坏味道之代码臃肿</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/bloaters" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/bloaters</a></p>
</blockquote>
<blockquote>
<p><strong>代码臃肿(Bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%81%8F%E6%89%A7">基本类型偏执</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%B3%A5%E5%9B%A2">数据泥团</a></li>
<li><a href="#%E8%BF%87%E5%A4%A7%E7%9A%84%E7%B1%BB">过大的类</a></li>
<li><a href="#%E8%BF%87%E9%95%BF%E5%87%BD%E6%95%B0">过长函数</a></li>
<li><a href="#%E8%BF%87%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97">过长参数列</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="基本类型偏执"><a class="markdownIt-Anchor" href="#基本类型偏执"></a> 基本类型偏执</h2>
<blockquote>
<p>基本类型偏执(Primitive Obsession)</p>
<ul>
<li>使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。</li>
<li>使用常量编码信息（例如一个用于引用管理员权限的常量<code>USER_ADMIN_ROLE = 1</code> ）。</li>
<li>使用字符串常量作为字段名在数组中使用。</li>
</ul>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/primitive-obsession-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>类似其他大部分坏味道，基本类型偏执诞生于类初建的时候。一开始，可能只是不多的字段，随着表示的特性越来越多，基本数据类型字段也越来越多。</p>
<p>基本类型常常被用于表示模型的类型。你有一组数字或字符串用来表示某个实体。</p>
<p>还有一个场景：在模拟场景，大量的字符串常量被用于数组的索引。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/primitive-obsession-2.png"/></div>
<p>大多数编程语言都支持基本数据类型和结构类型（类、结构体等）。结构类型允许程序员将基本数据类型组织起来，以代表某一事物的模型。</p>
<p>基本数据类型可以看成是机构类型的积木块。当基本数据类型数量成规模后，将它们有组织地结合起来，可以更方便的管理这些数据。</p>
<ul>
<li>如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 <code>以类取代类型码(Replace Type Code with Class)</code> 。</li>
<li>如果基本数据类型字段的值是用于方法的参数，可以使用 <code>引入参数对象(Introduce Parameter Object)</code> 或 <code>保持对象完整(Preserve Whole Object)</code> 。</li>
<li>如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 <code>以类取代类型码(Replace Type Code with Class)</code> 将它替换掉。如果你有与类型码相关的条件表达式，可运用 <code>以子类取代类型码(Replace Type Code with Subclass)</code> 或 <code>以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</code> 加以处理。</li>
<li>如果你发现自己正从数组中挑选数据，可运用 <code>以对象取代数组(Replace Array with Object)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>多亏了使用对象替代基本数据类型，使得代码变得更加灵活。</li>
<li>代码变得更加易读和更加有组织。特殊数据可以集中进行操作，而不像之前那样分散。不用再猜测这些陌生的常量的意义以及它们为什么在数组中。</li>
<li>更容易发现重复代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/primitive-obsession-3.png"/></div>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="以类取代类型码replace-type-code-with-class"><a class="markdownIt-Anchor" href="#以类取代类型码replace-type-code-with-class"></a> 以类取代类型码(Replace Type Code with Class)</h4>
<p><strong>问题</strong></p>
<p>类之中有一个数值类型码，但它并不影响类的行为。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个新的类替换该数值类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-class-after.png"/></div>
<h4 id="引入参数对象introduce-parameter-object"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h4 id="保持对象完整preserve-whole-object"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h4 id="以子类取代类型码replace-type-code-with-subclass"><a class="markdownIt-Anchor" href="#以子类取代类型码replace-type-code-with-subclass"></a> 以子类取代类型码(Replace Type Code with Subclass)</h4>
<p><strong>问题</strong></p>
<p>你有一个不可变的类型码，它会影响类的行为。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-before.png"/></div>
<p><strong>解决</strong></p>
<p>以子类取代这个类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-after.png"/></div>
<h4 id="以状态策略模式取代类型码replace-type-code-with-statestrategy"><a class="markdownIt-Anchor" href="#以状态策略模式取代类型码replace-type-code-with-statestrategy"></a> 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</h4>
<p><strong>问题</strong></p>
<p>你有一个类型码，它会影响类的行为，但你无法通过继承消除它。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-before.png"/></div>
<p><strong>解决</strong></p>
<p>以状态对象取代类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-after.png"/></div>
<h4 id="以对象取代数组replace-array-with-object"><a class="markdownIt-Anchor" href="#以对象取代数组replace-array-with-object"></a> 以对象取代数组(Replace Array with Object)</h4>
<p><strong>问题</strong></p>
<p>你有一个数组，其中的元素各自代表不同的东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">row[<span class="number">0</span>] = <span class="string">"Liverpool"</span>;</span><br><span class="line">row[<span class="number">1</span>] = <span class="string">"15"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>以对象替换数组。对于数组中的每个元素，以一个字段来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Performance row = <span class="keyword">new</span> Performance();</span><br><span class="line">row.setName(<span class="string">"Liverpool"</span>);</span><br><span class="line">row.setWins(<span class="string">"15"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="数据泥团"><a class="markdownIt-Anchor" href="#数据泥团"></a> 数据泥团</h2>
<blockquote>
<p>数据泥团(Data Clumps)</p>
<p>有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-clumps-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>通常，数据泥团的出现时因为糟糕的编程结构或“复制-粘贴式编程”。</p>
<p>有一个判断是否是数据泥团的好办法：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新的对象。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>首先找出这些数据以字段形式出现的地方，运用 <code>提炼类(Extract Class)</code> 将它们提炼到一个独立对象中。</li>
<li>如果数据泥团在函数的参数列中出现，运用 <code>引入参数对象(Introduce Parameter Object)</code> 将它们组织成一个类。</li>
<li>如果数据泥团的部分数据出现在其他函数中，考虑运用 <code>保持对象完整(Preserve Whole Object)</code> 将整个数据对象传入到函数中。</li>
<li>检视一下使用这些字段的代码，也许，将它们移入一个数据类是个不错的主意。</li>
</ul>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>提高代码易读性和组织性。对于特殊数据的操作，可以集中进行处理，而不像以前那样分散。</li>
<li>减少代码量。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-clumps-3.png"/></div>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>有时为了对象中的部分数据而将整个对象作为参数传递给函数，可能会产生让两个类之间不收欢迎的依赖关系，这中情况下可以不传递整个对象。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="引入参数对象introduce-parameter-object-2"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object-2"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h4 id="保持对象完整preserve-whole-object-2"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object-2"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h2 id="过大的类"><a class="markdownIt-Anchor" href="#过大的类"></a> 过大的类</h2>
<blockquote>
<p>过大的类(Large Class)</p>
<p>一个类含有过多字段、函数、代码行。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/large-class-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>类通常一开始很小，但是随着程序的增长而逐渐膨胀。</p>
<p>类似于过长函数，程序员通常觉得在一个现存类中添加新特性比创建一个新的类要容易。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<p>设计模式中有一条重要原则：职责单一原则。一个类应该只赋予它一个职责。如果它所承担的职责太多，就该考虑为它减减负。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/large-class-2.png"/></div>
<ul>
<li>如果过大类中的部分行为可以提炼到一个独立的组件中，可以使用 <code>提炼类(Extract Class)</code>。</li>
<li>如果过大类中的部分行为可以用不同方式实现或使用于特殊场景，可以使用 <code>提炼子类(Extract Subclass)</code>。</li>
<li>如果有必要为客户端提供一组操作和行为，可以使用 <code>提炼接口(Extract Interface)</code>。</li>
<li>如果你的过大类是个 GUI 类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持两边同步。 <code>复制被监视数据(Duplicate Observed Data)</code> 可以告诉你怎么做。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>重构过大的类可以使程序员不必记住一个类中大量的属性。</li>
<li>在大多数情况下，分割过大的类可以避免代码和功能的重复。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/large-class-3.png"/></div>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class-2"><a class="markdownIt-Anchor" href="#提炼类extract-class-2"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="提炼子类extract-subclass"><a class="markdownIt-Anchor" href="#提炼子类extract-subclass"></a> 提炼子类(Extract Subclass)</h4>
<p><strong>问题</strong></p>
<p>一个类中有些特性仅用于特定场景。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-subclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>创建一个子类，并将用于特殊场景的特性置入其中。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-subclass-after.png"/></div>
<h4 id="提炼接口extract-interface"><a class="markdownIt-Anchor" href="#提炼接口extract-interface"></a> 提炼接口(Extract Interface)</h4>
<p><strong>问题</strong></p>
<p>多个客户端使用一个类部分相同的函数。另一个场景是两个类中的部分函数相同。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-interface-before.png"/></div>
<p><strong>解决</strong></p>
<p>移动相同的部分函数到接口中。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-interface-after.png"/></div>
<h4 id="复制被监视数据duplicate-observed-data"><a class="markdownIt-Anchor" href="#复制被监视数据duplicate-observed-data"></a> 复制被监视数据(Duplicate Observed Data)</h4>
<p><strong>问题</strong></p>
<p>如果存储在类中的数据是负责 GUI 的。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-observed-data-before.png"/></div>
<p><strong>解决</strong></p>
<p>一个比较好的方法是将负责 GUI 的数据放入一个独立的类，以确保 GUI 数据与域类之间的连接和同步。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-observed-data-after.png"/></div>
<h2 id="过长函数"><a class="markdownIt-Anchor" href="#过长函数"></a> 过长函数</h2>
<blockquote>
<p>过长函数(Long Method)</p>
<p>一个函数含有太多行代码。一般来说，任何函数超过 10 行时，你就可以考虑是不是过长了。<br />
函数中的代码行数原则上不要超过 100 行。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-method-1.png"/></div>
<h3 id="问题的原因"><a class="markdownIt-Anchor" href="#问题的原因"></a> 问题的原因</h3>
<p>通常情况下，创建一个新函数的难度要大于添加功能到一个已存在的函数。大部分人都觉得：“我就添加这么两行代码，为此新建一个函数实在是小题大做了。”于是，张三加两行，李四加两行，王五加两行。。。函数日益庞大，最终烂的像一锅浆糊，再也没人能完全看懂了。于是大家就更不敢轻易动这个函数了，只能恶性循环的往其中添加代码。所以，如果你看到一个超过 200 行的函数，通常都是多个程序员东拼西凑出来的。</p>
<h3 id="解决函数"><a class="markdownIt-Anchor" href="#解决函数"></a> 解决函数</h3>
<p>一个很好的技巧是：<strong>寻找注释</strong>。添加注释，一般有这么几个原因：代码逻辑较为晦涩或复杂；这段代码功能相对独立；特殊处理。<br />
如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-method-2.png"/></div>
<ul>
<li>为了给一个函数瘦身，可以使用 <code>提炼函数(Extract Method)</code>。</li>
<li>如果局部变量和参数干扰提炼函数，可以使用 <code>以查询取代临时变量(Replace Temp with Query)</code>，<code>引入参数对象(Introduce Parameter Object)</code> 或 <code>保持对象完整(Preserve Whole Object)</code> 。</li>
<li>如果前面两条没有帮助，可以通过 <code>以函数对象取代函数(Replace Method with Method Object)</code> 尝试移动整个函数到一个独立的对象中。</li>
<li>条件表达式和循环常常也是提炼的信号。对于条件表达式，可以使用 <code>分解条件表达式(Decompose Conditional)</code> 。至于循环，应该使用 <code>提炼函数(Extract Method)</code> 将循环和其内的代码提炼到独立函数中。</li>
</ul>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>在所有类型的面向对象代码中，函数比较短小精悍的类往往生命周期较长。一个函数越长，就越不容易理解和维护。</li>
<li>此外，过长函数中往往含有难以发现的重复代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-method-3.png"/></div>
<h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3>
<p>是否像许多人说的那样，增加函数的数量会影响性能？在几乎绝大多数情况下，这种影响是可以忽略不计，所以不用担心。<br />
此外，现在有了清晰和易读的代码，在需要的时候，你将更容易找到真正有效的函数来重组代码和提高性能。</p>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="以查询取代临时变量replace-temp-with-query"><a class="markdownIt-Anchor" href="#以查询取代临时变量replace-temp-with-query"></a> 以查询取代临时变量(Replace Temp with Query)</h4>
<p><strong>问题</strong></p>
<p>将表达式的结果放在局部变量中，然后在代码中使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculateTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> basePrice = quantity * itemPrice;</span><br><span class="line">  <span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将整个表达式移动到一个独立的函数中并返回结果。使用查询函数来替代使用变量。如果需要，可以在其他函数中合并新函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculateTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> quantity * itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入参数对象introduce-parameter-object-3"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object-3"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h4 id="保持对象完整preserve-whole-object-3"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object-3"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h4 id="以函数对象取代函数replace-method-with-method-object"><a class="markdownIt-Anchor" href="#以函数对象取代函数replace-method-with-method-object"></a> 以函数对象取代函数(Replace Method with Method Object)</h4>
<p><strong>问题</strong></p>
<p>你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator(<span class="keyword">this</span>).compute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriceCalculator</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// copy relevant information from order object.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分解条件表达式decompose-conditional"><a class="markdownIt-Anchor" href="#分解条件表达式decompose-conditional"></a> 分解条件表达式(Decompose Conditional)</h4>
<p><strong>问题</strong></p>
<p>你有复杂的条件表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.before(SUMMER_START) || date.after(SUMMER_END)) &#123;</span><br><span class="line">  charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>根据条件分支将整个条件表达式分解成几个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (notSummer(date)) &#123;</span><br><span class="line">  charge = winterCharge(quantity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = summerCharge(quantity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过长参数列"><a class="markdownIt-Anchor" href="#过长参数列"></a> 过长参数列</h2>
<blockquote>
<p>过长参数列(Long Parameter List)</p>
<p>一个函数有超过 3、4 个入参。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-parameter-list-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>过长参数列可能是将多个算法并到一个函数中时发生的。函数中的入参可以用来控制最终选用哪个算法去执行。</p>
<p>过长参数列也可能是解耦类之间依赖关系时的副产品。例如，用于创建函数中所需的特定对象的代码已从函数移动到调用函数的代码处，但创建的对象是作为参数传递到函数中。因此，原始类不再知道对象之间的关系，并且依赖性也已经减少。但是如果创建的这些对象，每一个都将需要它自己的参数，这意味着过长参数列。</p>
<p>太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦需要更多数据，就不得不修改它。</p>
<h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/long-parameter-list-2.png"/></div>
<ul>
<li>如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用 <code>以函数取代参数(Replace Parameter with Methods)</code> 。在这里，，“已有的对象”可能是函数所属类里的一个字段，也可能是另一个参数。</li>
<li>你还可以运用 <code>保持对象完整(Preserve Whole Object)</code> 将来自同一对象的一堆数据收集起来，并以该对象替换它们。</li>
<li>如果某些数据缺乏合理的对象归属，可使用 <code>引入参数对象(Introduce Parameter Object)</code> 为它们制造出一个“参数对象”。</li>
</ul>
<h3 id="收益-5"><a class="markdownIt-Anchor" href="#收益-5"></a> 收益</h3>
<ul>
<li>更易读，更简短的代码。</li>
<li>重构可能会暴露出之前未注意到的重复代码。</li>
</ul>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<ul>
<li>这里有一个重要的例外：有时候你明显不想造成&quot;被调用对象&quot;与&quot;较大对象&quot;间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。</li>
</ul>
<h3 id="重构方法说明-5"><a class="markdownIt-Anchor" href="#重构方法说明-5"></a> 重构方法说明</h3>
<h4 id="以函数取代参数replace-parameter-with-methods"><a class="markdownIt-Anchor" href="#以函数取代参数replace-parameter-with-methods"></a> 以函数取代参数(Replace Parameter with Methods)</h4>
<p><strong>问题</strong></p>
<p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> seasonDiscount = <span class="keyword">this</span>.getSeasonalDiscount();</span><br><span class="line"><span class="keyword">double</span> fees = <span class="keyword">this</span>.getFees();</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice, seasonDiscount, fees);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>让参数接受者去除该项参数，并直接调用前一个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice);</span><br></pre></td></tr></table></figure>
<h4 id="保持对象完整preserve-whole-object-4"><a class="markdownIt-Anchor" href="#保持对象完整preserve-whole-object-4"></a> 保持对象完整(Preserve Whole Object)</h4>
<p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h4 id="引入参数对象introduce-parameter-object-4"><a class="markdownIt-Anchor" href="#引入参数对象introduce-parameter-object-4"></a> 引入参数对象(Introduce Parameter Object)</h4>
<p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-before.png"/></div>
<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-parameter-object-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88/" class="post-title-link" itemprop="url">代码坏味道之耦合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-21 13:20:31" itemprop="dateModified" datetime="2019-08-21T13:20:31+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/refactor/" itemprop="url" rel="index">
                    <span itemprop="name">refactor</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/refactor/代码坏味道之耦合/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码坏味道之耦合"><a class="markdownIt-Anchor" href="#代码坏味道之耦合"></a> 代码坏味道之耦合</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/couplers" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/couplers</a></p>
</blockquote>
<blockquote>
<p><strong>耦合(Couplers)这组坏味道意味着：不同类之间过度耦合。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#%E4%B8%8D%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%BA%93%E7%B1%BB">不完美的库类</a></li>
<li><a href="#%E4%B8%AD%E9%97%B4%E4%BA%BA">中间人</a></li>
<li><a href="#%E4%BE%9D%E6%81%8B%E6%83%85%E7%BB%93">依恋情结</a></li>
<li><a href="#%E7%8B%8E%E6%98%B5%E5%85%B3%E7%B3%BB">狎昵关系</a></li>
<li><a href="#%E8%BF%87%E5%BA%A6%E8%80%A6%E5%90%88%E7%9A%84%E6%B6%88%E6%81%AF%E9%93%BE">过度耦合的消息链</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="不完美的库类"><a class="markdownIt-Anchor" href="#不完美的库类"></a> 不完美的库类</h2>
<blockquote>
<p>不完美的库类(Incomplete Library Class)</p>
<p>当一个类库已经不能满足实际需要时，你就不得不改变这个库（如果这个库是只读的，那就没辙了）。</p>
</blockquote>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>许多编程技术都建立在库类的基础上。库类的作者没用未卜先知的能力，不能因此责怪他们。麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类以满足我们的需要。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>如果你只想修改类库的一两个函数，可以运用 <code>引入外加函数(Introduce Foreign Method)</code>；</li>
<li>如果想要添加一大堆额外行为，就得运用 <code>引入本地扩展(Introduce Local Extension)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>减少代码重复（你不用一言不合就自己动手实现一个库的全部功能，代价太高）</li>
</ul>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>如果扩展库会带来额外的工作量。</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="引入外加函数introduce-foreign-method"><a class="markdownIt-Anchor" href="#引入外加函数introduce-foreign-method"></a> 引入外加函数(Introduce Foreign Method)</h4>
<p><strong>问题</strong></p>
<p>你需要为提供服务的类增加一个函数，但你无法修改这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date nextDay = <span class="keyword">new</span> Date(previousEnd.getYear(),</span><br><span class="line">      previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在客户类中建立一个函数，并一个第一个参数形式传入一个服务类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date newStart = nextDay(previousEnd);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入本地扩展introduce-local-extension"><a class="markdownIt-Anchor" href="#引入本地扩展introduce-local-extension"></a> 引入本地扩展(Introduce Local Extension)</h4>
<p><strong>问题</strong></p>
<p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-local-extension-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/introduce-local-extension-after.png"/></div>
<h2 id="中间人"><a class="markdownIt-Anchor" href="#中间人"></a> 中间人</h2>
<blockquote>
<p>中间人(Middle Man)</p>
<p>如果一个类的作用仅仅是指向另一个类的委托，为什么要存在呢？</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/middle-man-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>对象的基本特征之一就是封装：对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。比如，你也许会看到一个类的大部分有用工作都委托给了其他类，类本身成了一个空壳，除了委托之外不做任何事情。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<p>应该运用 <code>移除中间人(Remove Middle Man)</code>，直接和真正负责的对象打交道。</p>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>减少笨重的代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/middle-man-2.png"/></div>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<p>如果是以下情况，不要删除已创建的中间人：</p>
<ul>
<li>添加中间人是为了避免类之间依赖关系。</li>
<li>一些设计模式有目的地创建中间人（例如代理模式和装饰器模式）。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="移除中间人remove-middle-man"><a class="markdownIt-Anchor" href="#移除中间人remove-middle-man"></a> 移除中间人(Remove Middle Man)</h4>
<p><strong>问题</strong></p>
<p>某个类做了过多的简单委托动作。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-middle-man-before.png"/></div>
<p><strong>解决</strong></p>
<p>让客户直接调用委托类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-middle-man-after.png"/></div>
<h2 id="依恋情结"><a class="markdownIt-Anchor" href="#依恋情结"></a> 依恋情结</h2>
<blockquote>
<p>依恋情结(Feature Envy)</p>
<p>一个函数访问其它对象的数据比访问自己的数据更多。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/feature-envy-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>这种气味可能发生在字段移动到数据类之后。如果是这种情况，你可能想将数据类的操作移动到这个类中。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<p>As a basic rule, if things change at the same time, you should keep them in the same place. Usually data and functions that use this data are changed together (although exceptions are possible).</p>
<p>有一个基本原则：同时会发生改变的事情应该被放在同一个地方。通常，数据和使用这些数据的函数是一起改变的。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/feature-envy-2.png"/></div>
<ul>
<li>如果一个函数明显应该被移到另一个地方，可运用 <code>搬移函数(Move Method)</code> 。</li>
<li>如果仅仅是函数的部分代码访问另一个对象的数据，运用 <code>提炼函数(Extract Method)</code> 将这部分代码移到独立的函数中。</li>
<li>如果一个方法使用来自其他几个类的函数，首先确定哪个类包含大多数使用的数据。然后，将该方法与其他数据一起放在此类中。或者，使用 <code>提炼函数(Extract Method)</code> 将方法拆分为几个部分，可以放置在不同类中的不同位置。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>减少重复代码（如果数据处理的代码放在中心位置）。</li>
<li>更好的代码组织性（处理数据的函数靠近实际数据）。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/feature-envy-3.png"/></div>
<h3 id="何时忽略-3"><a class="markdownIt-Anchor" href="#何时忽略-3"></a> 何时忽略</h3>
<ul>
<li>有时，行为被有意地与保存数据的类分开。这通常的优点是能够动态地改变行为（见策略设计模式，访问者设计模式和其他模式）。</li>
</ul>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狎昵关系"><a class="markdownIt-Anchor" href="#狎昵关系"></a> 狎昵关系</h2>
<blockquote>
<p>狎昵关系(Inappropriate Intimacy)</p>
<p>一个类大量使用另一个类的内部字段和方法。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inappropriate-intimacy-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>类和类之间应该尽量少的感知彼此（减少耦合）。这样的类更容易维护和复用。</p>
<h3 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法</h3>
<ul>
<li>最简单的解决方法是运用 <code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code> 来让类之间斩断羁绊。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inappropriate-intimacy-2.png"/></div>
<ul>
<li>
<p>你也可以看看是否能运用 <code>将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)</code> 让其中一个类对另一个说分手。</p>
</li>
<li>
<p>如果这两个类实在是情比金坚，难分难舍，可以运用 <code>提炼类(Extract Class)</code> 把二者共同点提炼到一个新类中，让它们产生爱的结晶。或者，可以尝试运用 <code>隐藏委托关系(Hide Delegate)</code> 让另一个类来为它们牵线搭桥。</p>
</li>
<li>
<p>继承往往造成类之间过分紧密，因为子类对超类的了解总是超过后者的主观愿望，如果你觉得该让这个子类自己闯荡，请运用 <code>以委托取代继承(Replace Inheritance with Delegation)</code> 来让超类和子类分家。</p>
</li>
</ul>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>提高代码组织性。</li>
<li>提高代码复用性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inappropriate-intimacy-3.png"/></div>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method-2"><a class="markdownIt-Anchor" href="#搬移函数move-method-2"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="搬移字段move-field"><a class="markdownIt-Anchor" href="#搬移字段move-field"></a> 搬移字段(Move Field)</h4>
<p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-before.png"/></div>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-after.png"/></div>
<h4 id="将双向关联改为单向关联change-bidirectional-association-to-unidirectional"><a class="markdownIt-Anchor" href="#将双向关联改为单向关联change-bidirectional-association-to-unidirectional"></a> 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)</h4>
<p><strong>问题</strong></p>
<p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/change-bidirectional-association-to-unidirectional-before.png"/></div>
<p><strong>解决</strong></p>
<p>去除不必要的关联。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/change-bidirectional-association-to-unidirectional-after.png"/></div>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="隐藏委托关系hide-delegate"><a class="markdownIt-Anchor" href="#隐藏委托关系hide-delegate"></a> 隐藏委托关系(Hide Delegate)</h4>
<p><strong>问题</strong></p>
<p>客户通过一个委托类来调用另一个对象。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-before.png"/></div>
<p><strong>解决</strong></p>
<p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-after.png"/></div>
<h4 id="以委托取代继承replace-inheritance-with-delegation"><a class="markdownIt-Anchor" href="#以委托取代继承replace-inheritance-with-delegation"></a> 以委托取代继承(Replace Inheritance with Delegation)</h4>
<p><strong>问题</strong></p>
<p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-delegation-with-inheritance-before.png"/></div>
<p><strong>解决</strong></p>
<p>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-delegation-with-inheritance-after.png"/></div>
<h2 id="过度耦合的消息链"><a class="markdownIt-Anchor" href="#过度耦合的消息链"></a> 过度耦合的消息链</h2>
<blockquote>
<p>过度耦合的消息链(Message Chains)</p>
<p>消息链的形式类似于：<code>obj.getA().getB().getC()</code>。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/message-chains-1.png"/></div>
<h3 id="问题原因-5"><a class="markdownIt-Anchor" href="#问题原因-5"></a> 问题原因</h3>
<p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串 getThis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航紧密耦合。一旦对象间关系发生任何变化，客户端就不得不做出相应的修改。</p>
<h3 id="解决方法-5"><a class="markdownIt-Anchor" href="#解决方法-5"></a> 解决方法</h3>
<ul>
<li>可以运用 <code>隐藏委托关系(Hide Delegate)</code> 删除一个消息链。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/message-chains-2.png"/></div>
<ul>
<li>有时更好的选择是：先观察消息链最终得到的对象是用来干什么的。看看能否以 <code>提炼函数(Extract Method)</code>把使用该对象的代码提炼到一个独立函数中，再运用 <code>搬移函数(Move Method)</code> 把这个函数推入消息链。</li>
</ul>
<h3 id="收益-5"><a class="markdownIt-Anchor" href="#收益-5"></a> 收益</h3>
<ul>
<li>能减少链中类之间的依赖。</li>
<li>能减少代码量。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/message-chains-3.png"/></div>
<h3 id="何时忽略-4"><a class="markdownIt-Anchor" href="#何时忽略-4"></a> 何时忽略</h3>
<ul>
<li>过于侵略性的委托可能会使程序员难以理解功能是如何触发的。</li>
</ul>
<h3 id="重构方法说明-5"><a class="markdownIt-Anchor" href="#重构方法说明-5"></a> 重构方法说明</h3>
<h4 id="隐藏委托关系hide-delegate-2"><a class="markdownIt-Anchor" href="#隐藏委托关系hide-delegate-2"></a> 隐藏委托关系(Hide Delegate)</h4>
<p><strong>问题</strong></p>
<p>客户通过一个委托类来调用另一个对象。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-before.png"/></div>
<p><strong>解决</strong></p>
<p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-delegate-after.png"/></div>
<h4 id="提炼函数extract-method-2"><a class="markdownIt-Anchor" href="#提炼函数extract-method-2"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搬移函数move-method-3"><a class="markdownIt-Anchor" href="#搬移函数move-method-3"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">代码坏味道之滥用面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-21 13:20:31" itemprop="dateModified" datetime="2019-08-21T13:20:31+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/refactor/" itemprop="url" rel="index">
                    <span itemprop="name">refactor</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/refactor/代码坏味道之滥用面向对象/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码坏味道之滥用面向对象"><a class="markdownIt-Anchor" href="#代码坏味道之滥用面向对象"></a> 代码坏味道之滥用面向对象</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/oo-abusers" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/oo-abusers</a></p>
</blockquote>
<blockquote>
<p><strong>滥用面向对象(Object-Orientation Abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#switch-%E5%A3%B0%E6%98%8E">Switch 声明</a></li>
<li><a href="#%E4%B8%B4%E6%97%B6%E5%AD%97%E6%AE%B5">临时字段</a></li>
<li><a href="#%E5%BC%82%E6%9B%B2%E5%90%8C%E5%B7%A5%E7%9A%84%E7%B1%BB">异曲同工的类</a></li>
<li><a href="#%E8%A2%AB%E6%8B%92%E7%BB%9D%E7%9A%84%E9%A6%88%E8%B5%A0">被拒绝的馈赠</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="switch-声明"><a class="markdownIt-Anchor" href="#switch-声明"></a> Switch 声明</h2>
<blockquote>
<p>Switch 声明(Switch Statements)</p>
<p>你有一个复杂的 <code>switch</code> 语句或 <code>if</code> 序列语句。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/switch-statements-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>面向对象程序的一个最明显特征就是：少用 <code>switch</code> 和 <code>case</code> 语句。从本质上说，<code>switch</code> 语句的问题在于重复（<code>if</code> 序列也同样如此）。你常会发现 <code>switch</code> 语句散布于不同地点。如果要为它添加一个新的 <code>case</code> 子句，就必须找到所有 <code>switch</code> 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。</p>
<p>大多数时候，一看到 <code>switch</code> 语句，就应该考虑以多态来替换它。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>问题是多态该出现在哪？switch 语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”，所以应该运用 <code>提炼函数(Extract Method)</code> 将 <code>switch</code> 语句提炼到一个独立函数中，再以 <code>搬移函数(Move Method)</code> 将它搬移到需要多态性的那个类里。</li>
<li>如果你的 <code>switch</code> 是基于类型码来识别分支，这时可以运用 <code>以子类取代类型码(Replace Type Code with Subclass)</code> 或 <code>以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</code> 。</li>
<li>一旦完成这样的继承结构后，就可以运用 <code>以多态取代条件表达式(Replace Conditional with Polymorphism)</code> 了。</li>
<li>如果条件分支并不多并且它们使用不同参数调用相同的函数，多态就没必要了。在这种情况下，你可以运用 <code>以明确函数取代参数(Replace Parameter with Explicit Methods)</code> 。</li>
<li>如果你的选择条件之一是 null，可以运用 <code>引入 Null 对象(Introduce Null Object)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>提升代码组织性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/switch-statements-2.png"/></div>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>如果一个 <code>switch</code> 操作只是执行简单的行为，就没有重构的必要了。</li>
<li><code>switch</code> 常被工厂设计模式族（<code>工厂方法模式(Factory Method)</code>和<code>抽象工厂模式(Abstract Factory)</code>）所使用，这种情况下也没必要重构。</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="以子类取代类型码replace-type-code-with-subclass"><a class="markdownIt-Anchor" href="#以子类取代类型码replace-type-code-with-subclass"></a> 以子类取代类型码(Replace Type Code with Subclass)</h4>
<p><strong>问题</strong></p>
<p>你有一个不可变的类型码，它会影响类的行为。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-before.png"/></div>
<p><strong>解决</strong></p>
<p>以子类取代这个类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-subclasses-after.png"/></div>
<h4 id="以状态策略模式取代类型码replace-type-code-with-statestrategy"><a class="markdownIt-Anchor" href="#以状态策略模式取代类型码replace-type-code-with-statestrategy"></a> 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</h4>
<p><strong>问题</strong></p>
<p>你有一个类型码，它会影响类的行为，但你无法通过继承消除它。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-before.png"/></div>
<p><strong>解决</strong></p>
<p>以状态对象取代类型码。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-type-code-with-state-strategy-after.png"/></div>
<h4 id="以多态取代条件表达式replace-conditional-with-polymorphism"><a class="markdownIt-Anchor" href="#以多态取代条件表达式replace-conditional-with-polymorphism"></a> 以多态取代条件表达式(Replace Conditional with Polymorphism)</h4>
<p><strong>问题</strong></p>
<p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> EUROPEAN:</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">      <span class="keyword">case</span> AFRICAN:</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">      <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">        <span class="keyword">return</span> (isNailed) ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Should be unreachable"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">African</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NorwegianBlue</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isNailed) ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in client code</span></span><br><span class="line">speed = bird.getSpeed();</span><br></pre></td></tr></table></figure>
<h4 id="以明确函数取代参数replace-parameter-with-explicit-methods"><a class="markdownIt-Anchor" href="#以明确函数取代参数replace-parameter-with-explicit-methods"></a> 以明确函数取代参数(Replace Parameter with Explicit Methods)</h4>
<p><strong>问题</strong></p>
<p>你有一个函数，其中完全取决于参数值而采取不同的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">"height"</span>)) &#123;</span><br><span class="line">    height = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">"width"</span>)) &#123;</span><br><span class="line">    width = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Assert.shouldNeverReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>针对该参数的每一个可能值，建立一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入-null-对象introduce-null-object"><a class="markdownIt-Anchor" href="#引入-null-对象introduce-null-object"></a> 引入 Null 对象(Introduce Null Object)</h4>
<p><strong>问题</strong></p>
<p>你需要再三检查某对象是否为 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (customer == <span class="keyword">null</span>) &#123;</span><br><span class="line">  plan = BillingPlan.basic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  plan = customer.getPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将 null 值替换为 null 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullCustomer</span> <span class="keyword">extends</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="function">Plan <span class="title">getPlan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NullPlan();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some other NULL functionality.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace null values with Null-object.</span></span><br><span class="line">customer = (order.customer != <span class="keyword">null</span>) ? order.customer : <span class="keyword">new</span> NullCustomer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Null-object as if it's normal subclass.</span></span><br><span class="line">plan = customer.getPlan();</span><br></pre></td></tr></table></figure>
<h2 id="临时字段"><a class="markdownIt-Anchor" href="#临时字段"></a> 临时字段</h2>
<blockquote>
<p>临时字段(Temporary Field)的值只在特定环境下有意义，离开这个环境，它们就什么也不是了。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/temporary-field-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初设置目的，会让你发疯。<br />
通常，临时字段是在某一算法需要大量输入时而创建。因此，为了避免函数有过多参数，程序员决定在类中创建这些数据的临时字段。这些临时字段仅仅在算法中使用，其他时候却毫无用处。<br />
这种代码不好理解。你期望查看对象字段的数据，但是出于某种原因，它们总是为空。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>可以通过 <code>提炼类(Extract Class)</code> 将临时字段和操作它们的所有代码提炼到一个单独的类中。此外，你可以运用 <code>以函数对象取代函数(Replace Method with Method Object)</code> 来实现同样的目的。</li>
<li><code>引入 Null 对象(Introduce Null Object)</code> 在“变量不合法”的情况下创建一个 null 对象，从而避免写出条件表达式。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/temporary-field-2.png"/></div>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>更好的代码清晰度和组织性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/temporary-field-3.png"/></div>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="以函数对象取代函数replace-method-with-method-object"><a class="markdownIt-Anchor" href="#以函数对象取代函数replace-method-with-method-object"></a> 以函数对象取代函数(Replace Method with Method Object)</h4>
<p><strong>问题</strong></p>
<p>你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator(<span class="keyword">this</span>).compute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PriceCalculator</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// copy relevant information from order object.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入-null-对象introduce-null-object-2"><a class="markdownIt-Anchor" href="#引入-null-对象introduce-null-object-2"></a> 引入 Null 对象(Introduce Null Object)</h4>
<p><strong>问题</strong></p>
<p>你需要再三检查某对象是否为 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (customer == <span class="keyword">null</span>) &#123;</span><br><span class="line">  plan = BillingPlan.basic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  plan = customer.getPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将 null 值替换为 null 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullCustomer</span> <span class="keyword">extends</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="function">Plan <span class="title">getPlan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NullPlan();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some other NULL functionality.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace null values with Null-object.</span></span><br><span class="line">customer = (order.customer != <span class="keyword">null</span>) ? order.customer : <span class="keyword">new</span> NullCustomer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Null-object as if it's normal subclass.</span></span><br><span class="line">plan = customer.getPlan();</span><br></pre></td></tr></table></figure>
<h2 id="异曲同工的类"><a class="markdownIt-Anchor" href="#异曲同工的类"></a> 异曲同工的类</h2>
<blockquote>
<p>异曲同工的类(Alternative Classes with Different Interfaces)</p>
<p>两个类中有着不同的函数，却在做着同一件事。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/alternative-classes-with-different-interfaces-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>这种情况往往是因为：创建这个类的程序员并不知道已经有实现这个功能的类存在了。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<ul>
<li>如果两个函数做同一件事，却有着不同的签名，请运用 <code>函数改名(Rename Method)</code> 根据它们的用途重新命名。</li>
<li>运用 <code>搬移函数(Move Method)</code> 、 <code>添加参数(Add Parameter)</code> 和 <code>令函数携带参数(Parameterize Method)</code> 来使得方法的名称和实现一致。</li>
<li>如果两个类仅有部分功能是重复的，尝试运用 <code>提炼超类(Extract Superclass)</code> 。这种情况下，已存在的类就成了超类。</li>
<li>当最终选择并运用某种方法来重构后，也许你就能删除其中一个类了。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>消除了不必要的重复代码，为代码瘦身了。</li>
<li>代码更易读（不再需要猜测为什么要有两个功能相同的类）。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/alternative-classes-with-different-interfaces-2.png"/></div>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<ul>
<li>有时合并类是不可能的，或者是如此困难以至于没有意义。例如：两个功能相似的类存在于不同的 lib 库中。</li>
</ul>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="函数改名rename-method"><a class="markdownIt-Anchor" href="#函数改名rename-method"></a> 函数改名(Rename Method)</h4>
<p><strong>问题</strong></p>
<p>函数的名称未能恰当的揭示函数的用途。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getsnm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>修改函数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSecondName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搬移函数move-method-2"><a class="markdownIt-Anchor" href="#搬移函数move-method-2"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="添加参数add-parameter"><a class="markdownIt-Anchor" href="#添加参数add-parameter"></a> 添加参数(Add Parameter)</h4>
<p><strong>问题</strong><br />
某个函数需要从调用端得到更多信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contact <span class="title">getContact</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong><br />
为此函数添加一个对象函数，让改对象带进函数所需信息。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">class<span class="built_in"> Customer </span>&#123;</span><br><span class="line">  public Contact getContact(Date date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="令函数携带参数parameterize-method"><a class="markdownIt-Anchor" href="#令函数携带参数parameterize-method"></a> 令函数携带参数(Parameterize Method)</h4>
<p><strong>问题</strong></p>
<p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/parameterize-method-before.png"/></div>
**解决**
<p>建立单一函数，以参数表达哪些不同的值。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/parameterize-method-after.png"/></div>
<h4 id="提炼超类extract-superclass"><a class="markdownIt-Anchor" href="#提炼超类extract-superclass"></a> 提炼超类(Extract Superclass)</h4>
<p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-after.png"/></div>
<h2 id="被拒绝的馈赠"><a class="markdownIt-Anchor" href="#被拒绝的馈赠"></a> 被拒绝的馈赠</h2>
<blockquote>
<p>被拒绝的馈赠(Refused Bequest)</p>
<p>子类仅仅使用父类中的部分方法和属性。其他来自父类的馈赠成为了累赘。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/refused-bequest-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>有些人仅仅是想重用超类中的部分代码而创建了子类。但实际上超类和子类完全不同。</p>
<h3 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法</h3>
<ul>
<li>如果继承没有意义并且子类和父类之间确实没有共同点，可以运用 <code>以委托取代继承(Replace Inheritance with Delegation)</code> 消除继承。</li>
<li>如果继承是适当的，则去除子类中不需要的字段和方法。运用 <code>提炼超类(Extract Superclass)</code> 将所有超类中对于子类有用的字段和函数提取出来，置入一个新的超类中，然后让两个类都继承自它。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/refused-bequest-2.png"/></div>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>提高代码的清晰度和组织性。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/refused-bequest-3.png"/></div>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="以委托取代继承replace-inheritance-with-delegation"><a class="markdownIt-Anchor" href="#以委托取代继承replace-inheritance-with-delegation"></a> 以委托取代继承(Replace Inheritance with Delegation)</h4>
<p><strong>问题</strong></p>
<p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-inheritance-with-delegation-before.png"/></div>
<p><strong>解决</strong></p>
<ol>
<li>在子类中新建一个字段用以保存超类；</li>
<li>调整子类函数，令它改而委托超类；</li>
<li>然后去掉两者之间的继承关系。</li>
</ol>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/replace-inheritance-with-delegation-after.png"/></div>
<h4 id="提炼超类extract-superclass-2"><a class="markdownIt-Anchor" href="#提炼超类extract-superclass-2"></a> 提炼超类(Extract Superclass)</h4>
<p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-08 18:07:49" itemprop="dateModified" datetime="2019-05-08T18:07:49+08:00">2019-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/architecture/" itemprop="url" rel="index">
                    <span itemprop="name">architecture</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/负载均衡/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86">1. 负载均衡原理</a></li>
<li><a href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%88%86%E7%B1%BB">2. 负载均衡分类</a>
<ul>
<li><a href="#21-dns-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.1. DNS 负载均衡</a></li>
<li><a href="#22-ip-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.2. IP 负载均衡</a></li>
<li><a href="#23-%E9%93%BE%E8%B7%AF%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.3. 链路层负载均衡</a></li>
<li><a href="#24-%E6%B7%B7%E5%90%88%E5%9E%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.4. 混合型负载均衡</a></li>
</ul>
</li>
<li><a href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">3. 负载均衡算法</a>
<ul>
<li><a href="#31-%E8%BD%AE%E8%AF%A2">3.1. 轮询</a></li>
<li><a href="#32-%E9%9A%8F%E6%9C%BA">3.2. 随机</a></li>
<li><a href="#33-%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5">3.3. 最少连接</a></li>
<li><a href="#34-hash%E6%BA%90%E5%9C%B0%E5%9D%80%E6%95%A3%E5%88%97">3.4. Hash（源地址散列）</a></li>
<li><a href="#35-%E5%8A%A0%E6%9D%83">3.5. 加权</a></li>
</ul>
</li>
<li><a href="#4-%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">4. 硬件负载均衡</a></li>
<li><a href="#5-ngnix-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">5. Ngnix 负载均衡</a>
<ul>
<li><a href="#51-ngnix-%E7%89%B9%E7%82%B9">5.1. Ngnix 特点</a></li>
<li><a href="#52-ngnix-%E5%8A%9F%E8%83%BD">5.2. Ngnix 功能</a></li>
<li><a href="#53-ngnix-%E6%9E%B6%E6%9E%84">5.3. Ngnix 架构</a></li>
<li><a href="#54-ngnix-%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5">5.4. Ngnix 均衡策略</a></li>
<li><a href="#55-ngnix-%E5%9C%BA%E6%99%AF">5.5. Ngnix 场景</a></li>
</ul>
</li>
<li><a href="#6-lvs-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">6. LVS 负载均衡</a>
<ul>
<li><a href="#61-lvs-%E5%8A%9F%E8%83%BD">6.1. LVS 功能</a></li>
<li><a href="#62-lvs-%E6%9E%B6%E6%9E%84">6.2. LVS 架构</a></li>
<li><a href="#63-lvs-%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5">6.3. LVS 均衡策略</a></li>
<li><a href="#64-lvs-%E5%9C%BA%E6%99%AF">6.4. LVS 场景</a></li>
</ul>
</li>
<li><a href="#7-haproxy-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">7. HaProxy 负载均衡</a>
<ul>
<li><a href="#71-haproxy-%E7%89%B9%E7%82%B9">7.1. HaProxy 特点</a></li>
<li><a href="#72-haproxy-%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5">7.2. HaProxy 均衡策略</a></li>
</ul>
</li>
<li><a href="#8-%E8%B5%84%E6%96%99">8. 资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-负载均衡原理"><a class="markdownIt-Anchor" href="#1-负载均衡原理"></a> 1. 负载均衡原理</h2>
<p>系统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。纵向扩展，是从单机的角度通过增加硬件处理能力，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构：如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213194550278-786046258.png"/></div>
<ul>
<li>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</li>
<li>负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</li>
</ul>
<p>负载均衡的作用（解决的问题）：</p>
<ol>
<li>
<p>解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；</p>
</li>
<li>
<p>提供故障转移，实现高可用；</p>
</li>
<li>
<p>通过添加或减少服务器数量，提供网站伸缩性（扩展性）；</p>
</li>
<li>
<p>安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）</p>
</li>
</ol>
<h2 id="2-负载均衡分类"><a class="markdownIt-Anchor" href="#2-负载均衡分类"></a> 2. 负载均衡分类</h2>
<p>根据实现技术不同，可分为 DNS 负载均衡，HTTP 负载均衡，IP 负载均衡，链路层负载均衡等。</p>
<h3 id="21-dns-负载均衡"><a class="markdownIt-Anchor" href="#21-dns-负载均衡"></a> 2.1. DNS 负载均衡</h3>
<p>最早的负载均衡技术，利用域名解析实现负载均衡，在 DNS 服务器，配置多个 A 记录，这些 A 记录对应的服务器构成集群。大型网站总是部分使用 DNS 解析，作为第一级负载均衡。如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213194538622-1255166256.png"/></div>
<p>优点</p>
<ol>
<li>使用简单：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li>提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能；</li>
</ol>
<p>缺点</p>
<ol>
<li>可用性差：DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li>扩展性低：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li>维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ol>
<p>实践建议</p>
<p>将 DNS 作为第一级负载均衡，A 记录对应着内部负载均衡的 IP 地址，通过内部负载均衡将请求分发到真实的 Web 服务器上。一般用于互联网公司，复杂的业务系统不合适使用。如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213194500497-164261027.png"/></div>
<h3 id="22-ip-负载均衡"><a class="markdownIt-Anchor" href="#22-ip-负载均衡"></a> 2.2. IP 负载均衡</h3>
<p>在网络层通过修改请求目标地址进行负载均衡。</p>
<p>用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然后将请求目的地址修改为，获得的真实 ip 地址，不需要经过用户进程处理。</p>
<p>真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器，再将数据包源地址修改为自身的 ip 地址，发送给用户浏览器。如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213195925966-1272593644.png"/></div>
<p>IP 负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式：</p>
<ol>
<li>负载均衡服务器在修改目的 ip 地址的同时修改源地址。将数据包源地址设为自身盘，即源地址转换（snat）。</li>
<li>将负载均衡服务器同时作为真实物理服务器集群的网关服务器。</li>
</ol>
<p>优点：在内核进程完成数据分发，比在应用层分发性能更好；</p>
<p>缺点：所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽；</p>
<h3 id="23-链路层负载均衡"><a class="markdownIt-Anchor" href="#23-链路层负载均衡"></a> 2.3. 链路层负载均衡</h3>
<p>在通信协议的数据链路层修改 mac 地址，进行负载均衡。</p>
<p>数据分发时，不修改 ip 地址，指修改目标 mac 地址，配置真实物理服务器集群所有机器虚拟 ip 和负载均衡服务器 ip 地址一致，达到不修改数据包的源地址和目标地址，进行数据分发的目的。</p>
<p>实际处理服务器 ip 和数据请求目的 ip 一致，不需要经过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。也称为直接路由模式（DR 模式）。如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213195947762-1630980523.png"/></div>
<p>优点：性能好；</p>
<p>缺点：配置复杂；</p>
<p>实践建议：DR 模式是目前使用最广泛的一种负载均衡方式。</p>
<h3 id="24-混合型负载均衡"><a class="markdownIt-Anchor" href="#24-混合型负载均衡"></a> 2.4. 混合型负载均衡</h3>
<p>由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。</p>
<p>此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。</p>
<p>方式一，如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200106747-94797427.png"/></div>
<p>以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。</p>
<p>方式二，如下图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151213200117825-1452672107.png"/></div>
<p>以上模式，适合动态请求场景。</p>
<p>因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。</p>
<h2 id="3-负载均衡算法"><a class="markdownIt-Anchor" href="#3-负载均衡算法"></a> 3. 负载均衡算法</h2>
<p>常用的负载均衡算法有：轮询、随机、最少连接、源地址散列、加权等方式。</p>
<h3 id="31-轮询"><a class="markdownIt-Anchor" href="#31-轮询"></a> 3.1. 轮询</h3>
<p>将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。</p>
<p>优点：服务器请求数目相同；</p>
<p>缺点：服务器压力不一样，不适合服务器配置不同的情况；</p>
<h3 id="32-随机"><a class="markdownIt-Anchor" href="#32-随机"></a> 3.2. 随机</h3>
<p>请求随机分配到各个服务器。</p>
<p>优点：使用简单；</p>
<p>缺点：不适合机器配置不同的场景；</p>
<h3 id="33-最少连接"><a class="markdownIt-Anchor" href="#33-最少连接"></a> 3.3. 最少连接</h3>
<p>将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。</p>
<p>优点：根据服务器当前的请求处理情况，动态分配；</p>
<p>缺点：算法实现相对复杂，需要监控服务器请求连接数；</p>
<h3 id="34-hash源地址散列"><a class="markdownIt-Anchor" href="#34-hash源地址散列"></a> 3.4. Hash（源地址散列）</h3>
<p>根据 IP 地址进行 Hash 计算，得到 IP 地址。</p>
<p>优点：将来自同一 IP 地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。</p>
<p>缺点：目标服务器宕机后，会话会丢失；</p>
<h3 id="35-加权"><a class="markdownIt-Anchor" href="#35-加权"></a> 3.5. 加权</h3>
<p>在轮询，随机，最少链接，Hash’等算法的基础上，通过加权的方式，进行负载服务器分配。</p>
<p>优点：根据权重，调节转发服务器的请求数目；</p>
<p>缺点：使用相对复杂；</p>
<h2 id="4-硬件负载均衡"><a class="markdownIt-Anchor" href="#4-硬件负载均衡"></a> 4. 硬件负载均衡</h2>
<p>采用硬件的方式实现负载均衡，一般是单独的负载均衡服务器，价格昂贵，一般土豪级公司可以考虑，业界领先的有两款，F5 和 A10。</p>
<p>使用硬件负载均衡，主要考虑一下几个方面：</p>
<p>（1）功能考虑：功能全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡；</p>
<p>（2）性能考虑：一般软件负载均衡支持到 5 万级并发已经很困难了，硬件负载均衡可以支持</p>
<p>（3）稳定性：商用硬件负载均衡，经过了良好的严格的测试，从经过大规模使用，在稳定性方面高；</p>
<p>（4）安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙，防 DDOS 攻击等安全功能；</p>
<p>（5）维护角度：提供良好的维护管理界面，售后服务和技术支持；</p>
<p>（6）土豪公司：F5 Big Ip 价格：15w~55w 不等；A10 价格：55w-100w 不等；</p>
<p>缺点</p>
<p>（1）价格昂贵；</p>
<p>（2）扩展能力差；</p>
<p>小结</p>
<p>（1）一般硬件的负载均衡也要做双机高可用，因此成本会比较高。</p>
<p>（2）互联网公司一般使用开源软件，因此大部分应用采用软件负载均衡；部分采用硬件负载均衡。</p>
<p>比如某互联网公司，目前是使用几台 F5 做全局负载均衡，内部使用 Nginx 等软件负载均衡。</p>
<h2 id="5-ngnix-负载均衡"><a class="markdownIt-Anchor" href="#5-ngnix-负载均衡"></a> 5. Ngnix 负载均衡</h2>
<p>Ngnix 是一款轻量级的 Web 服务器/反向代理服务器，工作在七层 Http 协议的负载均衡系统。具有高性能、高并发、低内存使用等特点。是一个轻量级的 Http 和反向代理服务器。Nginx 使用 epoll and kqueue 作为开发模型。能够支持高达 50,000 个并发连接数的响应。</p>
<p>操作系统：Liunx，Windows（Linux、FreeBSD、Solaris、Mac OS X、AIX 以及 Microsoft Windows）</p>
<p>开发语言：C</p>
<p>并发性能：官方支持每秒 5 万并发，实际国内一般到每秒 2 万并发，有优化到每秒 10 万并发的。具体性能看应用场景。</p>
<h3 id="51-ngnix-特点"><a class="markdownIt-Anchor" href="#51-ngnix-特点"></a> 5.1. Ngnix 特点</h3>
<p>1.模块化设计：良好的扩展性，可以通过模块方式进行功能扩展。</p>
<p>2.高可靠性：主控进程和 worker 是同步实现的，一个 worker 出现问题，会立刻启动另一个 worker。</p>
<p>3.内存消耗低：一万个长连接（keep-alive）,仅消耗 2.5MB 内存。</p>
<p>4.支持热部署：不用停止服务器，实现更新配置文件，更换日志文件、更新服务器程序版本。</p>
<p>5.并发能力强：官方数据每秒支持 5 万并发；</p>
<p>6.功能丰富：优秀的反向代理功能和灵活的负载均衡策略</p>
<h3 id="52-ngnix-功能"><a class="markdownIt-Anchor" href="#52-ngnix-功能"></a> 5.2. Ngnix 功能</h3>
<h4 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h4>
<ul>
<li>支持静态资源的 web 服务器。</li>
<li>http,smtp,pop3 协议的反向代理服务器、缓存、负载均衡；</li>
<li>支持 FASTCGI（fpm）</li>
<li>支持模块化，过滤器（让文本可以实现压缩，节约带宽）,ssl 及图像大小调整。</li>
<li>内置的健康检查功能</li>
<li>基于名称和 ip 的虚拟主机</li>
<li>定制访问日志</li>
<li>支持平滑升级</li>
<li>支持 KEEPALIVE</li>
<li>支持 url rewrite</li>
<li>支持路径别名</li>
<li>支持基于 IP 和用户名的访问控制。</li>
<li>支持传输速率限制，支持并发数限制。</li>
</ul>
<h4 id="扩展功能"><a class="markdownIt-Anchor" href="#扩展功能"></a> 扩展功能</h4>
<h4 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h4>
<p>Nginx 的高并发，官方测试支持 5 万并发连接。实际生产环境能到 2-3 万并发连接数。10000 个非活跃的 HTTP keep-alive 连接仅占用约 2.5MB 内存。三万并发连接下，10 个 Nginx 进程，消耗内存 150M。淘宝 tengine 团队测试结果是“24G 内存机器上，处理并发请求可达 200 万”。</p>
<h3 id="53-ngnix-架构"><a class="markdownIt-Anchor" href="#53-ngnix-架构"></a> 5.3. Ngnix 架构</h3>
<h4 id="nginx-的基本工作模式"><a class="markdownIt-Anchor" href="#nginx-的基本工作模式"></a> Nginx 的基本工作模式</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227195943640-864372763.jpg"/></div>
<p>一个 master 进程，生成一个或者多个 worker 进程。但是这里 master 是使用 root 身份启动的，因为 nginx 要工作在 80 端口。而只有管理员才有权限启动小于低于 1023 的端口。master 主要是负责的作用只是启动 worker，加载配置文件，负责系统的平滑升级。其它的工作是交给 worker。那么当 worker 被启动之后，也只是负责一些 web 最简单的工作，而其他的工作都是有 worker 中调用的模块来实现的。</p>
<p>模块之间是以流水线的方式实现功能的。流水线，指的是一个用户请求，由多个模块组合各自的功能依次实现完成的。比如：第一个模块只负责分析请求首部，第二个模块只负责查找数据，第三个模块只负责压缩数据，依次完成各自工作。来实现整个工作的完成。</p>
<p>他们是如何实现热部署的呢？其实是这样的，我们前面说 master 不负责具体的工作，而是调用 worker 工作，他只是负责读取配置文件，因此当一个模块修改或者配置文件发生变化，是由 master 进行读取，因此此时不会影响到 worker 工作。在 master 进行读取配置文件之后，不会立即的把修改的配置文件告知 worker。而是让被修改的 worker 继续使用老的配置文件工作，当 worker 工作完毕之后，直接当掉这个子进程，更换新的子进程，使用新的规则。</p>
<h4 id="nginx-支持的-sendfile-机制"><a class="markdownIt-Anchor" href="#nginx-支持的-sendfile-机制"></a> Nginx 支持的 sendfile 机制</h4>
<p>Sendfile 机制，用户将请求发给内核，内核根据用户的请求调用相应用户进程，进程在处理时需要资源。此时再把请求发给内核（进程没有直接 IO 的能力），由内核加载数据。内核查找到数据之后，会把数据复制给用户进程，由用户进程对数据进行封装，之后交给内核，内核在进行 tcp/ip 首部的封装，最后再发给客户端。这个功能用户进程只是发生了一个封装报文的过程，却要绕一大圈。因此 nginx 引入了 sendfile 机制，使得内核在接受到数据之后，不再依靠用户进程给予封装，而是自己查找自己封装，减少了一个很长一段时间的浪费，这是一个提升性能的核心点。</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227195957171-1801771404.jpg"/></div>
<p>以上内容摘自网友发布的文章，简单一句话是资源的处理，直接通过内核层进行数据传递，避免了数据传递到应用层，应用层再传递到内核层的开销。</p>
<p>目前高并发的处理，一般都采用 sendfile 模式。通过直接操作内核层数据，减少应用与内核层数据传递。</p>
<h4 id="nginx-通信模型io-复用机制"><a class="markdownIt-Anchor" href="#nginx-通信模型io-复用机制"></a> Nginx 通信模型（I/O 复用机制）</h4>
<p>开发模型：epoll 和 kqueue。</p>
<p>支持的事件机制：kqueue、epoll、rt signals、/dev/poll 、event ports、select 以及 poll。</p>
<p>支持的 kqueue 特性包括 EV_CLEAR、EV_DISABLE、NOTE_LOWAT、EV_EOF，可用数据的数量，错误代码.</p>
<p>支持 sendfile、sendfile64 和 sendfilev;文件 AIO；DIRECTIO;支持 Accept-filters 和 TCP_DEFER_ACCEP.</p>
<p>以上概念较多，大家自行百度或谷歌，知识领域是网络通信（BIO,NIO,AIO）和多线程方面的知识。</p>
<h3 id="54-ngnix-均衡策略"><a class="markdownIt-Anchor" href="#54-ngnix-均衡策略"></a> 5.4. Ngnix 均衡策略</h3>
<p>nginx 的负载均衡策略可以划分为两大类：内置策略和扩展策略。内置策略包含加权轮询和 ip hash，在默认情况下这两种策略会编译进 nginx 内核，只需在 nginx 配置中指明参数即可。扩展策略有很多，如 fair、通用 hash、consistent hash 等，默认不编译进 nginx 内核。由于在 nginx 版本升级中负载均衡的代码没有本质性的变化，因此下面将以 nginx1.0.15 稳定版为例，从源码角度分析各个策略。</p>
<h4 id="加权轮询weighted-round-robin"><a class="markdownIt-Anchor" href="#加权轮询weighted-round-robin"></a> 加权轮询（weighted round robin）</h4>
<p>轮询的原理很简单，首先我们介绍一下轮询的基本流程。如下是处理一次请求的流程图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227201913984-412518987.jpg"/></div>
<p>图中有两点需要注意，第一，如果可以把加权轮询算法分为先深搜索和先广搜索，那么 nginx 采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；第二，当所有后端机器都 down 掉时，nginx 会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在 timeout 的状态，从而导致整个前端被夯住。</p>
<h4 id="ip-hash"><a class="markdownIt-Anchor" href="#ip-hash"></a> ip hash</h4>
<p>ip hash 是 nginx 内置的另一个负载均衡的策略，流程和轮询很类似，只是其中的算法和具体的策略有些变化，如下图所示：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227201851812-352858632.jpg"/></div>
<h4 id="fair"><a class="markdownIt-Anchor" href="#fair"></a> fair</h4>
<p>fair 策略是扩展策略，默认不被编译进 nginx 内核。其原理是根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流。这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此要慎用。</p>
<h4 id="通用-hash-一致性-hash"><a class="markdownIt-Anchor" href="#通用-hash-一致性-hash"></a> 通用 hash、一致性 hash</h4>
<p>这两种也是扩展策略，在具体的实现上有些差别，通用 hash 比较简单，可以以 nginx 内置的变量为 key 进行 hash，一致性 hash 采用了 nginx 内置的一致性 hash 环，可以支持 memcache。</p>
<h3 id="55-ngnix-场景"><a class="markdownIt-Anchor" href="#55-ngnix-场景"></a> 5.5. Ngnix 场景</h3>
<p>Ngnix 一般作为入口负载均衡或内部负载均衡，结合反向代理服务器使用。以下架构示例，仅供参考，具体使用根据场景而定。</p>
<h4 id="入口负载均衡架构"><a class="markdownIt-Anchor" href="#入口负载均衡架构"></a> 入口负载均衡架构</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202044781-2116477406.png"/></div>
<p>Ngnix 服务器在用户访问的最前端。根据用户请求再转发到具体的应用服务器或二级负载均衡服务器（LVS）</p>
<h4 id="内部负载均衡架构"><a class="markdownIt-Anchor" href="#内部负载均衡架构"></a> 内部负载均衡架构</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202054421-2015542569.png"/></div>
<p>LVS 作为入口负载均衡，将请求转发到二级 Ngnix 服务器，Ngnix 再根据请求转发到具体的应用服务器。</p>
<h4 id="ngnix-高可用"><a class="markdownIt-Anchor" href="#ngnix-高可用"></a> Ngnix 高可用</h4>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227202100921-915093452.png"/></div>
<p>分布式系统中，应用只部署一台服务器会存在单点故障，负载均衡同样有类似的问题。一般可采用主备或负载均衡设备集群的方式节约单点故障或高并发请求分流。</p>
<p>Ngnix 高可用，至少包含两个 Ngnix 服务器，一台主服务器，一台备服务器，之间使用 Keepalived 做健康监控和故障检测。开放 VIP 端口，通过防火墙进行外部映射。</p>
<p>DNS 解析公网的 IP 实际为 VIP。</p>
<h2 id="6-lvs-负载均衡"><a class="markdownIt-Anchor" href="#6-lvs-负载均衡"></a> 6. LVS 负载均衡</h2>
<p>LVS 是一个开源的软件，由毕业于国防科技大学的章文嵩博士于 1998 年 5 月创立，用来实现 Linux 平台下的简单负载均衡。LVS 是 Linux Virtual Server 的缩写，意思是 Linux 虚拟服务器。</p>
<p>基于 IP 层的负载均衡调度技术，它在操作系统核心层上，将来自 IP 层的 TCP/UDP 请求均衡地转移到不同的 服务器，从而将一组服务器构成一个高性能、高可用的虚拟服务器。</p>
<p>操作系统：Liunx</p>
<p>开发语言：C</p>
<p>并发性能：默认 4096，可以修改但需要重新编译。</p>
<h3 id="61-lvs-功能"><a class="markdownIt-Anchor" href="#61-lvs-功能"></a> 6.1. LVS 功能</h3>
<p>LVS 的主要功能是实现 IP 层（网络层）负载均衡，有 NAT,TUN,DR 三种请求转发模式。</p>
<h4 id="lvsnat-方式的负载均衡集群"><a class="markdownIt-Anchor" href="#lvsnat-方式的负载均衡集群"></a> LVS/NAT 方式的负载均衡集群</h4>
<p>NAT 是指 Network Address Translation，它的转发流程是：Director 机器收到外界请求，改写数据包的目标地址，按相应的调度算法将其发送到相应 Real Server 上，Real Server 处理完该请求后，将结果数据包返回到其默认网关，即 Director 机器上，Director 机器再改写数据包的源地址，最后将其返回给外界。这样就完成一次负载调度。</p>
<p>构架一个最简单的 LVS/NAT 方式的负载均衡集群 Real Server 可以是任何的操作系统，而且无需做任何特殊的设定，惟一要做的就是将其默认网关指向 Director 机器。Real Server 可以使用局域网的内部 IP(192.168.0.0/24)。Director 要有两块网卡，一块网卡绑定一个外部 IP 地址 (10.0.0.1)，另一块网卡绑定局域网的内部 IP(192.168.0.254)，作为 Real Server 的默认网关。</p>
<p>LVS/NAT 方式实现起来最为简单，而且 Real Server 使用的是内部 IP，可以节省 Real IP 的开销。但因为执行 NAT 需要重写流经 Director 的数据包，在速度上有一定延迟；</p>
<p>当用户的请求非常短，而服务器的回应非常大的情况下，会对 Director 形成很大压力，成为新的瓶颈，从而使整个系统的性能受到限制。</p>
<h4 id="lvstun-方式的负载均衡集群"><a class="markdownIt-Anchor" href="#lvstun-方式的负载均衡集群"></a> LVS/TUN 方式的负载均衡集群</h4>
<p>TUN 是指 IP Tunneling，它的转发流程是：Director 机器收到外界请求，按相应的调度算法,通过 IP 隧道发送到相应 Real Server，Real Server 处理完该请求后，将结果数据包直接返回给客户。至此完成一次负载调度。</p>
<p>最简单的 LVS/TUN 方式的负载均衡集群架构使用 IP Tunneling 技术，在 Director 机器和 Real Server 机器之间架设一个 IP Tunnel，通过 IP Tunnel 将负载分配到 Real Server 机器上。Director 和 Real Server 之间的关系比较松散，可以是在同一个网络中，也可以是在不同的网络中，只要两者能够通过 IP Tunnel 相连就行。收到负载分配的 Real Server 机器处理完后会直接将反馈数据送回给客户，而不必通过 Director 机器。实际应用中，服务器必须拥有正式的 IP 地址用于与客户机直接通信，并且所有服务器必须支持 IP 隧道协议。</p>
<p>该方式中 Director 将客户请求分配到不同的 Real Server，Real Server 处理请求后直接回应给用户，这样 Director 就只处理客户机与服务器的一半连接，极大地提高了 Director 的调度处理能力，使集群系统能容纳更多的节点数。另外 TUN 方式中的 Real Server 可以在任何 LAN 或 WAN 上运行，这样可以构筑跨地域的集群，其应对灾难的能力也更强，但是服务器需要为 IP 封装付出一定的资源开销，而且后端的 Real Server 必须是支持 IP Tunneling 的操作系统。</p>
<h4 id="lvstun-方式的负载均衡集群-2"><a class="markdownIt-Anchor" href="#lvstun-方式的负载均衡集群-2"></a> LVS/TUN 方式的负载均衡集群</h4>
<p>DR 是指 Direct Routing，它的转发流程是：Director 机器收到外界请求，按相应的调度算法将其直接发送到相应 Real Server，Real Server 处理完该请求后，将结果数据包直接返回给客户，完成一次负载调度。</p>
<p>构架一个最简单的 LVS/DR 方式的负载均衡集群 Real Server 和 Director 都在同一个物理网段中，Director 的网卡 IP 是 192.168.0.253，再绑定另一个 IP： 192.168.0.254 作为对外界的 virtual IP，外界客户通过该 IP 来访问整个集群系统。Real Server 在 lo 上绑定 IP：192.168.0.254，同时加入相应的路由。</p>
<p>LVS/DR 方式与前面的 LVS/TUN 方式有些类似，前台的 Director 机器也是只需要接收和调度外界的请求，而不需要负责返回这些请求的反馈结果，所以能够负载更多的 Real Server，提高 Director 的调度处理能力，使集群系统容纳更多的 Real Server。但 LVS/DR 需要改写请求报文的 MAC 地址，所以所有服务器必须在同一物理网段内。</p>
<h3 id="62-lvs-架构"><a class="markdownIt-Anchor" href="#62-lvs-架构"></a> 6.2. LVS 架构</h3>
<p>LVS 架设的服务器集群系统有三个部分组成：最前端的负载均衡层（Loader Balancer），中间的服务器群组层，用 Server Array 表示，最底层的数据共享存储层，用 Shared Storage 表示。在用户看来所有的应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。</p>
<p>LVS 的体系架构如图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201512/820332-20151227220009109-1768809526.png"/></div>
<p>LVS 的各个层次的详细介绍：</p>
<p>Load Balancer 层：位于整个集群系统的最前端，有一台或者多台负载调度器（Director Server）组成，LVS 模块就安装在 Director Server 上，而 Director 的主要作用类似于一个路由器，它含有完成 LVS 功能所设定的路由表，通过这些路由表把用户的请求分发给 Server Array 层的应用服务器（Real Server）上。同时，在 Director Server 上还要安装对 Real Server 服务的监控模块 Ldirectord，此模块用于监测各个 Real Server 服务的健康状况。在 Real Server 不可用时把它从 LVS 路由表中剔除，恢复时重新加入。</p>
<p>Server Array 层：由一组实际运行应用服务的机器组成，Real Server 可以是 WEB 服务器、MAIL 服务器、FTP 服务器、DNS 服务器、视频服务器中的一个或者多个，每个 Real Server 之间通过高速的 LAN 或分布在各地的 WAN 相连接。在实际的应用中，Director Server 也可以同时兼任 Real Server 的角色。</p>
<p>Shared Storage 层：是为所有 Real Server 提供共享存储空间和内容一致性的存储区域，在物理上，一般有磁盘阵列设备组成，为了提供内容的一致性，一般可以通过 NFS 网络文件系统共享数 据，但是 NFS 在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如 Red hat 的 GFS 文件系统，oracle 提供的 OCFS2 文件系统等。</p>
<p>从整个 LVS 结构可以看出，Director Server 是整个 LVS 的核心，目前，用于 Director Server 的操作系统只能是 Linux 和 FreeBSD，linux2.6 内核不用任何设置就可以支持 LVS 功能，而 FreeBSD 作为 Director Server 的应用还不是很多，性能也不是很好。对于 Real Server，几乎可以是所有的系统平台，Linux、windows、Solaris、AIX、BSD 系列都能很好的支持。</p>
<h3 id="63-lvs-均衡策略"><a class="markdownIt-Anchor" href="#63-lvs-均衡策略"></a> 6.3. LVS 均衡策略</h3>
<p>LVS 默认支持八种负载均衡策略，简述如下：</p>
<h4 id="轮询调度round-robin"><a class="markdownIt-Anchor" href="#轮询调度round-robin"></a> 轮询调度（Round Robin）</h4>
<p>调度器通过“轮询”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。</p>
<h4 id="加权轮询weighted-round-robin-2"><a class="markdownIt-Anchor" href="#加权轮询weighted-round-robin-2"></a> 加权轮询（Weighted Round Robin）</h4>
<p>调度器通过“加权轮询”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器能处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p>
<h4 id="最少链接least-connections"><a class="markdownIt-Anchor" href="#最少链接least-connections"></a> 最少链接（Least Connections）</h4>
<p>调度器通过“最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用“最小连接”调度算法可以较好地均衡负载。</p>
<h4 id="加权最少链接weighted-least-connections"><a class="markdownIt-Anchor" href="#加权最少链接weighted-least-connections"></a> 加权最少链接（Weighted Least Connections）</h4>
<p>在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p>
<h4 id="基于局部性的最少链接locality-based-least-connections"><a class="markdownIt-Anchor" href="#基于局部性的最少链接locality-based-least-connections"></a> 基于局部性的最少链接（Locality-Based Least Connections）</h4>
<p>“基于局部性的最少链接”调度算法是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。该算法根据请求的目标 IP 地址找出该目标 IP 地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接” 的原则选出一个可用的服务器，将请求发送到该服务器。</p>
<h4 id="带复制的基于局部性最少链接locality-based-least-connections-with-replication"><a class="markdownIt-Anchor" href="#带复制的基于局部性最少链接locality-based-least-connections-with-replication"></a> 带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）</h4>
<p>“带复制的基于局部性最少链接”调度算法也是针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。它与 LBLC 算法的不同之处是它要维护从一个目标 IP 地址到一组服务器的映射，而 LBLC 算法维护从一个目标 IP 地址到一台服务器的映射。该算法根据请求的目标 IP 地址找出该目标 IP 地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p>
<h4 id="目标地址散列destination-hashing"><a class="markdownIt-Anchor" href="#目标地址散列destination-hashing"></a> 目标地址散列（Destination Hashing）</h4>
<p>“目标地址散列”调度算法根据请求的目标 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>
<h4 id="源地址散列source-hashing"><a class="markdownIt-Anchor" href="#源地址散列source-hashing"></a> 源地址散列（Source Hashing）</h4>
<p>“源地址散列”调度算法根据请求的源 IP 地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>
<p>除具备以上负载均衡算法外，还可以自定义均衡策略。</p>
<h3 id="64-lvs-场景"><a class="markdownIt-Anchor" href="#64-lvs-场景"></a> 6.4. LVS 场景</h3>
<p>一般作为入口负载均衡或内部负载均衡，结合反向代理服务器使用。相关架构可参考 Ngnix 场景架构。</p>
<h2 id="7-haproxy-负载均衡"><a class="markdownIt-Anchor" href="#7-haproxy-负载均衡"></a> 7. HaProxy 负载均衡</h2>
<p>HAProxy 也是使用较多的一款负载均衡软件。HAProxy 提供高可用性、负载均衡以及基于 TCP 和 HTTP 应用的代理，支持虚拟主机，是免费、快速并且可靠的一种解决方案。特别适用于那些负载特大的 web 站点。运行模式使得它可以很简单安全的整合到当前的架构中，同时可以保护你的 web 服务器不被暴露到网络上。</p>
<h3 id="71-haproxy-特点"><a class="markdownIt-Anchor" href="#71-haproxy-特点"></a> 7.1. HaProxy 特点</h3>
<ul>
<li>支持两种代理模式：TCP（四层）和 HTTP（七层），支持虚拟主机；</li>
<li>配置简单，支持 url 检测后端服务器状态；</li>
<li>做负载均衡软件使用，在高并发情况下，处理速度高于 nginx；</li>
<li>TCP 层多用于 Mysql 从（读）服务器负载均衡。 （对 Mysql 进行负载均衡，对后端的 DB 节点进行检测和负载均衡）</li>
<li>能够补充 Nginx 的一些缺点比如 Session 的保持，Cookie 引导等工作</li>
</ul>
<h3 id="72-haproxy-均衡策略"><a class="markdownIt-Anchor" href="#72-haproxy-均衡策略"></a> 7.2. HaProxy 均衡策略</h3>
<p>支持四种常用算法：</p>
<p>1.roundrobin：轮询，轮流分配到后端服务器；</p>
<p>2.static-rr：根据后端服务器性能分配；</p>
<p>3.leastconn：最小连接者优先处理；</p>
<p>4.source：根据请求源 IP，与 Nginx 的 IP_Hash 类似。</p>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（1）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5043452.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（2）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5080743.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（3）</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5080988.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（4）</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84/" class="post-title-link" itemprop="url">代码坏味道之非必要的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-21 13:20:31" itemprop="dateModified" datetime="2019-08-21T13:20:31+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/refactor/" itemprop="url" rel="index">
                    <span itemprop="name">refactor</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/refactor/代码坏味道之非必要的/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码坏味道之非必要的"><a class="markdownIt-Anchor" href="#代码坏味道之非必要的"></a> 代码坏味道之非必要的</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/dispensables" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/dispensables</a></p>
</blockquote>
<blockquote>
<p><strong>非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#%E5%86%97%E4%BD%99%E7%B1%BB">冗余类</a></li>
<li><a href="#%E5%A4%B8%E5%A4%B8%E5%85%B6%E8%B0%88%E6%9C%AA%E6%9D%A5%E6%80%A7">夸夸其谈未来性</a></li>
<li><a href="#%E7%BA%AF%E7%A8%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB">纯稚的数据类</a></li>
<li><a href="#%E8%BF%87%E5%A4%9A%E7%9A%84%E6%B3%A8%E9%87%8A">过多的注释</a></li>
<li><a href="#%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81">重复代码</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="冗余类"><a class="markdownIt-Anchor" href="#冗余类"></a> 冗余类</h2>
<blockquote>
<p>冗余类(Lazy Class)</p>
<p>理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/lazy-class-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。<br />
又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>没什么用的类可以运用 <code>将类内联化(Inline Class)</code> 来干掉。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/lazy-class-2.png"/></div>
<ul>
<li>如果子类用处不大，试试 <code>折叠继承体系(Collapse Hierarchy)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>减少代码量</li>
<li>易于维护</li>
</ul>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="将类内联化inline-class"><a class="markdownIt-Anchor" href="#将类内联化inline-class"></a> 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-after.png"/></div>
<h4 id="折叠继承体系collapse-hierarchy"><a class="markdownIt-Anchor" href="#折叠继承体系collapse-hierarchy"></a> 折叠继承体系(Collapse Hierarchy)</h4>
<p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-before.png"/></div>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-after.png"/></div>
<h2 id="夸夸其谈未来性"><a class="markdownIt-Anchor" href="#夸夸其谈未来性"></a> 夸夸其谈未来性</h2>
<blockquote>
<p>夸夸其谈未来性(Speculative Generality)</p>
<p>存在未被使用的类、函数、字段或参数。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/speculative-generality-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>如果你的某个抽象类其实没有太大作用，请运用 <code>折叠继承体系(Collapse Hierarch)</code> 。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/speculative-generality-2.png"/></div>
<ul>
<li>不必要的委托可运用 <code>将类内联化(Inline Class)</code> 消除。</li>
<li>无用的函数可运用 <code>内联函数(Inline Method)</code> 消除。</li>
<li>函数中有无用的参数应该运用 <code>移除参数(Remove Parameter)</code> 消除。</li>
<li>无用字段可以直接删除。</li>
</ul>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>减少代码量。</li>
<li>更易维护。</li>
</ul>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<ul>
<li>如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。</li>
<li>删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="折叠继承体系collapse-hierarchy-2"><a class="markdownIt-Anchor" href="#折叠继承体系collapse-hierarchy-2"></a> 折叠继承体系(Collapse Hierarchy)</h4>
<p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-before.png"/></div>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/collapse-hierarchy-after.png"/></div>
<h4 id="将类内联化inline-class-2"><a class="markdownIt-Anchor" href="#将类内联化inline-class-2"></a> 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-after.png"/></div>
<h4 id="内联函数inline-method"><a class="markdownIt-Anchor" href="#内联函数inline-method"></a> 内联函数(Inline Method)</h4>
<p><strong>问题</strong></p>
<p>一个函数的本体比函数名更清楚易懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaDelivery</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moreThanFiveLateDeliveries() ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">moreThanFiveLateDeliveries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在函数调用点插入函数本体，然后移除该函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaDelivery</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除参数remove-parameter"><a class="markdownIt-Anchor" href="#移除参数remove-parameter"></a> 移除参数(Remove Parameter)</h4>
<p><strong>问题</strong></p>
<p>函数本体不再需要某个参数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-parameter-before.png"/></div>
<p><strong>解决</strong></p>
<p>将该参数去除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-parameter-after.png"/></div>
<h2 id="纯稚的数据类"><a class="markdownIt-Anchor" href="#纯稚的数据类"></a> 纯稚的数据类</h2>
<blockquote>
<p><code>纯稚的数据类(Data Class)</code> 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-class-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>当一个新创建的类只包含几个公共字段（甚至可能几个 getters / setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<ul>
<li>如果一个类有公共字段，你应该运用 <code>封装字段(Encapsulated Field)</code> 来隐藏字段的直接访问方式。</li>
<li>如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 <code>封装集合(Encapsulated Collection)</code> 把它们封装起来。</li>
<li>找出这些 getter/setter 函数被其他类运用的地点。尝试以 <code>搬移函数(Move Method)</code> 把那些调用行为搬移到 <code>纯稚的数据类(Data Class)</code> 来。如果无法搬移这个函数，就运用 <code>提炼函数(Extract Method)</code> 产生一个可搬移的函数。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/data-class-2.png"/></div>
<ul>
<li>在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 <code>移除设置函数(Remove Setting Method)</code> 和 <code>隐藏函数(Hide Method)</code> 。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。</li>
<li>帮助你发现客户端代码的重复处。</li>
</ul>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="封装字段encapsulated-field"><a class="markdownIt-Anchor" href="#封装字段encapsulated-field"></a> 封装字段(Encapsulated Field)</h4>
<p><strong>问题</strong></p>
<p>你的类中存在 public 字段。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将它声明为 private，并提供相应的访问函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> arg)</span> </span>&#123;</span><br><span class="line">    name = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="封装集合encapsulated-collection"><a class="markdownIt-Anchor" href="#封装集合encapsulated-collection"></a> 封装集合(Encapsulated Collection)</h4>
<p><strong>问题</strong></p>
<p>有个函数返回一个集合。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/encapsulate-collection-before.png"/></div>
<p><strong>解决</strong></p>
<p>让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/encapsulate-collection-after.png"/></div>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除设置函数remove-setting-method"><a class="markdownIt-Anchor" href="#移除设置函数remove-setting-method"></a> 移除设置函数(Remove Setting Method)</h4>
<p><strong>问题</strong></p>
<p>类中的某个字段应该在对象创建时被设值，然后就不再改变。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-setting-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>去掉该字段的所有设值函数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/remove-setting-method-after.png"/></div>
<h4 id="隐藏函数hide-method"><a class="markdownIt-Anchor" href="#隐藏函数hide-method"></a> 隐藏函数(Hide Method)</h4>
<p><strong>问题</strong></p>
<p>有一个函数，从来没有被其他任何类用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个函数修改为 private。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/hide-method-after.png"/></div>
<h2 id="过多的注释"><a class="markdownIt-Anchor" href="#过多的注释"></a> 过多的注释</h2>
<blockquote>
<p>过多的注释(Comments)</p>
<p>注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/comments-1.png"/></div>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。</p>
<blockquote>
<p>最好的注释是为函数或类起一个恰当的名字。</p>
</blockquote>
<p>如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。</p>
<h3 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法</h3>
<ul>
<li>如果一个注释是为了解释一个复杂的表达式，可以运用 <code>提炼变量(Extract Variable)</code> 将表达式切分为易理解的子表达式。</li>
<li>如果你需要通过注释来解释一段代码做了什么，请试试 <code>提炼函数(Extract Method)</code> 。</li>
<li>如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 <code>函数改名(Rename Method)</code> 来为函数起一个可以自解释的名字。</li>
<li>如果需要对系统某状态进行断言，请运用 <code>引入断言(Introduce Assertion)</code> 。</li>
</ul>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>代码变得更直观和明显。</li>
</ul>
<h3 id="何时忽略-3"><a class="markdownIt-Anchor" href="#何时忽略-3"></a> 何时忽略</h3>
<p>注释有时候很有用：</p>
<ul>
<li>当解释为什么某事物要以特殊方式实现时。</li>
<li>当解释某种复杂算法时。</li>
<li>当你实在不知可以做些什么时。</li>
</ul>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="提炼变量extract-variable"><a class="markdownIt-Anchor" href="#提炼变量extract-variable"></a> 提炼变量(Extract Variable)</h4>
<p><strong>问题</strong></p>
<p>你有个难以理解的表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderBanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">       (browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">        wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将表达式的结果或它的子表达式的结果用不言自明的变量来替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderBanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isMacOs = platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isIE = browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMacOs &amp;&amp; isIE &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提炼函数extract-method-2"><a class="markdownIt-Anchor" href="#提炼函数extract-method-2"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数改名rename-method"><a class="markdownIt-Anchor" href="#函数改名rename-method"></a> 函数改名(Rename Method)</h4>
<p><strong>问题</strong></p>
<p>函数的名称未能恰当的揭示函数的用途。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getsnm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>修改函数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSecondName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入断言introduce-assertion"><a class="markdownIt-Anchor" href="#引入断言introduce-assertion"></a> 引入断言(Introduce Assertion)</h4>
<p><strong>问题</strong></p>
<p>某一段代码需要对程序状态做出某种假设。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getExpenseLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// should have either expense limit or a primary project</span></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>以断言明确表现这种假设。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getExpenseLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。</em></p>
<h2 id="重复代码"><a class="markdownIt-Anchor" href="#重复代码"></a> 重复代码</h2>
<blockquote>
<p>重复代码(Duplicate Code)</p>
<p>重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。</p>
</blockquote>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-code-1.png"/></div>
<h3 id="问题原因-5"><a class="markdownIt-Anchor" href="#问题原因-5"></a> 问题原因</h3>
<p>重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。</p>
<p>还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。</p>
<p>有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。</p>
<h3 id="解决方法-5"><a class="markdownIt-Anchor" href="#解决方法-5"></a> 解决方法</h3>
<ul>
<li>同一个类的两个函数含有相同的表达式，这时可以采用 <code>提炼函数(Extract Method)</code> 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/duplicate-code-2.png"/></div>
<ul>
<li>如果两个互为兄弟的子类含有重复代码：
<ul>
<li>首先对两个类都运用 <code>提炼函数(Extract Method)</code> ，然后对被提炼出来的函数运用 <code>函数上移(Pull Up Method)</code> ，将它推入超类。</li>
<li>如果重复代码在构造函数中，运用 <code>构造函数本体上移(Pull Up Constructor Body)</code> 。</li>
<li>如果重复代码只是相似但不是完全相同，运用 <code>塑造模板函数(Form Template Method)</code> 获得一个 <strong>模板方法模式(Template Method)</strong> 。</li>
<li>如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 <code>替换算法(Substitute Algorithm)</code> 将其他函数的算法替换掉。</li>
</ul>
</li>
<li>如果两个毫不相关的类中有重复代码：
<ul>
<li>请尝试运用 <code>提炼超类(Extract Superclass)</code> ，以便为维护所有先前功能的这些类创建一个超类。</li>
<li>如果创建超类十分困难，可以在一个类中运用 <code>提炼类(Extract Class)</code> ，并在另一个类中使用这个新的组件。</li>
</ul>
</li>
<li>如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 <code>合并条件表达式(Consolidate Conditional Expression)</code> 将这些操作合并为单个条件，并运用 <code>提炼函数(Extract Method)</code> 将该条件放入一个名字容易理解的独立函数中。</li>
<li>如果条件表达式的所有分支都有部分相同的代码片段：可以运用 <code>合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</code> 将它们都存在的代码片段置于条件表达式外部。</li>
</ul>
<h3 id="收益-5"><a class="markdownIt-Anchor" href="#收益-5"></a> 收益</h3>
<ul>
<li>合并重复代码会简化代码的结构，并减少代码量。</li>
<li>代码更简化、更易维护。</li>
</ul>
<h3 id="重构方法说明-5"><a class="markdownIt-Anchor" href="#重构方法说明-5"></a> 重构方法说明</h3>
<h4 id="提炼函数extract-method-3"><a class="markdownIt-Anchor" href="#提炼函数extract-method-3"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数上移pull-up-method"><a class="markdownIt-Anchor" href="#函数上移pull-up-method"></a> 函数上移(Pull Up Method)</h4>
<p><strong>问题</strong></p>
<p>有些函数，在各个子类中产生完全相同的结果。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/pull-up-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>将该函数移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/pull-up-method-after.png"/></div>
<h4 id="构造函数本体上移pull-up-constructor-body"><a class="markdownIt-Anchor" href="#构造函数本体上移pull-up-constructor-body"></a> 构造函数本体上移(Pull Up Constructor Body)</h4>
<p><strong>问题</strong></p>
<p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在超类中新建一个构造函数，并在子类构造函数中调用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, id);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="塑造模板函数form-template-method"><a class="markdownIt-Anchor" href="#塑造模板函数form-template-method"></a> 塑造模板函数(Form Template Method)</h4>
<p><strong>问题</strong></p>
<p>你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/form-template-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/form-template-method-after.png"/></div>
<p><em>注：这里只提到具体做法，建议了解一下模板方法设计模式。</em></p>
<h4 id="替换算法substitute-algorithm"><a class="markdownIt-Anchor" href="#替换算法substitute-algorithm"></a> 替换算法(Substitute Algorithm)</h4>
<p><strong>问题</strong></p>
<p>你想要把某个算法替换为另一个更清晰的算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"Don"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"John"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"Kent"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将函数本体替换为另一个算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">  List candidates =</span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates.contains(people[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> people[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提炼超类extract-superclass"><a class="markdownIt-Anchor" href="#提炼超类extract-superclass"></a> 提炼超类(Extract Superclass)</h4>
<p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-before.png"/></div>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-superclass-after.png"/></div>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h4 id="合并条件表达式consolidate-conditional-expression"><a class="markdownIt-Anchor" href="#合并条件表达式consolidate-conditional-expression"></a> 合并条件表达式(Consolidate Conditional Expression)</h4>
<p><strong>问题</strong></p>
<p>你有一系列条件分支，都得到相同结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (seniority &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (monthsDisabled &gt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isPartTime) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotEligableForDisability()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并重复的条件片段consolidate-duplicate-conditional-fragments"><a class="markdownIt-Anchor" href="#合并重复的条件片段consolidate-duplicate-conditional-fragments"></a> 合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</h4>
<p><strong>问题</strong></p>
<p>在条件表达式的每个分支上有着相同的一段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这段重复代码搬移到条件表达式之外。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">&#125;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D/" class="post-title-link" itemprop="url">代码坏味道之变革的障碍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-21 13:20:29" itemprop="dateModified" datetime="2019-08-21T13:20:29+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/refactor/" itemprop="url" rel="index">
                    <span itemprop="name">refactor</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/refactor/代码坏味道之变革的障碍/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码坏味道之变革的障碍"><a class="markdownIt-Anchor" href="#代码坏味道之变革的障碍"></a> 代码坏味道之变革的障碍</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/change-preventers" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/change-preventers</a></p>
</blockquote>
<blockquote>
<p><strong>变革的障碍(Change Preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#%E5%8F%91%E6%95%A3%E5%BC%8F%E5%8F%98%E5%8C%96">发散式变化</a></li>
<li><a href="#%E5%B9%B3%E8%A1%8C%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB">平行继承体系</a></li>
<li><a href="#%E9%9C%B0%E5%BC%B9%E5%BC%8F%E4%BF%AE%E6%94%B9">霰弹式修改</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="发散式变化"><a class="markdownIt-Anchor" href="#发散式变化"></a> 发散式变化</h2>
<blockquote>
<p><code>发散式变化(Divergent Change)</code> 类似于 <code>霰弹式修改(Shotgun Surgery)</code> ，但实际上完全不同。<code>发散式变化(Divergent Change)</code> 是指一个类受多种变化的影响。<code>霰弹式修改(Shotgun Surgery)</code> 是指多种变化引发多个类相应的修改。</p>
</blockquote>
<h3 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h3>
<p>你发现你想要修改一个函数，却必须要同时修改许多不相关的函数。例如，当你想要添加一个新的产品类型时，你需要同步修改对产品进行查找、显示、排序的函数。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/divergent-change-1.png"/></div>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>通常，这种发散式修改是由于编程结构不合理或者“复制-粘贴式编程”。</p>
<h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h3>
<ul>
<li>运用 <code>提炼类(Extract Class)</code> 拆分类的行为。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>提高代码组织结构</li>
<li>减少重复代码</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/extract-class-after.png"/></div>
<h2 id="平行继承体系"><a class="markdownIt-Anchor" href="#平行继承体系"></a> 平行继承体系</h2>
<blockquote>
<p><code>平行继承体系(Parallel Inheritance Hierarchies)</code> 其实是 <code>霰弹式修改(Shotgun Surgery)</code> 的特殊情况。</p>
</blockquote>
<h3 id="特征-2"><a class="markdownIt-Anchor" href="#特征-2"></a> 特征</h3>
<p>每当你为某个类添加一个子类，必须同时为另一个类相应添加一个子类。这种情况的典型特征是：某个继承体系的类名前缀或类名后缀完全相同。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/parallel-inheritance-hierarchies-1.png"/></div>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>起初的继承体系很小，随着不断添加新类，继承体系越来越大，也越来越难修改。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用 <code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code>，就可以消除引用端的继承体系。</li>
</ul>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>更好的代码组织</li>
<li>减少重复代码</li>
</ul>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>有时具有并行类层次结构只是一种为了避免程序体系结构更混乱的方法。如果你发现尝试消除平行继承体系导致代码更加丑陋，那么你应该回滚你的修改。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="搬移字段move-field"><a class="markdownIt-Anchor" href="#搬移字段move-field"></a> 搬移字段(Move Field)</h4>
<p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-before.png"/></div>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-after.png"/></div>
<h2 id="霰弹式修改"><a class="markdownIt-Anchor" href="#霰弹式修改"></a> 霰弹式修改</h2>
<blockquote>
<p><code>霰弹式修改(Shotgun Surgery)</code> 类似于 <code>发散式变化(Divergent Change)</code> ，但实际上完全不同。<code>发散式变化(Divergent Change)</code> 是指一个类受多种变化的影响。<code>霰弹式修改(Shotgun Surgery)</code> 是指多种变化引发多个类相应的修改。</p>
</blockquote>
<h3 id="特征-3"><a class="markdownIt-Anchor" href="#特征-3"></a> 特征</h3>
<p>任何修改都需要在许多不同类上做小幅度修改。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/shotgun-surgery-1.png"/></div>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>一个单一的职责被拆分成大量的类。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<ul>
<li>运用<code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code> 来搬移不同类中相同的行为到一个独立类中。如果没有适合存放搬移函数或字段的类，就创建一个新类。</li>
<li>通常，可以运用 <code>将类内联化(Inline Class)</code> 将一些列相关行为放进同一个类。</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/shotgun-surgery-2.png"/></div>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>更好的代码组织</li>
<li>减少重复代码</li>
<li>更易维护</li>
</ul>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/shotgun-surgery-3.png"/></div>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method-2"><a class="markdownIt-Anchor" href="#搬移函数move-method-2"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-before.png"/></div>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-method-after.png"/></div>
<h4 id="搬移字段move-field-2"><a class="markdownIt-Anchor" href="#搬移字段move-field-2"></a> 搬移字段(Move Field)</h4>
<p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-before.png"/></div>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/move-field-after.png"/></div>
<h4 id="将类内联化inline-class"><a class="markdownIt-Anchor" href="#将类内联化inline-class"></a> 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-before.png"/></div>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/inline-class-after.png"/></div>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/refactor/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84/" class="post-title-link" itemprop="url">代码的坏味道和重构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-21 13:20:31" itemprop="dateModified" datetime="2019-08-21T13:20:31+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/refactor/" itemprop="url" rel="index">
                    <span itemprop="name">refactor</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/refactor/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/refactor/代码的坏味道和重构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码的坏味道和重构"><a class="markdownIt-Anchor" href="#代码的坏味道和重构"></a> 代码的坏味道和重构</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%97%87%E4%B8%8E%E8%8D%AF">症与药</a>
<ul>
<li><a href="#%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E7%9A%84%E6%80%9D%E8%80%83">对代码的坏味道的思考</a></li>
<li><a href="#%E9%87%8D%E6%9E%84%E7%9A%84%E5%8E%9F%E5%88%99">重构的原则</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93">代码的坏味道</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF">代码坏味道之代码臃肿</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">代码坏味道之滥用面向对象</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D">代码坏味道之变革的障碍</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84">代码坏味道之非必要的</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88">代码坏味道之耦合</a></li>
</ul>
</li>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<p>第一次读《重构:改善既有代码的设计》时，我曾整理过一个简单的笔记。最近，因为参与一个重构项目，再一次温习了《重构:改善既有代码的设计》。过程中，萌发了认真总结、整理重构方法的冲动，于是有了这系列文字。</p>
<p>代码的坏味道还有几篇没有完稿，后面我会陆续补充。。。</p>
<h2 id="症与药"><a class="markdownIt-Anchor" href="#症与药"></a> 症与药</h2>
<h3 id="对代码的坏味道的思考"><a class="markdownIt-Anchor" href="#对代码的坏味道的思考"></a> 对代码的坏味道的思考</h3>
<p>“有病要早治，不要放弃治疗”。多么朴素的道理 ，人人都懂。</p>
<p>病，就是不健康。</p>
<p>人有病，可以通过打针、吃药、做手术来进行治疗。</p>
<p><strong>如果把代码的坏味道（代码质量问题）比作病症，那么重构就是治疗代码的坏味道的药。</strong></p>
<p>个人认为，在重构这件事上，也可以应用治病的道理：</p>
<ul>
<li>
<p><strong>防病于未然。</strong><br />
—— 春秋战国时期的一代名医扁鹊，曾经有个很著名的医学主张：<strong>防病于未然</strong>。 我觉得这个道理应用于软件代码的重构亦然。编程前要有合理的设计、编程时要有良好的编程风格，尽量减少问题。从这个层面上说，了解代码的坏味道，不仅仅是为了发现问题、解决问题。更重要的作用是：指导我们在编程过程中有意识的去规避这些问题。</p>
</li>
<li>
<p><strong>小病不医，易得大病。</strong><br />
—— 刘备说过：“勿以善小而不为，勿以恶小而为之”。发现问题就及时修改，代码质量自然容易进入良性循环；反之，亦然。要重视积累的力量，别总以为代码出现点小问题，那都不是事儿。</p>
</li>
<li>
<p><strong>对症下药。</strong><br />
—— 程序出现了问题，要分析出问题的根本，有针对性的制定合理的重构方案。大家都知道吃错药的后果，同样的，<strong>瞎改还不如不改</strong>。</p>
</li>
<li>
<p><strong>忌猛药</strong><br />
—— 医病用猛药容易产生副作用。换一句俗语：步子大了容易扯着蛋。重构如果大刀阔斧的干，那你就要有随时可能扑街的心理准备。推倒重来不是重构，而是重写。重构应该是循序渐进，步步为营的过程。当你发现重写代码比重构代码更简单，往往说明你早就该重构了。</p>
</li>
</ul>
<h3 id="重构的原则"><a class="markdownIt-Anchor" href="#重构的原则"></a> 重构的原则</h3>
<p>前面把代码质量问题比作病症，而把重构比作药。这里，我们再进一步讨论一下重构的原则。</p>
<h4 id="何谓重构what"><a class="markdownIt-Anchor" href="#何谓重构what"></a> 何谓重构(What)</h4>
<p><code>重构（Refactoring）</code> 的常见定义是：不改变软件系统外部行为的前提下，改善它的内部结构。</p>
<p>个人觉得这个定义有点生涩。不妨理解为：重构是给代码治病的行为。而代码有病是指代码的质量（可靠性、安全性、可复用性、可维护性）和性能有问题。</p>
<p><strong>重构的目的是为了提高代码的质量和性能</strong>。</p>
<p><em>注：功能不全或者不正确，那是残疾代码。就像治病治不了残疾，重构也解决不了功能问题。</em></p>
<h4 id="为何重构why"><a class="markdownIt-Anchor" href="#为何重构why"></a> 为何重构(Why)</h4>
<p>翻翻书，上网搜一下，谈到重构的理由大体相同：</p>
<ul>
<li>重构改进软件设计</li>
<li>重构使软件更容易理解</li>
<li>重构帮助找到 bug</li>
<li>重构提高编程速度</li>
</ul>
<p>总之就是，<strong>重构可以提高代码质量</strong>。</p>
<h4 id="何时重构when"><a class="markdownIt-Anchor" href="#何时重构when"></a> 何时重构(When)</h4>
<p>关于何时重构，我先引用一下 <a href="http://mt.sohu.com/20160812/n463980993.shtml" target="_blank" rel="noopener"><u>重构并非难在如何做，而是难在何时开始做</u></a> 一文的观点。</p>
<blockquote>
<p>对于一个高速发展的公司来说，停止业务开发，专门来做重构项目，<strong>从来就不是一个可接受的选项</strong>，“边开飞机边换引擎”才是这种公司想要的。</p>
</blockquote>
<p>我们不妨来衡量一下重构的成本和收益。</p>
<ul>
<li>
<p><strong>重构的成本</strong></p>
<p>重构是有成本的，费时费力（时间、人力）不说，还有可能会使本来正常运行的程序出错。所以，很多人都抱着“不求有功，但求无过”的心理得过且过。</p>
<p>还有一种成本：重构使用较新且较为复杂的技术，学习曲线不平滑，团队成员技术切换困难，短期内开发效率可能不升反降。</p>
<p>但是，如果一直放任代码腐朽下去，技术债务会越来越沉重。当代码最终快要跑不动时，架构师们往往还是不得不使用激进的手段来治疗代码的顽疾。但是，这个过程通常都是非常痛苦的，而且有着很高的失败风险。</p>
</li>
<li>
<p><strong>重构的收益</strong></p>
<p>重构的收益是提高代码的质量和性能，并提高未来的开发效率。但是，应当看到，重构往往并不能在短期内带来实际的效益，或者很难直观看出效益。而对于一个企业来说，没有什么比效益更重要。换句话说，没有实际效益的事，通常也没有价值。很多领导，尤其是非技术方向的领导，并不关心你应用了什么新技术，让代码变得多么优雅等等。</p>
</li>
<li>
<p><strong>重构的合适时机</strong></p>
<p>从以上来看，重构实在是个吃力不讨好的事情。</p>
<p>于是，很多人屈服于万恶的 KPI 和要命的 deadline，一边吐槽着以前的代码是垃圾，一边自己也在造垃圾。</p>
<p>但是，**重构本应该是个渐进式的过程，不是只有伤筋动骨的改造才叫重构。**如果非要等到代码已经烂到病入膏肓，再使用激进方式来重构，那必然是困难重重，风险极高。</p>
<p>《重构》书中提到的重构时机应该在添加功能、修复功能、审查代码时，不建议专门抽出时间专门做重构项目。</p>
<p>我认为，其思想就是指：<strong>重构应该是在开发过程中实时的、渐进的演化过程。</strong></p>
</li>
<li>
<p><strong>重构的不恰当时机</strong></p>
<p>但是，这里我也要强调一下：<strong>不是所有软件开发过程都一定要重构。</strong></p>
<p>较能<strong>凸显重构价值的场景</strong>是：代码规模较大、生命周期还较长、承担了较多责任、有一个较大（且较不稳定，人员流动频繁）团队在其上工作的单一代码库。</p>
<p>与之相反，有一些场景的重构价值就很小：</p>
<ul>
<li>代码库生命周期快要走到尾声，开发逐渐减少，以维护为主。</li>
<li>代码库当前版本马上要发布了，这时重构无疑是给自己找麻烦。</li>
<li>重构代价过于沉重：重构后功能的正确性、稳定性难以保障；技术过于超前，团队成员技术迁移难度太大。</li>
</ul>
</li>
</ul>
<h4 id="如何重构how"><a class="markdownIt-Anchor" href="#如何重构how"></a> 如何重构(How)</h4>
<p>重构行为在我看来，也是可以分层级的。由高到低，越高层级难度越大：</p>
<ul>
<li>
<p>服务、数据库<br />
现代软件往往业务复杂、庞大。使用微服务、数据迁移来拆分业务，降低业务复杂度成为了主流。但是，这些技术的测试、部署复杂，技术难度很高。</p>
</li>
<li>
<p>组件、模块、框架<br />
组件、模块、框架的重构，主要是针对代码的设计问题。解决的是代码的整体结构问题。需要对框架、设计模式、分布式、并发等等有足够的了解。</p>
</li>
<li>
<p>类、接口、函数、字段<br />
《重构》一书提到了**“代码的坏味道”**以及相关的重构方法。这些都是对类、接口、函数、字段级别代码的重构手段。由于这一级别的重构方法较为简单，所以可操作性较强。具体细节可以阅读《代码的坏味道》篇章。</p>
</li>
</ul>
<p>前两种层级的重构已经涉及到架构层面，影响较大，难度较高，如果功力不够不要轻易变动。由于这两个层级涉及领域较广，这里不做论述。</p>
<p><u><strong><em>此处为分割线。下面是代码的坏味道系列。。。</em></strong></u></p>
<h2 id="代码的坏味道"><a class="markdownIt-Anchor" href="#代码的坏味道"></a> 代码的坏味道</h2>
<p>《重构:改善既有代码的设计》中介绍了 22 种代码的坏味道以及重构手法。这些坏味道可以进一步归类。我总觉得将事物分类有助于理解和记忆。所以本系列将坏味道按照特性分类，然后逐一讲解。</p>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/design/refactor/code-smell.png"/></div>
<h3 id="代码坏味道之代码臃肿"><a class="markdownIt-Anchor" href="#代码坏味道之代码臃肿"></a> 代码坏味道之代码臃肿</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码臃肿(Bloated)</a>这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E8%BF%87%E9%95%BF%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">过长函数</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E8%BF%87%E5%A4%A7%E7%9A%84%E7%B1%BB" target="_blank" rel="noopener">过大的类</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%81%8F%E6%89%A7" target="_blank" rel="noopener">基本类型偏执</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E8%BF%87%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97" target="_blank" rel="noopener">过长参数列</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md#%E6%95%B0%E6%8D%AE%E6%B3%A5%E5%9B%A2" target="_blank" rel="noopener">数据泥团</a></li>
</ul>
<h3 id="代码坏味道之滥用面向对象"><a class="markdownIt-Anchor" href="#代码坏味道之滥用面向对象"></a> 代码坏味道之滥用面向对象</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">滥用面向对象(Object-Orientation Abusers)</a>这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#switch-%E5%A3%B0%E6%98%8E" target="_blank" rel="noopener">switch 声明</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#%E4%B8%B4%E6%97%B6%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">临时字段</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#%E8%A2%AB%E6%8B%92%E7%BB%9D%E7%9A%84%E9%A6%88%E8%B5%A0" target="_blank" rel="noopener">被拒绝的馈赠</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md#%E5%BC%82%E6%9B%B2%E5%90%8C%E5%B7%A5%E7%9A%84%E7%B1%BB" target="_blank" rel="noopener">异曲同工的类</a></li>
</ul>
<h3 id="代码坏味道之变革的障碍"><a class="markdownIt-Anchor" href="#代码坏味道之变革的障碍"></a> 代码坏味道之变革的障碍</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">变革的障碍(Change Preventers)</a>这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md#%E5%8F%91%E6%95%A3%E5%BC%8F%E5%8F%98%E5%8C%96" target="_blank" rel="noopener">发散式变化</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md#%E9%9C%B0%E5%BC%B9%E5%BC%8F%E4%BF%AE%E6%94%B9" target="_blank" rel="noopener">霰弹式修改</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md#%E5%B9%B3%E8%A1%8C%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB" target="_blank" rel="noopener">平行继承体系</a></li>
</ul>
<h3 id="代码坏味道之非必要的"><a class="markdownIt-Anchor" href="#代码坏味道之非必要的"></a> 代码坏味道之非必要的</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">非必要的(Dispensables)</a>这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E8%BF%87%E5%A4%9A%E7%9A%84%E6%B3%A8%E9%87%8A" target="_blank" rel="noopener">过多的注释</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">重复代码</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E5%86%97%E4%BD%99%E7%B1%BB" target="_blank" rel="noopener">冗余类</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E7%BA%AF%E7%A8%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB" target="_blank" rel="noopener">纯稚的数据类</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md#%E5%A4%B8%E5%A4%B8%E5%85%B6%E8%B0%88%E6%9C%AA%E6%9D%A5%E6%80%A7" target="_blank" rel="noopener">夸夸其谈未来性</a></li>
</ul>
<h3 id="代码坏味道之耦合"><a class="markdownIt-Anchor" href="#代码坏味道之耦合"></a> 代码坏味道之耦合</h3>
<blockquote>
<p><strong><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">耦合(Couplers)</a>这组坏味道意味着：不同类之间过度耦合。</strong></p>
</blockquote>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E4%BE%9D%E6%81%8B%E6%83%85%E7%BB%93" target="_blank" rel="noopener">依恋情结</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E7%8B%8E%E6%98%B5%E5%85%B3%E7%B3%BB" target="_blank" rel="noopener">狎昵关系</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E8%BF%87%E5%BA%A6%E8%80%A6%E5%90%88%E7%9A%84%E6%B6%88%E6%81%AF%E9%93%BE" target="_blank" rel="noopener">过度耦合的消息链</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E4%B8%AD%E9%97%B4%E4%BA%BA" target="_blank" rel="noopener">中间人</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md#%E4%B8%8D%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%BA%93%E7%B1%BB" target="_blank" rel="noopener">不完美的库类</a></li>
</ul>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/design/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构——改善既有代码的设计</a> - by Martin Fowler</li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">分布式原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-17 09:18:15" itemprop="dateModified" datetime="2019-10-17T09:18:15+08:00">2019-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/" itemprop="url" rel="index">
                    <span itemprop="name">design</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/design/architecture/" itemprop="url" rel="index">
                    <span itemprop="name">architecture</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="design/architecture/分布式原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式原理"><a class="markdownIt-Anchor" href="#分布式原理"></a> 分布式原理</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%AF%E8%AF%AD">1. 分布式术语</a>
<ul>
<li><a href="#11-%E5%BC%82%E5%B8%B8">1.1. 异常</a></li>
<li><a href="#12-%E8%B6%85%E6%97%B6">1.2. 超时</a></li>
<li><a href="#13-%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87">1.3. 衡量指标</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">2. 数据分布</a>
<ul>
<li><a href="#21-%E5%93%88%E5%B8%8C%E5%88%86%E5%B8%83">2.1. 哈希分布</a></li>
<li><a href="#22-%E9%A1%BA%E5%BA%8F%E5%88%86%E5%B8%83">2.2. 顺序分布</a></li>
<li><a href="#23-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2.3. 负载均衡</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA">3. 分布式理论</a>
<ul>
<li><a href="#31-cap">3.1. CAP</a></li>
<li><a href="#32-base">3.2. BASE</a></li>
</ul>
</li>
<li><a href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">4. 分布式事务问题</a>
<ul>
<li><a href="#41-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A42pc">4.1. 两阶段提交（2PC）</a></li>
<li><a href="#42-%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1tcc">4.2. 补偿事务（TCC）</a></li>
<li><a href="#43-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D">4.3. 本地消息表（异步确保）</a></li>
<li><a href="#44-mq-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">4.4. MQ 事务消息</a></li>
</ul>
</li>
<li><a href="#5-%E5%85%B1%E8%AF%86%E6%80%A7%E9%97%AE%E9%A2%98">5. 共识性问题</a>
<ul>
<li><a href="#51-paxos">5.1. Paxos</a></li>
<li><a href="#52-raft">5.2. Raft</a></li>
</ul>
</li>
<li><a href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">6. 分布式缓存问题</a>z
<ul>
<li><a href="#61-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">6.1. 缓存雪崩</a></li>
<li><a href="#62-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">6.2. 缓存穿透</a>z</li>
<li><a href="#63-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">6.3. 缓存预热</a></li>
<li><a href="#64-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0">6.4. 缓存更新</a></li>
<li><a href="#65-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7">6.5. 缓存降级</a></li>
</ul>
</li>
<li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-分布式术语"><a class="markdownIt-Anchor" href="#1-分布式术语"></a> 1. 分布式术语</h2>
<h3 id="11-异常"><a class="markdownIt-Anchor" href="#11-异常"></a> 1.1. 异常</h3>
<h4 id="服务器宕机"><a class="markdownIt-Anchor" href="#服务器宕机"></a> 服务器宕机</h4>
<p>内存错误、服务器停电等都会导致服务器宕机，此时节点无法正常工作，称为不可用。</p>
<p>服务器宕机会导致节点失去所有内存信息，因此需要将内存信息保存到持久化介质上。</p>
<h4 id="网络异常"><a class="markdownIt-Anchor" href="#网络异常"></a> 网络异常</h4>
<p>有一种特殊的网络异常称为——<strong>网络分区</strong> ，即集群的所有节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<h4 id="磁盘故障"><a class="markdownIt-Anchor" href="#磁盘故障"></a> 磁盘故障</h4>
<p>磁盘故障是一种发生概率很高的异常。</p>
<p>使用冗余机制，将数据存储到多台服务器。</p>
<h3 id="12-超时"><a class="markdownIt-Anchor" href="#12-超时"></a> 1.2. 超时</h3>
<p>在分布式系统中，一个请求除了成功和失败两种状态，还存在着超时状态。</p>
<p>可以将服务器的操作设计为具有 <strong>幂等性</strong> ，即执行多次的结果与执行一次的结果相同。如果使用这种方式，当出现超时的时候，可以不断地重新请求直到成功。</p>
<h3 id="13-衡量指标"><a class="markdownIt-Anchor" href="#13-衡量指标"></a> 1.3. 衡量指标</h3>
<h4 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h4>
<p>常见的性能指标有：吞吐量、响应时间。</p>
<p>其中，吞吐量指系统在某一段时间可以处理的请求总数，通常为每秒的读操作数或者写操作数；响应时间指从某个请求发出到接收到返回结果消耗的时间。</p>
<p>这两个指标往往是矛盾的，追求高吞吐的系统，往往很难做到低响应时间，解释如下：</p>
<ul>
<li>
<p>在无并发的系统中，吞吐量为响应时间的倒数，例如响应时间为 10 ms，那么吞吐量为 100 req/s，因此高吞吐也就意味着低响应时间。</p>
</li>
<li>
<p>但是在并发的系统中，由于一个请求在调用 I/O 资源的时候，需要进行等待。服务器端一般使用的是异步等待方式，即等待的请求被阻塞之后不需要一直占用 CPU 资源。这种方式能大大提高 CPU 资源的利用率，例如上面的例子中，单个请求在无并发的系统中响应时间为 10 ms，如果在并发的系统中，那么吞吐量将大于 100 req/s。因此为了追求高吞吐量，通常会提高并发程度。但是并发程度的增加，会导致请求的平均响应时间也增加，因为请求不能马上被处理，需要和其它请求一起进行并发处理，响应时间自然就会增高。</p>
</li>
</ul>
<h4 id="可用性"><a class="markdownIt-Anchor" href="#可用性"></a> 可用性</h4>
<p>可用性指系统在面对各种异常时可以提供正常服务的能力。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<h4 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h4>
<p>可以从两个角度理解一致性：从客户端的角度，读写操作是否满足某种特性；从服务器的角度，多个数据副本之间是否一致。</p>
<h4 id="可扩展性"><a class="markdownIt-Anchor" href="#可扩展性"></a> 可扩展性</h4>
<p>指系统通过扩展集群服务器规模来提高性能的能力。理想的分布式系统需要实现“线性可扩展”，即随着集群规模的增加，系统的整体性能也会线性增加。</p>
<h2 id="2-数据分布"><a class="markdownIt-Anchor" href="#2-数据分布"></a> 2. 数据分布</h2>
<p>分布式存储系统的数据分布在多个节点中，常用的数据分布方式有哈希分布和顺序分布。</p>
<p>数据库的水平切分（Sharding）也是一种分布式存储方法，下面的数据分布方法同样适用于 Sharding。</p>
<h3 id="21-哈希分布"><a class="markdownIt-Anchor" href="#21-哈希分布"></a> 2.1. 哈希分布</h3>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<p><strong>一致性哈希</strong></p>
<p>Distributed Hash Table（DHT）：对于哈希空间 [0, 2<sup>n</sup>-1]，将该哈希空间看成一个哈希环，将每个节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<p>一致性哈希的优点是在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将数据对象 C 重新存放到节点 X 上即可，对于节点 A、B、D 都没有影响。</p>
<h3 id="22-顺序分布"><a class="markdownIt-Anchor" href="#22-顺序分布"></a> 2.2. 顺序分布</h3>
<p>哈希分布式破坏了数据的有序性，顺序分布则不会。</p>
<p>顺序分布的数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如下图中，User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p>
<p>顺序分布的优点是可以充分利用每个节点的空间，而哈希分布很难控制一个节点存储多少数据。</p>
<p>但是顺序分布需要使用一个映射表来存储数据到节点的映射，这个映射表通常使用单独的节点来存储。当数据量非常大时，映射表也随着变大，那么一个节点就可能无法存放下整个映射表。并且单个节点维护着整个映射表的开销很大，查找速度也会变慢。为了解决以上问题，引入了一个中间层，也就是 Meta 表，从而分担映射表的维护工作。</p>
<h3 id="23-负载均衡"><a class="markdownIt-Anchor" href="#23-负载均衡"></a> 2.3. 负载均衡</h3>
<p>衡量负载的因素很多，如 CPU、内存、磁盘等资源使用情况、读写请求数等。</p>
<p>分布式系统存储应当能够自动负载均衡，当某个节点的负载较高，将它的部分数据迁移到其它节点。</p>
<p>每个集群都有一个总控节点，其它节点为工作节点，由总控节点根据全局负载信息进行整体调度，工作节点定时发送心跳包（Heartbeat）将节点负载相关的信息发送给总控节点。</p>
<p>一个新上线的工作节点，由于其负载较低，如果不加控制，总控节点会将大量数据同时迁移到该节点上，造成该节点一段时间内无法工作。因此负载均衡操作需要平滑进行，新加入的节点需要较长的一段时间来达到比较均衡的状态。</p>
<h2 id="3-分布式理论"><a class="markdownIt-Anchor" href="#3-分布式理论"></a> 3. 分布式理论</h2>
<h3 id="31-cap"><a class="markdownIt-Anchor" href="#31-cap"></a> 3.1. CAP</h3>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式理论-CAP.jpg" width="450"/>
</div>
<h4 id="一致性-2"><a class="markdownIt-Anchor" href="#一致性-2"></a> 一致性</h4>
<p>一致性指的是多个数据副本是否能保持一致的特性。</p>
<p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<h4 id="可用性-2"><a class="markdownIt-Anchor" href="#可用性-2"></a> 可用性</h4>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="分区容忍性"><a class="markdownIt-Anchor" href="#分区容忍性"></a> 分区容忍性</h4>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h4 id="权衡"><a class="markdownIt-Anchor" href="#权衡"></a> 权衡</h4>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；</li>
<li>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="32-base"><a class="markdownIt-Anchor" href="#32-base"></a> 3.2. BASE</h3>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式理论-BASE.png" />
</div>
<h4 id="基本可用"><a class="markdownIt-Anchor" href="#基本可用"></a> 基本可用</h4>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h4 id="软状态"><a class="markdownIt-Anchor" href="#软状态"></a> 软状态</h4>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。</p>
<h4 id="最终一致性"><a class="markdownIt-Anchor" href="#最终一致性"></a> 最终一致性</h4>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="4-分布式事务问题"><a class="markdownIt-Anchor" href="#4-分布式事务问题"></a> 4. 分布式事务问题</h2>
<h3 id="41-两阶段提交2pc"><a class="markdownIt-Anchor" href="#41-两阶段提交2pc"></a> 4.1. 两阶段提交（2PC）</h3>
<p>两阶段提交（Two-phase Commit，2PC）</p>
<p>主要用于实现分布式事务，分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</p>
<p>通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<h4 id="运行过程"><a class="markdownIt-Anchor" href="#运行过程"></a> 运行过程</h4>
<h5 id="准备阶段"><a class="markdownIt-Anchor" href="#准备阶段"></a> 准备阶段</h5>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式事务两阶段提交-01.jpg" />
</div>
<h5 id="提交阶段"><a class="markdownIt-Anchor" href="#提交阶段"></a> 提交阶段</h5>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式事务两阶段提交-02.jpg" />
</div>
需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。
<h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4>
<h5 id="同步阻塞"><a class="markdownIt-Anchor" href="#同步阻塞"></a> 同步阻塞</h5>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p>
<h5 id="单点问题"><a class="markdownIt-Anchor" href="#单点问题"></a> 单点问题</h5>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p>
<h5 id="数据不一致"><a class="markdownIt-Anchor" href="#数据不一致"></a> 数据不一致</h5>
<p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
<h5 id="太过保守"><a class="markdownIt-Anchor" href="#太过保守"></a> 太过保守</h5>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<h4 id="2pc-优缺点"><a class="markdownIt-Anchor" href="#2pc-优缺点"></a> 2PC 优缺点</h4>
<p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致）<br />
缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p>
<h3 id="42-补偿事务tcc"><a class="markdownIt-Anchor" href="#42-补偿事务tcc"></a> 4.2. 补偿事务（TCC）</h3>
<p>补偿事务（TCC）其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ol>
<li>Try 阶段主要是对业务系统做检测及资源预留。</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ol>
<p>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p>
<ol>
<li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li>
<li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li>
<li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li>
</ol>
<h4 id="tcc-优缺点"><a class="markdownIt-Anchor" href="#tcc-优缺点"></a> TCC 优缺点</h4>
<ul>
<li>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</li>
<li>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</li>
</ul>
<h3 id="43-本地消息表异步确保"><a class="markdownIt-Anchor" href="#43-本地消息表异步确保"></a> 4.3. 本地消息表（异步确保）</h3>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/分布式事务本地消息.jpg" />
</div>
<p>这种方案遵循 BASE 理论，采用的是最终一致性。</p>
<p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p>
<h4 id="本地消息表优缺点"><a class="markdownIt-Anchor" href="#本地消息表优缺点"></a> 本地消息表优缺点</h4>
<ul>
<li>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li>
<li>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li>
</ul>
<h3 id="44-mq-事务消息"><a class="markdownIt-Anchor" href="#44-mq-事务消息"></a> 4.4. MQ 事务消息</h3>
<p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p>
<ol>
<li>Prepared 消息，会拿到消息的地址。</li>
<li>执行本地事务。</li>
<li>通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ol>
<p>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<h4 id="mq-事务消息优缺点"><a class="markdownIt-Anchor" href="#mq-事务消息优缺点"></a> MQ 事务消息优缺点</h4>
<ul>
<li>优点：实现了最终一致性，不需要依赖本地数据库事务。</li>
<li>缺点：实现难度大，主流 MQ 不支持。</li>
</ul>
<h2 id="5-共识性问题"><a class="markdownIt-Anchor" href="#5-共识性问题"></a> 5. 共识性问题</h2>
<h3 id="51-paxos"><a class="markdownIt-Anchor" href="#51-paxos"></a> 5.1. Paxos</h3>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<p>算法需要满足 safety 和 liveness 两方面的约束要求（实际上这两个基础属性是大部分分布式算法都该考虑的）：</p>
<ul>
<li>safety：保证决议结果是对的，无歧义的，不会出现错误情况。
<ul>
<li>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；</li>
<li>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；</li>
</ul>
</li>
<li>liveness：保证决议过程能在有限时间内完成。
<ul>
<li>决议总会产生，并且 learners 能获得被批准（chosen）的决议。</li>
</ul>
</li>
</ul>
<p>基本过程包括 proposer 提出提案，先争取大多数 acceptor 的支持，超过一半支持时，则发送结案结果给所有人进行确认。一个潜在的问题是 proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新的一轮提案的 proposer 都恰好故障，系统则永远无法达成一致（概率很小）。</p>
<p>Paxos 能保证在超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 的正常节点存在时，系统能达成共识。</p>
<h4 id="单个提案者多接收者"><a class="markdownIt-Anchor" href="#单个提案者多接收者"></a> 单个提案者+多接收者</h4>
<p>如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接收者的投票，即可认为通过，因为系统中不存在其他的提案。</p>
<p>但一旦提案者故障，则系统无法工作。</p>
<h4 id="多个提案者单个接收者"><a class="markdownIt-Anchor" href="#多个提案者单个接收者"></a> 多个提案者+单个接收者</h4>
<p>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。</p>
<p>缺陷也是容易发生单点故障，包括接收者故障或首个提案者节点故障。</p>
<p>以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。</p>
<p>当提案者和接收者都推广到多个的情形，会出现一些挑战。</p>
<h4 id="多个提案者多个接收者"><a class="markdownIt-Anchor" href="#多个提案者多个接收者"></a> 多个提案者+多个接收者</h4>
<p>既然限定单提案者或单接收者都会出现故障，那么就得允许出现多个提案者和多个接收者。问题一下子变得复杂了。</p>
<p>一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个数字来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。</p>
<p>另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。</p>
<p>如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。</p>
<p>此外，提案者即便收到了多数接收者的投票，也不敢说就一定通过。因为在此过程中系统可能还有其它的提案。</p>
<h3 id="52-raft"><a class="markdownIt-Anchor" href="#52-raft"></a> 5.2. Raft</h3>
<p>Raft 算法是 Paxos 算法的一种简化实现。</p>
<p>包括三种角色：leader、candidate 和 follower，其基本过程为：</p>
<ul>
<li><strong>Leader 选举</strong> - 每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；</li>
<li><strong>同步 log</strong> - leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；</li>
</ul>
<p><em>注：此处 log 并非是指日志消息，而是各种事件的发生记录。</em></p>
<h4 id="单个-candidate-的竞选"><a class="markdownIt-Anchor" href="#单个-candidate-的竞选"></a> 单个 Candidate 的竞选</h4>
<p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-01.gif" />
</div>
<ul>
<li>此时 A 发送投票请求给其它所有节点。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-02.gif" />
</div>
<ul>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-03.gif" />
</div>
<ul>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-candidate-04.gif" />
</div>
<h4 id="多个-candidate-竞选"><a class="markdownIt-Anchor" href="#多个-candidate-竞选"></a> 多个 Candidate 竞选</h4>
<ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-multi-candidate-01.gif" />
</div>
<ul>
<li>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-multi-candidate-02.gif" />
</div>
<h4 id="同步日志"><a class="markdownIt-Anchor" href="#同步日志"></a> 同步日志</h4>
<ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-01.gif" />
</div>
<ul>
<li>Leader 会把修改复制到所有 Follower。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-02.gif" />
</div>
<ul>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-03.gif" />
</div>
<ul>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/distributed/architecture/raft-sync-log-04.gif" />
</div>
<h2 id="6-分布式缓存问题"><a class="markdownIt-Anchor" href="#6-分布式缓存问题"></a> 6. 分布式缓存问题</h2>
<h3 id="61-缓存雪崩"><a class="markdownIt-Anchor" href="#61-缓存雪崩"></a> 6.1. 缓存雪崩</h3>
<p>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>解决方案：</p>
<ul>
<li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。</li>
<li>还有一个简单的方案，就是将缓存失效时间分散开，不要所有缓存时间长度都设置成 5 分钟或者 10 分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
</ul>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<h3 id="62-缓存穿透"><a class="markdownIt-Anchor" href="#62-缓存穿透"></a> 6.2. 缓存穿透</h3>
<p>缓存穿透是指：用户查询的数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p>
<p>解决方案：</p>
<ol>
<li>在封装的缓存 SET 和 GET 部分增加个步骤，如果查询一个 KEY 不存在，就以这个 KEY 为前缀设定一个标识 KEY；以后再查询该 KEY 的时候，先查询标识 KEY，如果标识 KEY 存在，就返回一个协定好的非 false 或者 NULL 值，然后 APP 做相应的处理，这样缓存层就不会被穿透。当然这个验证 KEY 的失效时间不能太长。</li>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h3 id="63-缓存预热"><a class="markdownIt-Anchor" href="#63-缓存预热"></a> 6.3. 缓存预热</h3>
<p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="64-缓存更新"><a class="markdownIt-Anchor" href="#64-缓存更新"></a> 6.4. 缓存更新</h3>
<p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="65-缓存降级"><a class="markdownIt-Anchor" href="#65-缓存降级"></a> 6.5. 缓存降级</h3>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li>杨传辉. 大规模分布式存储系统: 原理解析与架构实战[M]. 机械工业出版社, 2013.</li>
<li><a href="https://www.gitbook.com/book/yeasy/blockchain_guide/details" target="_blank" rel="noopener">区块链技术指南</a></li>
<li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener">NEAT ALGORITHMS - PAXOS</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/bigdata/Flume/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/bigdata/Flume/" class="post-title-link" itemprop="url">Flume</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">2018-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-08 18:07:48" itemprop="dateModified" datetime="2019-05-08T18:07:48+08:00">2019-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/bigdata/" itemprop="url" rel="index">
                    <span itemprop="name">bigdata</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/bigdata/Flume/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="bigdata/Flume/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="flume"><a class="markdownIt-Anchor" href="#flume"></a> Flume</h1>
<blockquote>
<p><strong>Sqoop 是一个主要在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#flume-%E7%AE%80%E4%BB%8B">Flume 简介</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-flume-">什么是 Flume ？</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
</ul>
</li>
<li><a href="#flume-%E5%8E%9F%E7%90%86">Flume 原理</a>
<ul>
<li><a href="#flume-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Flume 基本概念</a></li>
<li><a href="#flume-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6">Flume 基本组件</a></li>
<li><a href="#flume-%E6%95%B0%E6%8D%AE%E6%B5%81">Flume 数据流</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
</ul>
<!-- /TOC -->
<h2 id="flume-简介"><a class="markdownIt-Anchor" href="#flume-简介"></a> Flume 简介</h2>
<h3 id="什么是-flume"><a class="markdownIt-Anchor" href="#什么是-flume"></a> 什么是 Flume ？</h3>
<p>Flume 是一个分布式海量数据采集、聚合和传输系统。</p>
<p>特点</p>
<ul>
<li>基于事件的海量数据采集</li>
<li>数据流模型：Source -&gt; Channel -&gt; Sink</li>
<li>事务机制：支持重读重写，保证消息传递的可靠性</li>
<li>内置丰富插件：轻松与各种外部系统集成</li>
<li>高可用：Agent 主备切换</li>
<li>Java 实现：开源，优秀的系统设计</li>
</ul>
<h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3>
<h2 id="flume-原理"><a class="markdownIt-Anchor" href="#flume-原理"></a> Flume 原理</h2>
<h3 id="flume-基本概念"><a class="markdownIt-Anchor" href="#flume-基本概念"></a> Flume 基本概念</h3>
<ul>
<li>Event：事件，最小数据传输单元，由 Header 和 Body 组成。</li>
<li>Agent：代理，JVM 进程，最小运行单元，由 Source、Channel、Sink 三个基本组件构成，负责将外部数据源产生的数据以 Event 的形式传输到目的地
<ul>
<li>Source：负责对接各种外部数据源，将采集到的数据封装成 Event，然后写入 Channel</li>
<li>Channel：Event 暂存容器，负责保存 Source 发送的 Event，直至被 Sink 成功读取</li>
<li>Sink：负责从 Channel 读取 Event，然后将其写入外部存储，或传输给下一阶段的 Agent</li>
<li>映射关系：1 个 Source -&gt; 多个 Channel，1 个 Channel -&gt; 多个 Sink，1 个 Sink -&gt; 1 个 Channel</li>
</ul>
</li>
</ul>
<h3 id="flume-基本组件"><a class="markdownIt-Anchor" href="#flume-基本组件"></a> Flume 基本组件</h3>
<h4 id="source-组件"><a class="markdownIt-Anchor" href="#source-组件"></a> Source 组件</h4>
<ul>
<li>对接各种外部数据源，将采集到的数据封装成 Event，然后写入 Channel</li>
<li>一个 Source 可向多个 Channel 发送 Event</li>
<li>Flume 内置类型丰富的 Source，同时用户可自定义 Source</li>
</ul>
<h4 id="channel-组件"><a class="markdownIt-Anchor" href="#channel-组件"></a> Channel 组件</h4>
<ul>
<li>Event 中转暂存区，存储 Source 采集但未被 Sink 读取的 Event</li>
<li>为了平衡 Source 采集、Sink 读取的速度，可视为 Flume 内部的消息队列</li>
<li>线程安全并具有事务性，支持 Source 写失败重写和 Sink 读失败重读</li>
</ul>
<h4 id="sink-组件"><a class="markdownIt-Anchor" href="#sink-组件"></a> Sink 组件</h4>
<ul>
<li>从 Channel 读取 Event，将其写入外部存储，或传输到下一阶段的 Agent</li>
<li>一个 Sink 只能从一个 Channel 中读取 Event</li>
<li>Sink 成功读取 Event 后，向 Channel 提交事务，Event 被删除，否则 Channel 会等待 Sink 重新读取</li>
</ul>
<h3 id="flume-数据流"><a class="markdownIt-Anchor" href="#flume-数据流"></a> Flume 数据流</h3>
<p>单层架构</p>
<p>优点：架构简单，使用方便，占用资源较少<br />
缺点<br />
如果采集的数据源或Agent较多，将Event写入到HDFS会产生很多小文件<br />
外部存储升级维护或发生故障，需对采集层的所有Agent做处理，人力成本较高，系统稳定性较差<br />
系统安全性较差<br />
数据源管理较混乱</p>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/bigdata/Sqoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/bigdata/Sqoop/" class="post-title-link" itemprop="url">Sqoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">2018-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-21 13:20:28" itemprop="dateModified" datetime="2019-08-21T13:20:28+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/bigdata/" itemprop="url" rel="index">
                    <span itemprop="name">bigdata</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/bigdata/Sqoop/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="bigdata/Sqoop/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>503</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sqoop"><a class="markdownIt-Anchor" href="#sqoop"></a> Sqoop</h1>
<blockquote>
<p><strong>Sqoop 是一个主要在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#sqoop-%E7%AE%80%E4%BB%8B">Sqoop 简介</a>
<ul>
<li><a href="#%E6%8F%90%E4%BE%9B%E5%A4%9A%E7%A7%8D-sqoop-%E8%BF%9E%E6%8E%A5%E5%99%A8">提供多种 Sqoop 连接器</a></li>
<li><a href="#sqoop-%E7%89%88%E6%9C%AC">Sqoop 版本</a></li>
</ul>
</li>
<li><a href="#sqoop-%E5%8E%9F%E7%90%86">Sqoop 原理</a>
<ul>
<li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li>
<li><a href="#%E5%AF%BC%E5%87%BA">导出</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="sqoop-简介"><a class="markdownIt-Anchor" href="#sqoop-简介"></a> Sqoop 简介</h2>
<p><strong>Sqoop 是一个主要在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
<ul>
<li>Hadoop：HDFS、Hive、HBase、Inceptor、Hyperbase</li>
<li>面向大数据集的批量导入导出</li>
<li>将输入数据集分为 N 个切片，然后启动 N 个 Map 任务并行传输</li>
<li>支持全量、增量两种传输方式</li>
</ul>
<h3 id="提供多种-sqoop-连接器"><a class="markdownIt-Anchor" href="#提供多种-sqoop-连接器"></a> 提供多种 Sqoop 连接器</h3>
<h4 id="内置连接器"><a class="markdownIt-Anchor" href="#内置连接器"></a> 内置连接器</h4>
<ul>
<li>经过优化的专用 RDBMS 连接器：MySQL、PostgreSQL、Oracle、DB2、SQL Server、Netzza 等</li>
<li>通用的 JDBC 连接器：支持 JDBC 协议的数据库</li>
</ul>
<h4 id="第三方连接器"><a class="markdownIt-Anchor" href="#第三方连接器"></a> 第三方连接器</h4>
<ul>
<li>数据仓库：Teradata</li>
<li>NoSQL 数据库：Couchbase</li>
</ul>
<h3 id="sqoop-版本"><a class="markdownIt-Anchor" href="#sqoop-版本"></a> Sqoop 版本</h3>
<h4 id="sqoop-1-优缺点"><a class="markdownIt-Anchor" href="#sqoop-1-优缺点"></a> Sqoop 1 优缺点</h4>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-architecture.png"/></div>
<p>优点</p>
<ul>
<li>架构简单</li>
<li>部署简单</li>
<li>功能全面</li>
<li>稳定性较高</li>
<li>速度较快</li>
</ul>
<p>缺点</p>
<ul>
<li>访问方式单一</li>
<li>命令行方式容易出错，格式紧耦合</li>
<li>安全机制不够完善，存在密码泄露风险</li>
</ul>
<h4 id="sqoop-2-优缺点"><a class="markdownIt-Anchor" href="#sqoop-2-优缺点"></a> Sqoop 2 优缺点</h4>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-v2-architecture.png"/></div>
<p>优点</p>
<ul>
<li>访问方式多样</li>
<li>集中管理连接器</li>
<li>安全机制较完善</li>
<li>支持多用户</li>
</ul>
<p>缺点</p>
<ul>
<li>架构较复杂</li>
<li>部署较繁琐</li>
<li>稳定性一般</li>
<li>速度一般</li>
</ul>
<h2 id="sqoop-原理"><a class="markdownIt-Anchor" href="#sqoop-原理"></a> Sqoop 原理</h2>
<h3 id="导入"><a class="markdownIt-Anchor" href="#导入"></a> 导入</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-import.png"/></div>
<h3 id="导出"><a class="markdownIt-Anchor" href="#导出"></a> 导出</h3>
<div align="center"><img src="http://dunwu.test.upcdn.net/cs/bigdata/Sqoop/sqoop-export.png"/></div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><a class="extend next" rel="next" href="/blog/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">329k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:59</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>
<script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script>
<script src="/blog/js/schemes/pisces.js"></script>
<script src="/blog/js/next-boot.js"></script><script src="/blog/js/bookmark.js"></script>



  




  <script src="/blog/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
